diff --git a/node_modules/nextra/context.js b/node_modules/nextra/context.js
deleted file mode 100644
index 77e9dd1..0000000
--- a/node_modules/nextra/context.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/context')
diff --git a/node_modules/nextra/data.js b/node_modules/nextra/data.js
deleted file mode 100755
index 9016f08..0000000
--- a/node_modules/nextra/data.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/ssg')
diff --git a/node_modules/nextra/dist/compile.mjs b/node_modules/nextra/dist/compile.mjs
new file mode 100644
index 0000000..34bf62e
--- /dev/null
+++ b/node_modules/nextra/dist/compile.mjs
@@ -0,0 +1,41108 @@
+var __create = Object.create;
+var __defProp = Object.defineProperty;
+var __defProps = Object.defineProperties;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getOwnPropSymbols = Object.getOwnPropertySymbols;
+var __getProtoOf = Object.getPrototypeOf;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __propIsEnum = Object.prototype.propertyIsEnumerable;
+var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __spreadValues = (a, b) => {
+  for (var prop in b || (b = {}))
+    if (__hasOwnProp.call(b, prop))
+      __defNormalProp(a, prop, b[prop]);
+  if (__getOwnPropSymbols)
+    for (var prop of __getOwnPropSymbols(b)) {
+      if (__propIsEnum.call(b, prop))
+        __defNormalProp(a, prop, b[prop]);
+    }
+  return a;
+};
+var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
+var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
+var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
+  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
+}) : x)(function(x) {
+  if (typeof require !== "undefined")
+    return require.apply(this, arguments);
+  throw new Error('Dynamic require of "' + x + '" is not supported');
+});
+var __objRest = (source, exclude) => {
+  var target = {};
+  for (var prop in source)
+    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
+      target[prop] = source[prop];
+  if (source != null && __getOwnPropSymbols)
+    for (var prop of __getOwnPropSymbols(source)) {
+      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
+        target[prop] = source[prop];
+    }
+  return target;
+};
+var __commonJS = (cb, mod) => function __require2() {
+  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
+};
+var __export = (target, all4) => {
+  for (var name3 in all4)
+    __defProp(target, name3, { get: all4[name3], enumerable: true });
+};
+var __reExport = (target, module, copyDefault, desc) => {
+  if (module && typeof module === "object" || typeof module === "function") {
+    for (let key of __getOwnPropNames(module))
+      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
+        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
+  }
+  return target;
+};
+var __toESM = (module, isNodeMode) => {
+  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
+};
+var __async = (__this, __arguments, generator) => {
+  return new Promise((resolve, reject) => {
+    var fulfilled = (value) => {
+      try {
+        step(generator.next(value));
+      } catch (e) {
+        reject(e);
+      }
+    };
+    var rejected = (value) => {
+      try {
+        step(generator.throw(value));
+      } catch (e) {
+        reject(e);
+      }
+    };
+    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
+    step((generator = generator.apply(__this, __arguments)).next());
+  });
+};
+
+// ../../node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js
+var require_is_buffer = __commonJS({
+  "../../node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js"(exports, module) {
+    module.exports = function isBuffer4(obj) {
+      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
+    };
+  }
+});
+
+// ../../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js
+var require_extend = __commonJS({
+  "../../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js"(exports, module) {
+    "use strict";
+    var hasOwn3 = Object.prototype.hasOwnProperty;
+    var toStr2 = Object.prototype.toString;
+    var defineProperty2 = Object.defineProperty;
+    var gOPD2 = Object.getOwnPropertyDescriptor;
+    var isArray4 = function isArray5(arr) {
+      if (typeof Array.isArray === "function") {
+        return Array.isArray(arr);
+      }
+      return toStr2.call(arr) === "[object Array]";
+    };
+    var isPlainObject4 = function isPlainObject5(obj) {
+      if (!obj || toStr2.call(obj) !== "[object Object]") {
+        return false;
+      }
+      var hasOwnConstructor = hasOwn3.call(obj, "constructor");
+      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn3.call(obj.constructor.prototype, "isPrototypeOf");
+      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
+        return false;
+      }
+      var key;
+      for (key in obj) {
+      }
+      return typeof key === "undefined" || hasOwn3.call(obj, key);
+    };
+    var setProperty3 = function setProperty4(target, options) {
+      if (defineProperty2 && options.name === "__proto__") {
+        defineProperty2(target, options.name, {
+          enumerable: true,
+          configurable: true,
+          value: options.newValue,
+          writable: true
+        });
+      } else {
+        target[options.name] = options.newValue;
+      }
+    };
+    var getProperty3 = function getProperty4(obj, name3) {
+      if (name3 === "__proto__") {
+        if (!hasOwn3.call(obj, name3)) {
+          return void 0;
+        } else if (gOPD2) {
+          return gOPD2(obj, name3).value;
+        }
+      }
+      return obj[name3];
+    };
+    module.exports = function extend5() {
+      var options, name3, src, copy, copyIsArray, clone;
+      var target = arguments[0];
+      var i = 1;
+      var length = arguments.length;
+      var deep = false;
+      if (typeof target === "boolean") {
+        deep = target;
+        target = arguments[1] || {};
+        i = 2;
+      }
+      if (target == null || typeof target !== "object" && typeof target !== "function") {
+        target = {};
+      }
+      for (; i < length; ++i) {
+        options = arguments[i];
+        if (options != null) {
+          for (name3 in options) {
+            src = getProperty3(target, name3);
+            copy = getProperty3(options, name3);
+            if (target !== copy) {
+              if (deep && copy && (isPlainObject4(copy) || (copyIsArray = isArray4(copy)))) {
+                if (copyIsArray) {
+                  copyIsArray = false;
+                  clone = src && isArray4(src) ? src : [];
+                } else {
+                  clone = src && isPlainObject4(src) ? src : {};
+                }
+                setProperty3(target, { name: name3, newValue: extend5(deep, clone, copy) });
+              } else if (typeof copy !== "undefined") {
+                setProperty3(target, { name: name3, newValue: copy });
+              }
+            }
+          }
+        }
+      }
+      return target;
+    };
+  }
+});
+
+// ../../node_modules/.pnpm/acorn-jsx@5.3.2_acorn@8.7.0/node_modules/acorn-jsx/xhtml.js
+var require_xhtml = __commonJS({
+  "../../node_modules/.pnpm/acorn-jsx@5.3.2_acorn@8.7.0/node_modules/acorn-jsx/xhtml.js"(exports, module) {
+    module.exports = {
+      quot: '"',
+      amp: "&",
+      apos: "'",
+      lt: "<",
+      gt: ">",
+      nbsp: "\xA0",
+      iexcl: "\xA1",
+      cent: "\xA2",
+      pound: "\xA3",
+      curren: "\xA4",
+      yen: "\xA5",
+      brvbar: "\xA6",
+      sect: "\xA7",
+      uml: "\xA8",
+      copy: "\xA9",
+      ordf: "\xAA",
+      laquo: "\xAB",
+      not: "\xAC",
+      shy: "\xAD",
+      reg: "\xAE",
+      macr: "\xAF",
+      deg: "\xB0",
+      plusmn: "\xB1",
+      sup2: "\xB2",
+      sup3: "\xB3",
+      acute: "\xB4",
+      micro: "\xB5",
+      para: "\xB6",
+      middot: "\xB7",
+      cedil: "\xB8",
+      sup1: "\xB9",
+      ordm: "\xBA",
+      raquo: "\xBB",
+      frac14: "\xBC",
+      frac12: "\xBD",
+      frac34: "\xBE",
+      iquest: "\xBF",
+      Agrave: "\xC0",
+      Aacute: "\xC1",
+      Acirc: "\xC2",
+      Atilde: "\xC3",
+      Auml: "\xC4",
+      Aring: "\xC5",
+      AElig: "\xC6",
+      Ccedil: "\xC7",
+      Egrave: "\xC8",
+      Eacute: "\xC9",
+      Ecirc: "\xCA",
+      Euml: "\xCB",
+      Igrave: "\xCC",
+      Iacute: "\xCD",
+      Icirc: "\xCE",
+      Iuml: "\xCF",
+      ETH: "\xD0",
+      Ntilde: "\xD1",
+      Ograve: "\xD2",
+      Oacute: "\xD3",
+      Ocirc: "\xD4",
+      Otilde: "\xD5",
+      Ouml: "\xD6",
+      times: "\xD7",
+      Oslash: "\xD8",
+      Ugrave: "\xD9",
+      Uacute: "\xDA",
+      Ucirc: "\xDB",
+      Uuml: "\xDC",
+      Yacute: "\xDD",
+      THORN: "\xDE",
+      szlig: "\xDF",
+      agrave: "\xE0",
+      aacute: "\xE1",
+      acirc: "\xE2",
+      atilde: "\xE3",
+      auml: "\xE4",
+      aring: "\xE5",
+      aelig: "\xE6",
+      ccedil: "\xE7",
+      egrave: "\xE8",
+      eacute: "\xE9",
+      ecirc: "\xEA",
+      euml: "\xEB",
+      igrave: "\xEC",
+      iacute: "\xED",
+      icirc: "\xEE",
+      iuml: "\xEF",
+      eth: "\xF0",
+      ntilde: "\xF1",
+      ograve: "\xF2",
+      oacute: "\xF3",
+      ocirc: "\xF4",
+      otilde: "\xF5",
+      ouml: "\xF6",
+      divide: "\xF7",
+      oslash: "\xF8",
+      ugrave: "\xF9",
+      uacute: "\xFA",
+      ucirc: "\xFB",
+      uuml: "\xFC",
+      yacute: "\xFD",
+      thorn: "\xFE",
+      yuml: "\xFF",
+      OElig: "\u0152",
+      oelig: "\u0153",
+      Scaron: "\u0160",
+      scaron: "\u0161",
+      Yuml: "\u0178",
+      fnof: "\u0192",
+      circ: "\u02C6",
+      tilde: "\u02DC",
+      Alpha: "\u0391",
+      Beta: "\u0392",
+      Gamma: "\u0393",
+      Delta: "\u0394",
+      Epsilon: "\u0395",
+      Zeta: "\u0396",
+      Eta: "\u0397",
+      Theta: "\u0398",
+      Iota: "\u0399",
+      Kappa: "\u039A",
+      Lambda: "\u039B",
+      Mu: "\u039C",
+      Nu: "\u039D",
+      Xi: "\u039E",
+      Omicron: "\u039F",
+      Pi: "\u03A0",
+      Rho: "\u03A1",
+      Sigma: "\u03A3",
+      Tau: "\u03A4",
+      Upsilon: "\u03A5",
+      Phi: "\u03A6",
+      Chi: "\u03A7",
+      Psi: "\u03A8",
+      Omega: "\u03A9",
+      alpha: "\u03B1",
+      beta: "\u03B2",
+      gamma: "\u03B3",
+      delta: "\u03B4",
+      epsilon: "\u03B5",
+      zeta: "\u03B6",
+      eta: "\u03B7",
+      theta: "\u03B8",
+      iota: "\u03B9",
+      kappa: "\u03BA",
+      lambda: "\u03BB",
+      mu: "\u03BC",
+      nu: "\u03BD",
+      xi: "\u03BE",
+      omicron: "\u03BF",
+      pi: "\u03C0",
+      rho: "\u03C1",
+      sigmaf: "\u03C2",
+      sigma: "\u03C3",
+      tau: "\u03C4",
+      upsilon: "\u03C5",
+      phi: "\u03C6",
+      chi: "\u03C7",
+      psi: "\u03C8",
+      omega: "\u03C9",
+      thetasym: "\u03D1",
+      upsih: "\u03D2",
+      piv: "\u03D6",
+      ensp: "\u2002",
+      emsp: "\u2003",
+      thinsp: "\u2009",
+      zwnj: "\u200C",
+      zwj: "\u200D",
+      lrm: "\u200E",
+      rlm: "\u200F",
+      ndash: "\u2013",
+      mdash: "\u2014",
+      lsquo: "\u2018",
+      rsquo: "\u2019",
+      sbquo: "\u201A",
+      ldquo: "\u201C",
+      rdquo: "\u201D",
+      bdquo: "\u201E",
+      dagger: "\u2020",
+      Dagger: "\u2021",
+      bull: "\u2022",
+      hellip: "\u2026",
+      permil: "\u2030",
+      prime: "\u2032",
+      Prime: "\u2033",
+      lsaquo: "\u2039",
+      rsaquo: "\u203A",
+      oline: "\u203E",
+      frasl: "\u2044",
+      euro: "\u20AC",
+      image: "\u2111",
+      weierp: "\u2118",
+      real: "\u211C",
+      trade: "\u2122",
+      alefsym: "\u2135",
+      larr: "\u2190",
+      uarr: "\u2191",
+      rarr: "\u2192",
+      darr: "\u2193",
+      harr: "\u2194",
+      crarr: "\u21B5",
+      lArr: "\u21D0",
+      uArr: "\u21D1",
+      rArr: "\u21D2",
+      dArr: "\u21D3",
+      hArr: "\u21D4",
+      forall: "\u2200",
+      part: "\u2202",
+      exist: "\u2203",
+      empty: "\u2205",
+      nabla: "\u2207",
+      isin: "\u2208",
+      notin: "\u2209",
+      ni: "\u220B",
+      prod: "\u220F",
+      sum: "\u2211",
+      minus: "\u2212",
+      lowast: "\u2217",
+      radic: "\u221A",
+      prop: "\u221D",
+      infin: "\u221E",
+      ang: "\u2220",
+      and: "\u2227",
+      or: "\u2228",
+      cap: "\u2229",
+      cup: "\u222A",
+      "int": "\u222B",
+      there4: "\u2234",
+      sim: "\u223C",
+      cong: "\u2245",
+      asymp: "\u2248",
+      ne: "\u2260",
+      equiv: "\u2261",
+      le: "\u2264",
+      ge: "\u2265",
+      sub: "\u2282",
+      sup: "\u2283",
+      nsub: "\u2284",
+      sube: "\u2286",
+      supe: "\u2287",
+      oplus: "\u2295",
+      otimes: "\u2297",
+      perp: "\u22A5",
+      sdot: "\u22C5",
+      lceil: "\u2308",
+      rceil: "\u2309",
+      lfloor: "\u230A",
+      rfloor: "\u230B",
+      lang: "\u2329",
+      rang: "\u232A",
+      loz: "\u25CA",
+      spades: "\u2660",
+      clubs: "\u2663",
+      hearts: "\u2665",
+      diams: "\u2666"
+    };
+  }
+});
+
+// ../../node_modules/.pnpm/acorn@8.7.0/node_modules/acorn/dist/acorn.js
+var require_acorn = __commonJS({
+  "../../node_modules/.pnpm/acorn@8.7.0/node_modules/acorn/dist/acorn.js"(exports, module) {
+    (function(global, factory2) {
+      typeof exports === "object" && typeof module !== "undefined" ? factory2(exports) : typeof define === "function" && define.amd ? define(["exports"], factory2) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory2(global.acorn = {}));
+    })(exports, function(exports2) {
+      "use strict";
+      var reservedWords2 = {
+        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
+        5: "class enum extends super const export import",
+        6: "enum",
+        strict: "implements interface let package private protected public static yield",
+        strictBind: "eval arguments"
+      };
+      var ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
+      var keywords$12 = {
+        5: ecma5AndLessKeywords2,
+        "5module": ecma5AndLessKeywords2 + " export import",
+        6: ecma5AndLessKeywords2 + " const class extends export import super"
+      };
+      var keywordRelationalOperator2 = /^in(stanceof)?$/;
+      var nonASCIIidentifierStartChars2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
+      var nonASCIIidentifierChars2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
+      var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
+      var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
+      nonASCIIidentifierStartChars2 = nonASCIIidentifierChars2 = null;
+      var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
+      var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
+      function isInAstralSet2(code3, set) {
+        var pos = 65536;
+        for (var i2 = 0; i2 < set.length; i2 += 2) {
+          pos += set[i2];
+          if (pos > code3) {
+            return false;
+          }
+          pos += set[i2 + 1];
+          if (pos >= code3) {
+            return true;
+          }
+        }
+      }
+      function isIdentifierStart2(code3, astral) {
+        if (code3 < 65) {
+          return code3 === 36;
+        }
+        if (code3 < 91) {
+          return true;
+        }
+        if (code3 < 97) {
+          return code3 === 95;
+        }
+        if (code3 < 123) {
+          return true;
+        }
+        if (code3 <= 65535) {
+          return code3 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code3));
+        }
+        if (astral === false) {
+          return false;
+        }
+        return isInAstralSet2(code3, astralIdentifierStartCodes2);
+      }
+      function isIdentifierChar2(code3, astral) {
+        if (code3 < 48) {
+          return code3 === 36;
+        }
+        if (code3 < 58) {
+          return true;
+        }
+        if (code3 < 65) {
+          return false;
+        }
+        if (code3 < 91) {
+          return true;
+        }
+        if (code3 < 97) {
+          return code3 === 95;
+        }
+        if (code3 < 123) {
+          return true;
+        }
+        if (code3 <= 65535) {
+          return code3 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code3));
+        }
+        if (astral === false) {
+          return false;
+        }
+        return isInAstralSet2(code3, astralIdentifierStartCodes2) || isInAstralSet2(code3, astralIdentifierCodes2);
+      }
+      var TokenType3 = function TokenType4(label, conf) {
+        if (conf === void 0)
+          conf = {};
+        this.label = label;
+        this.keyword = conf.keyword;
+        this.beforeExpr = !!conf.beforeExpr;
+        this.startsExpr = !!conf.startsExpr;
+        this.isLoop = !!conf.isLoop;
+        this.isAssign = !!conf.isAssign;
+        this.prefix = !!conf.prefix;
+        this.postfix = !!conf.postfix;
+        this.binop = conf.binop || null;
+        this.updateContext = null;
+      };
+      function binop2(name3, prec) {
+        return new TokenType3(name3, { beforeExpr: true, binop: prec });
+      }
+      var beforeExpr2 = { beforeExpr: true }, startsExpr2 = { startsExpr: true };
+      var keywords2 = {};
+      function kw2(name3, options) {
+        if (options === void 0)
+          options = {};
+        options.keyword = name3;
+        return keywords2[name3] = new TokenType3(name3, options);
+      }
+      var types$12 = {
+        num: new TokenType3("num", startsExpr2),
+        regexp: new TokenType3("regexp", startsExpr2),
+        string: new TokenType3("string", startsExpr2),
+        name: new TokenType3("name", startsExpr2),
+        privateId: new TokenType3("privateId", startsExpr2),
+        eof: new TokenType3("eof"),
+        bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }),
+        bracketR: new TokenType3("]"),
+        braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }),
+        braceR: new TokenType3("}"),
+        parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }),
+        parenR: new TokenType3(")"),
+        comma: new TokenType3(",", beforeExpr2),
+        semi: new TokenType3(";", beforeExpr2),
+        colon: new TokenType3(":", beforeExpr2),
+        dot: new TokenType3("."),
+        question: new TokenType3("?", beforeExpr2),
+        questionDot: new TokenType3("?."),
+        arrow: new TokenType3("=>", beforeExpr2),
+        template: new TokenType3("template"),
+        invalidTemplate: new TokenType3("invalidTemplate"),
+        ellipsis: new TokenType3("...", beforeExpr2),
+        backQuote: new TokenType3("`", startsExpr2),
+        dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }),
+        eq: new TokenType3("=", { beforeExpr: true, isAssign: true }),
+        assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }),
+        incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }),
+        prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
+        logicalOR: binop2("||", 1),
+        logicalAND: binop2("&&", 2),
+        bitwiseOR: binop2("|", 3),
+        bitwiseXOR: binop2("^", 4),
+        bitwiseAND: binop2("&", 5),
+        equality: binop2("==/!=/===/!==", 6),
+        relational: binop2("</>/<=/>=", 7),
+        bitShift: binop2("<</>>/>>>", 8),
+        plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
+        modulo: binop2("%", 10),
+        star: binop2("*", 10),
+        slash: binop2("/", 10),
+        starstar: new TokenType3("**", { beforeExpr: true }),
+        coalesce: binop2("??", 1),
+        _break: kw2("break"),
+        _case: kw2("case", beforeExpr2),
+        _catch: kw2("catch"),
+        _continue: kw2("continue"),
+        _debugger: kw2("debugger"),
+        _default: kw2("default", beforeExpr2),
+        _do: kw2("do", { isLoop: true, beforeExpr: true }),
+        _else: kw2("else", beforeExpr2),
+        _finally: kw2("finally"),
+        _for: kw2("for", { isLoop: true }),
+        _function: kw2("function", startsExpr2),
+        _if: kw2("if"),
+        _return: kw2("return", beforeExpr2),
+        _switch: kw2("switch"),
+        _throw: kw2("throw", beforeExpr2),
+        _try: kw2("try"),
+        _var: kw2("var"),
+        _const: kw2("const"),
+        _while: kw2("while", { isLoop: true }),
+        _with: kw2("with"),
+        _new: kw2("new", { beforeExpr: true, startsExpr: true }),
+        _this: kw2("this", startsExpr2),
+        _super: kw2("super", startsExpr2),
+        _class: kw2("class", startsExpr2),
+        _extends: kw2("extends", beforeExpr2),
+        _export: kw2("export"),
+        _import: kw2("import", startsExpr2),
+        _null: kw2("null", startsExpr2),
+        _true: kw2("true", startsExpr2),
+        _false: kw2("false", startsExpr2),
+        _in: kw2("in", { beforeExpr: true, binop: 7 }),
+        _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }),
+        _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
+        _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
+        _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
+      };
+      var lineBreak2 = /\r\n?|\n|\u2028|\u2029/;
+      var lineBreakG2 = new RegExp(lineBreak2.source, "g");
+      function isNewLine2(code3) {
+        return code3 === 10 || code3 === 13 || code3 === 8232 || code3 === 8233;
+      }
+      function nextLineBreak2(code3, from, end) {
+        if (end === void 0)
+          end = code3.length;
+        for (var i2 = from; i2 < end; i2++) {
+          var next = code3.charCodeAt(i2);
+          if (isNewLine2(next)) {
+            return i2 < end - 1 && next === 13 && code3.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
+          }
+        }
+        return -1;
+      }
+      var nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
+      var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
+      var ref2 = Object.prototype;
+      var hasOwnProperty3 = ref2.hasOwnProperty;
+      var toString3 = ref2.toString;
+      var hasOwn3 = Object.hasOwn || function(obj, propName) {
+        return hasOwnProperty3.call(obj, propName);
+      };
+      var isArray4 = Array.isArray || function(obj) {
+        return toString3.call(obj) === "[object Array]";
+      };
+      function wordsRegexp2(words) {
+        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
+      }
+      var loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
+      var Position3 = function Position4(line, col) {
+        this.line = line;
+        this.column = col;
+      };
+      Position3.prototype.offset = function offset2(n) {
+        return new Position3(this.line, this.column + n);
+      };
+      var SourceLocation3 = function SourceLocation4(p, start3, end) {
+        this.start = start3;
+        this.end = end;
+        if (p.sourceFile !== null) {
+          this.source = p.sourceFile;
+        }
+      };
+      function getLineInfo2(input, offset2) {
+        for (var line = 1, cur = 0; ; ) {
+          var nextBreak = nextLineBreak2(input, cur, offset2);
+          if (nextBreak < 0) {
+            return new Position3(line, offset2 - cur);
+          }
+          ++line;
+          cur = nextBreak;
+        }
+      }
+      var defaultOptions2 = {
+        ecmaVersion: null,
+        sourceType: "script",
+        onInsertedSemicolon: null,
+        onTrailingComma: null,
+        allowReserved: null,
+        allowReturnOutsideFunction: false,
+        allowImportExportEverywhere: false,
+        allowAwaitOutsideFunction: null,
+        allowSuperOutsideMethod: null,
+        allowHashBang: false,
+        locations: false,
+        onToken: null,
+        onComment: null,
+        ranges: false,
+        program: null,
+        sourceFile: null,
+        directSourceFile: null,
+        preserveParens: false
+      };
+      var warnedAboutEcmaVersion2 = false;
+      function getOptions2(opts) {
+        var options = {};
+        for (var opt in defaultOptions2) {
+          options[opt] = opts && hasOwn3(opts, opt) ? opts[opt] : defaultOptions2[opt];
+        }
+        if (options.ecmaVersion === "latest") {
+          options.ecmaVersion = 1e8;
+        } else if (options.ecmaVersion == null) {
+          if (!warnedAboutEcmaVersion2 && typeof console === "object" && console.warn) {
+            warnedAboutEcmaVersion2 = true;
+            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
+          }
+          options.ecmaVersion = 11;
+        } else if (options.ecmaVersion >= 2015) {
+          options.ecmaVersion -= 2009;
+        }
+        if (options.allowReserved == null) {
+          options.allowReserved = options.ecmaVersion < 5;
+        }
+        if (isArray4(options.onToken)) {
+          var tokens = options.onToken;
+          options.onToken = function(token) {
+            return tokens.push(token);
+          };
+        }
+        if (isArray4(options.onComment)) {
+          options.onComment = pushComment2(options, options.onComment);
+        }
+        return options;
+      }
+      function pushComment2(options, array) {
+        return function(block, text7, start3, end, startLoc, endLoc) {
+          var comment3 = {
+            type: block ? "Block" : "Line",
+            value: text7,
+            start: start3,
+            end
+          };
+          if (options.locations) {
+            comment3.loc = new SourceLocation3(this, startLoc, endLoc);
+          }
+          if (options.ranges) {
+            comment3.range = [start3, end];
+          }
+          array.push(comment3);
+        };
+      }
+      var SCOPE_TOP2 = 1, SCOPE_FUNCTION2 = 2, SCOPE_ASYNC2 = 4, SCOPE_GENERATOR2 = 8, SCOPE_ARROW2 = 16, SCOPE_SIMPLE_CATCH2 = 32, SCOPE_SUPER2 = 64, SCOPE_DIRECT_SUPER2 = 128, SCOPE_CLASS_STATIC_BLOCK2 = 256, SCOPE_VAR2 = SCOPE_TOP2 | SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2;
+      function functionFlags2(async, generator) {
+        return SCOPE_FUNCTION2 | (async ? SCOPE_ASYNC2 : 0) | (generator ? SCOPE_GENERATOR2 : 0);
+      }
+      var BIND_NONE2 = 0, BIND_VAR2 = 1, BIND_LEXICAL2 = 2, BIND_FUNCTION2 = 3, BIND_SIMPLE_CATCH2 = 4, BIND_OUTSIDE2 = 5;
+      var Parser4 = function Parser6(options, input, startPos) {
+        this.options = options = getOptions2(options);
+        this.sourceFile = options.sourceFile;
+        this.keywords = wordsRegexp2(keywords$12[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
+        var reserved = "";
+        if (options.allowReserved !== true) {
+          reserved = reservedWords2[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
+          if (options.sourceType === "module") {
+            reserved += " await";
+          }
+        }
+        this.reservedWords = wordsRegexp2(reserved);
+        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
+        this.reservedWordsStrict = wordsRegexp2(reservedStrict);
+        this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind);
+        this.input = String(input);
+        this.containsEsc = false;
+        if (startPos) {
+          this.pos = startPos;
+          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
+          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length;
+        } else {
+          this.pos = this.lineStart = 0;
+          this.curLine = 1;
+        }
+        this.type = types$12.eof;
+        this.value = null;
+        this.start = this.end = this.pos;
+        this.startLoc = this.endLoc = this.curPosition();
+        this.lastTokEndLoc = this.lastTokStartLoc = null;
+        this.lastTokStart = this.lastTokEnd = this.pos;
+        this.context = this.initialContext();
+        this.exprAllowed = true;
+        this.inModule = options.sourceType === "module";
+        this.strict = this.inModule || this.strictDirective(this.pos);
+        this.potentialArrowAt = -1;
+        this.potentialArrowInForAwait = false;
+        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
+        this.labels = [];
+        this.undefinedExports = /* @__PURE__ */ Object.create(null);
+        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
+          this.skipLineComment(2);
+        }
+        this.scopeStack = [];
+        this.enterScope(SCOPE_TOP2);
+        this.regexpState = null;
+        this.privateNameStack = [];
+      };
+      var prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
+      Parser4.prototype.parse = function parse6() {
+        var node = this.options.program || this.startNode();
+        this.nextToken();
+        return this.parseTopLevel(node);
+      };
+      prototypeAccessors2.inFunction.get = function() {
+        return (this.currentVarScope().flags & SCOPE_FUNCTION2) > 0;
+      };
+      prototypeAccessors2.inGenerator.get = function() {
+        return (this.currentVarScope().flags & SCOPE_GENERATOR2) > 0 && !this.currentVarScope().inClassFieldInit;
+      };
+      prototypeAccessors2.inAsync.get = function() {
+        return (this.currentVarScope().flags & SCOPE_ASYNC2) > 0 && !this.currentVarScope().inClassFieldInit;
+      };
+      prototypeAccessors2.canAwait.get = function() {
+        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
+          var scope = this.scopeStack[i2];
+          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK2) {
+            return false;
+          }
+          if (scope.flags & SCOPE_FUNCTION2) {
+            return (scope.flags & SCOPE_ASYNC2) > 0;
+          }
+        }
+        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
+      };
+      prototypeAccessors2.allowSuper.get = function() {
+        var ref3 = this.currentThisScope();
+        var flags = ref3.flags;
+        var inClassFieldInit = ref3.inClassFieldInit;
+        return (flags & SCOPE_SUPER2) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
+      };
+      prototypeAccessors2.allowDirectSuper.get = function() {
+        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER2) > 0;
+      };
+      prototypeAccessors2.treatFunctionsAsVar.get = function() {
+        return this.treatFunctionsAsVarInScope(this.currentScope());
+      };
+      prototypeAccessors2.allowNewDotTarget.get = function() {
+        var ref3 = this.currentThisScope();
+        var flags = ref3.flags;
+        var inClassFieldInit = ref3.inClassFieldInit;
+        return (flags & (SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2)) > 0 || inClassFieldInit;
+      };
+      prototypeAccessors2.inClassStaticBlock.get = function() {
+        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK2) > 0;
+      };
+      Parser4.extend = function extend5() {
+        var plugins = [], len = arguments.length;
+        while (len--)
+          plugins[len] = arguments[len];
+        var cls = this;
+        for (var i2 = 0; i2 < plugins.length; i2++) {
+          cls = plugins[i2](cls);
+        }
+        return cls;
+      };
+      Parser4.parse = function parse6(input, options) {
+        return new this(options, input).parse();
+      };
+      Parser4.parseExpressionAt = function parseExpressionAt3(input, pos, options) {
+        var parser2 = new this(options, input, pos);
+        parser2.nextToken();
+        return parser2.parseExpression();
+      };
+      Parser4.tokenizer = function tokenizer4(input, options) {
+        return new this(options, input);
+      };
+      Object.defineProperties(Parser4.prototype, prototypeAccessors2);
+      var pp$92 = Parser4.prototype;
+      var literal2 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
+      pp$92.strictDirective = function(start3) {
+        for (; ; ) {
+          skipWhiteSpace2.lastIndex = start3;
+          start3 += skipWhiteSpace2.exec(this.input)[0].length;
+          var match = literal2.exec(this.input.slice(start3));
+          if (!match) {
+            return false;
+          }
+          if ((match[1] || match[2]) === "use strict") {
+            skipWhiteSpace2.lastIndex = start3 + match[0].length;
+            var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
+            var next = this.input.charAt(end);
+            return next === ";" || next === "}" || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
+          }
+          start3 += match[0].length;
+          skipWhiteSpace2.lastIndex = start3;
+          start3 += skipWhiteSpace2.exec(this.input)[0].length;
+          if (this.input[start3] === ";") {
+            start3++;
+          }
+        }
+      };
+      pp$92.eat = function(type2) {
+        if (this.type === type2) {
+          this.next();
+          return true;
+        } else {
+          return false;
+        }
+      };
+      pp$92.isContextual = function(name3) {
+        return this.type === types$12.name && this.value === name3 && !this.containsEsc;
+      };
+      pp$92.eatContextual = function(name3) {
+        if (!this.isContextual(name3)) {
+          return false;
+        }
+        this.next();
+        return true;
+      };
+      pp$92.expectContextual = function(name3) {
+        if (!this.eatContextual(name3)) {
+          this.unexpected();
+        }
+      };
+      pp$92.canInsertSemicolon = function() {
+        return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
+      };
+      pp$92.insertSemicolon = function() {
+        if (this.canInsertSemicolon()) {
+          if (this.options.onInsertedSemicolon) {
+            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
+          }
+          return true;
+        }
+      };
+      pp$92.semicolon = function() {
+        if (!this.eat(types$12.semi) && !this.insertSemicolon()) {
+          this.unexpected();
+        }
+      };
+      pp$92.afterTrailingComma = function(tokType, notNext) {
+        if (this.type === tokType) {
+          if (this.options.onTrailingComma) {
+            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
+          }
+          if (!notNext) {
+            this.next();
+          }
+          return true;
+        }
+      };
+      pp$92.expect = function(type2) {
+        this.eat(type2) || this.unexpected();
+      };
+      pp$92.unexpected = function(pos) {
+        this.raise(pos != null ? pos : this.start, "Unexpected token");
+      };
+      function DestructuringErrors2() {
+        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
+      }
+      pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
+        if (!refDestructuringErrors) {
+          return;
+        }
+        if (refDestructuringErrors.trailingComma > -1) {
+          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
+        }
+        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
+        if (parens > -1) {
+          this.raiseRecoverable(parens, "Parenthesized pattern");
+        }
+      };
+      pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
+        if (!refDestructuringErrors) {
+          return false;
+        }
+        var shorthandAssign = refDestructuringErrors.shorthandAssign;
+        var doubleProto = refDestructuringErrors.doubleProto;
+        if (!andThrow) {
+          return shorthandAssign >= 0 || doubleProto >= 0;
+        }
+        if (shorthandAssign >= 0) {
+          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
+        }
+        if (doubleProto >= 0) {
+          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
+        }
+      };
+      pp$92.checkYieldAwaitInDefaultParams = function() {
+        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
+          this.raise(this.yieldPos, "Yield expression cannot be a default value");
+        }
+        if (this.awaitPos) {
+          this.raise(this.awaitPos, "Await expression cannot be a default value");
+        }
+      };
+      pp$92.isSimpleAssignTarget = function(expr) {
+        if (expr.type === "ParenthesizedExpression") {
+          return this.isSimpleAssignTarget(expr.expression);
+        }
+        return expr.type === "Identifier" || expr.type === "MemberExpression";
+      };
+      var pp$82 = Parser4.prototype;
+      pp$82.parseTopLevel = function(node) {
+        var exports3 = /* @__PURE__ */ Object.create(null);
+        if (!node.body) {
+          node.body = [];
+        }
+        while (this.type !== types$12.eof) {
+          var stmt = this.parseStatement(null, true, exports3);
+          node.body.push(stmt);
+        }
+        if (this.inModule) {
+          for (var i2 = 0, list4 = Object.keys(this.undefinedExports); i2 < list4.length; i2 += 1) {
+            var name3 = list4[i2];
+            this.raiseRecoverable(this.undefinedExports[name3].start, "Export '" + name3 + "' is not defined");
+          }
+        }
+        this.adaptDirectivePrologue(node.body);
+        this.next();
+        node.sourceType = this.options.sourceType;
+        return this.finishNode(node, "Program");
+      };
+      var loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" };
+      pp$82.isLet = function(context) {
+        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
+          return false;
+        }
+        skipWhiteSpace2.lastIndex = this.pos;
+        var skip = skipWhiteSpace2.exec(this.input);
+        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
+        if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
+          return true;
+        }
+        if (context) {
+          return false;
+        }
+        if (nextCh === 123) {
+          return true;
+        }
+        if (isIdentifierStart2(nextCh, true)) {
+          var pos = next + 1;
+          while (isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true)) {
+            ++pos;
+          }
+          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
+            return true;
+          }
+          var ident = this.input.slice(next, pos);
+          if (!keywordRelationalOperator2.test(ident)) {
+            return true;
+          }
+        }
+        return false;
+      };
+      pp$82.isAsyncFunction = function() {
+        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
+          return false;
+        }
+        skipWhiteSpace2.lastIndex = this.pos;
+        var skip = skipWhiteSpace2.exec(this.input);
+        var next = this.pos + skip[0].length, after;
+        return !lineBreak2.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar2(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
+      };
+      pp$82.parseStatement = function(context, topLevel, exports3) {
+        var starttype = this.type, node = this.startNode(), kind;
+        if (this.isLet(context)) {
+          starttype = types$12._var;
+          kind = "let";
+        }
+        switch (starttype) {
+          case types$12._break:
+          case types$12._continue:
+            return this.parseBreakContinueStatement(node, starttype.keyword);
+          case types$12._debugger:
+            return this.parseDebuggerStatement(node);
+          case types$12._do:
+            return this.parseDoStatement(node);
+          case types$12._for:
+            return this.parseForStatement(node);
+          case types$12._function:
+            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
+              this.unexpected();
+            }
+            return this.parseFunctionStatement(node, false, !context);
+          case types$12._class:
+            if (context) {
+              this.unexpected();
+            }
+            return this.parseClass(node, true);
+          case types$12._if:
+            return this.parseIfStatement(node);
+          case types$12._return:
+            return this.parseReturnStatement(node);
+          case types$12._switch:
+            return this.parseSwitchStatement(node);
+          case types$12._throw:
+            return this.parseThrowStatement(node);
+          case types$12._try:
+            return this.parseTryStatement(node);
+          case types$12._const:
+          case types$12._var:
+            kind = kind || this.value;
+            if (context && kind !== "var") {
+              this.unexpected();
+            }
+            return this.parseVarStatement(node, kind);
+          case types$12._while:
+            return this.parseWhileStatement(node);
+          case types$12._with:
+            return this.parseWithStatement(node);
+          case types$12.braceL:
+            return this.parseBlock(true, node);
+          case types$12.semi:
+            return this.parseEmptyStatement(node);
+          case types$12._export:
+          case types$12._import:
+            if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
+              skipWhiteSpace2.lastIndex = this.pos;
+              var skip = skipWhiteSpace2.exec(this.input);
+              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
+              if (nextCh === 40 || nextCh === 46) {
+                return this.parseExpressionStatement(node, this.parseExpression());
+              }
+            }
+            if (!this.options.allowImportExportEverywhere) {
+              if (!topLevel) {
+                this.raise(this.start, "'import' and 'export' may only appear at the top level");
+              }
+              if (!this.inModule) {
+                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
+              }
+            }
+            return starttype === types$12._import ? this.parseImport(node) : this.parseExport(node, exports3);
+          default:
+            if (this.isAsyncFunction()) {
+              if (context) {
+                this.unexpected();
+              }
+              this.next();
+              return this.parseFunctionStatement(node, true, !context);
+            }
+            var maybeName = this.value, expr = this.parseExpression();
+            if (starttype === types$12.name && expr.type === "Identifier" && this.eat(types$12.colon)) {
+              return this.parseLabeledStatement(node, maybeName, expr, context);
+            } else {
+              return this.parseExpressionStatement(node, expr);
+            }
+        }
+      };
+      pp$82.parseBreakContinueStatement = function(node, keyword) {
+        var isBreak = keyword === "break";
+        this.next();
+        if (this.eat(types$12.semi) || this.insertSemicolon()) {
+          node.label = null;
+        } else if (this.type !== types$12.name) {
+          this.unexpected();
+        } else {
+          node.label = this.parseIdent();
+          this.semicolon();
+        }
+        var i2 = 0;
+        for (; i2 < this.labels.length; ++i2) {
+          var lab = this.labels[i2];
+          if (node.label == null || lab.name === node.label.name) {
+            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
+              break;
+            }
+            if (node.label && isBreak) {
+              break;
+            }
+          }
+        }
+        if (i2 === this.labels.length) {
+          this.raise(node.start, "Unsyntactic " + keyword);
+        }
+        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
+      };
+      pp$82.parseDebuggerStatement = function(node) {
+        this.next();
+        this.semicolon();
+        return this.finishNode(node, "DebuggerStatement");
+      };
+      pp$82.parseDoStatement = function(node) {
+        this.next();
+        this.labels.push(loopLabel2);
+        node.body = this.parseStatement("do");
+        this.labels.pop();
+        this.expect(types$12._while);
+        node.test = this.parseParenExpression();
+        if (this.options.ecmaVersion >= 6) {
+          this.eat(types$12.semi);
+        } else {
+          this.semicolon();
+        }
+        return this.finishNode(node, "DoWhileStatement");
+      };
+      pp$82.parseForStatement = function(node) {
+        this.next();
+        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
+        this.labels.push(loopLabel2);
+        this.enterScope(0);
+        this.expect(types$12.parenL);
+        if (this.type === types$12.semi) {
+          if (awaitAt > -1) {
+            this.unexpected(awaitAt);
+          }
+          return this.parseFor(node, null);
+        }
+        var isLet = this.isLet();
+        if (this.type === types$12._var || this.type === types$12._const || isLet) {
+          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
+          this.next();
+          this.parseVar(init$1, true, kind);
+          this.finishNode(init$1, "VariableDeclaration");
+          if ((this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
+            if (this.options.ecmaVersion >= 9) {
+              if (this.type === types$12._in) {
+                if (awaitAt > -1) {
+                  this.unexpected(awaitAt);
+                }
+              } else {
+                node.await = awaitAt > -1;
+              }
+            }
+            return this.parseForIn(node, init$1);
+          }
+          if (awaitAt > -1) {
+            this.unexpected(awaitAt);
+          }
+          return this.parseFor(node, init$1);
+        }
+        var startsWithLet = this.isContextual("let"), isForOf = false;
+        var refDestructuringErrors = new DestructuringErrors2();
+        var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
+        if (this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
+          if (this.options.ecmaVersion >= 9) {
+            if (this.type === types$12._in) {
+              if (awaitAt > -1) {
+                this.unexpected(awaitAt);
+              }
+            } else {
+              node.await = awaitAt > -1;
+            }
+          }
+          if (startsWithLet && isForOf) {
+            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
+          }
+          this.toAssignable(init, false, refDestructuringErrors);
+          this.checkLValPattern(init);
+          return this.parseForIn(node, init);
+        } else {
+          this.checkExpressionErrors(refDestructuringErrors, true);
+        }
+        if (awaitAt > -1) {
+          this.unexpected(awaitAt);
+        }
+        return this.parseFor(node, init);
+      };
+      pp$82.parseFunctionStatement = function(node, isAsync, declarationPosition) {
+        this.next();
+        return this.parseFunction(node, FUNC_STATEMENT2 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
+      };
+      pp$82.parseIfStatement = function(node) {
+        this.next();
+        node.test = this.parseParenExpression();
+        node.consequent = this.parseStatement("if");
+        node.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null;
+        return this.finishNode(node, "IfStatement");
+      };
+      pp$82.parseReturnStatement = function(node) {
+        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
+          this.raise(this.start, "'return' outside of function");
+        }
+        this.next();
+        if (this.eat(types$12.semi) || this.insertSemicolon()) {
+          node.argument = null;
+        } else {
+          node.argument = this.parseExpression();
+          this.semicolon();
+        }
+        return this.finishNode(node, "ReturnStatement");
+      };
+      pp$82.parseSwitchStatement = function(node) {
+        this.next();
+        node.discriminant = this.parseParenExpression();
+        node.cases = [];
+        this.expect(types$12.braceL);
+        this.labels.push(switchLabel2);
+        this.enterScope(0);
+        var cur;
+        for (var sawDefault = false; this.type !== types$12.braceR; ) {
+          if (this.type === types$12._case || this.type === types$12._default) {
+            var isCase = this.type === types$12._case;
+            if (cur) {
+              this.finishNode(cur, "SwitchCase");
+            }
+            node.cases.push(cur = this.startNode());
+            cur.consequent = [];
+            this.next();
+            if (isCase) {
+              cur.test = this.parseExpression();
+            } else {
+              if (sawDefault) {
+                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
+              }
+              sawDefault = true;
+              cur.test = null;
+            }
+            this.expect(types$12.colon);
+          } else {
+            if (!cur) {
+              this.unexpected();
+            }
+            cur.consequent.push(this.parseStatement(null));
+          }
+        }
+        this.exitScope();
+        if (cur) {
+          this.finishNode(cur, "SwitchCase");
+        }
+        this.next();
+        this.labels.pop();
+        return this.finishNode(node, "SwitchStatement");
+      };
+      pp$82.parseThrowStatement = function(node) {
+        this.next();
+        if (lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) {
+          this.raise(this.lastTokEnd, "Illegal newline after throw");
+        }
+        node.argument = this.parseExpression();
+        this.semicolon();
+        return this.finishNode(node, "ThrowStatement");
+      };
+      var empty$12 = [];
+      pp$82.parseTryStatement = function(node) {
+        this.next();
+        node.block = this.parseBlock();
+        node.handler = null;
+        if (this.type === types$12._catch) {
+          var clause = this.startNode();
+          this.next();
+          if (this.eat(types$12.parenL)) {
+            clause.param = this.parseBindingAtom();
+            var simple = clause.param.type === "Identifier";
+            this.enterScope(simple ? SCOPE_SIMPLE_CATCH2 : 0);
+            this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH2 : BIND_LEXICAL2);
+            this.expect(types$12.parenR);
+          } else {
+            if (this.options.ecmaVersion < 10) {
+              this.unexpected();
+            }
+            clause.param = null;
+            this.enterScope(0);
+          }
+          clause.body = this.parseBlock(false);
+          this.exitScope();
+          node.handler = this.finishNode(clause, "CatchClause");
+        }
+        node.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null;
+        if (!node.handler && !node.finalizer) {
+          this.raise(node.start, "Missing catch or finally clause");
+        }
+        return this.finishNode(node, "TryStatement");
+      };
+      pp$82.parseVarStatement = function(node, kind) {
+        this.next();
+        this.parseVar(node, false, kind);
+        this.semicolon();
+        return this.finishNode(node, "VariableDeclaration");
+      };
+      pp$82.parseWhileStatement = function(node) {
+        this.next();
+        node.test = this.parseParenExpression();
+        this.labels.push(loopLabel2);
+        node.body = this.parseStatement("while");
+        this.labels.pop();
+        return this.finishNode(node, "WhileStatement");
+      };
+      pp$82.parseWithStatement = function(node) {
+        if (this.strict) {
+          this.raise(this.start, "'with' in strict mode");
+        }
+        this.next();
+        node.object = this.parseParenExpression();
+        node.body = this.parseStatement("with");
+        return this.finishNode(node, "WithStatement");
+      };
+      pp$82.parseEmptyStatement = function(node) {
+        this.next();
+        return this.finishNode(node, "EmptyStatement");
+      };
+      pp$82.parseLabeledStatement = function(node, maybeName, expr, context) {
+        for (var i$1 = 0, list4 = this.labels; i$1 < list4.length; i$1 += 1) {
+          var label = list4[i$1];
+          if (label.name === maybeName) {
+            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
+          }
+        }
+        var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null;
+        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
+          var label$1 = this.labels[i2];
+          if (label$1.statementStart === node.start) {
+            label$1.statementStart = this.start;
+            label$1.kind = kind;
+          } else {
+            break;
+          }
+        }
+        this.labels.push({ name: maybeName, kind, statementStart: this.start });
+        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
+        this.labels.pop();
+        node.label = expr;
+        return this.finishNode(node, "LabeledStatement");
+      };
+      pp$82.parseExpressionStatement = function(node, expr) {
+        node.expression = expr;
+        this.semicolon();
+        return this.finishNode(node, "ExpressionStatement");
+      };
+      pp$82.parseBlock = function(createNewLexicalScope, node, exitStrict) {
+        if (createNewLexicalScope === void 0)
+          createNewLexicalScope = true;
+        if (node === void 0)
+          node = this.startNode();
+        node.body = [];
+        this.expect(types$12.braceL);
+        if (createNewLexicalScope) {
+          this.enterScope(0);
+        }
+        while (this.type !== types$12.braceR) {
+          var stmt = this.parseStatement(null);
+          node.body.push(stmt);
+        }
+        if (exitStrict) {
+          this.strict = false;
+        }
+        this.next();
+        if (createNewLexicalScope) {
+          this.exitScope();
+        }
+        return this.finishNode(node, "BlockStatement");
+      };
+      pp$82.parseFor = function(node, init) {
+        node.init = init;
+        this.expect(types$12.semi);
+        node.test = this.type === types$12.semi ? null : this.parseExpression();
+        this.expect(types$12.semi);
+        node.update = this.type === types$12.parenR ? null : this.parseExpression();
+        this.expect(types$12.parenR);
+        node.body = this.parseStatement("for");
+        this.exitScope();
+        this.labels.pop();
+        return this.finishNode(node, "ForStatement");
+      };
+      pp$82.parseForIn = function(node, init) {
+        var isForIn = this.type === types$12._in;
+        this.next();
+        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
+          this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
+        }
+        node.left = init;
+        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
+        this.expect(types$12.parenR);
+        node.body = this.parseStatement("for");
+        this.exitScope();
+        this.labels.pop();
+        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
+      };
+      pp$82.parseVar = function(node, isFor, kind) {
+        node.declarations = [];
+        node.kind = kind;
+        for (; ; ) {
+          var decl = this.startNode();
+          this.parseVarId(decl, kind);
+          if (this.eat(types$12.eq)) {
+            decl.init = this.parseMaybeAssign(isFor);
+          } else if (kind === "const" && !(this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
+            this.unexpected();
+          } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$12._in || this.isContextual("of")))) {
+            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
+          } else {
+            decl.init = null;
+          }
+          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
+          if (!this.eat(types$12.comma)) {
+            break;
+          }
+        }
+        return node;
+      };
+      pp$82.parseVarId = function(decl, kind) {
+        decl.id = this.parseBindingAtom();
+        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR2 : BIND_LEXICAL2, false);
+      };
+      var FUNC_STATEMENT2 = 1, FUNC_HANGING_STATEMENT2 = 2, FUNC_NULLABLE_ID2 = 4;
+      pp$82.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
+        this.initFunction(node);
+        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
+          if (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2) {
+            this.unexpected();
+          }
+          node.generator = this.eat(types$12.star);
+        }
+        if (this.options.ecmaVersion >= 8) {
+          node.async = !!isAsync;
+        }
+        if (statement & FUNC_STATEMENT2) {
+          node.id = statement & FUNC_NULLABLE_ID2 && this.type !== types$12.name ? null : this.parseIdent();
+          if (node.id && !(statement & FUNC_HANGING_STATEMENT2)) {
+            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR2 : BIND_LEXICAL2 : BIND_FUNCTION2);
+          }
+        }
+        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
+        this.yieldPos = 0;
+        this.awaitPos = 0;
+        this.awaitIdentPos = 0;
+        this.enterScope(functionFlags2(node.async, node.generator));
+        if (!(statement & FUNC_STATEMENT2)) {
+          node.id = this.type === types$12.name ? this.parseIdent() : null;
+        }
+        this.parseFunctionParams(node);
+        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
+        this.yieldPos = oldYieldPos;
+        this.awaitPos = oldAwaitPos;
+        this.awaitIdentPos = oldAwaitIdentPos;
+        return this.finishNode(node, statement & FUNC_STATEMENT2 ? "FunctionDeclaration" : "FunctionExpression");
+      };
+      pp$82.parseFunctionParams = function(node) {
+        this.expect(types$12.parenL);
+        node.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
+        this.checkYieldAwaitInDefaultParams();
+      };
+      pp$82.parseClass = function(node, isStatement) {
+        this.next();
+        var oldStrict = this.strict;
+        this.strict = true;
+        this.parseClassId(node, isStatement);
+        this.parseClassSuper(node);
+        var privateNameMap = this.enterClassBody();
+        var classBody = this.startNode();
+        var hadConstructor = false;
+        classBody.body = [];
+        this.expect(types$12.braceL);
+        while (this.type !== types$12.braceR) {
+          var element3 = this.parseClassElement(node.superClass !== null);
+          if (element3) {
+            classBody.body.push(element3);
+            if (element3.type === "MethodDefinition" && element3.kind === "constructor") {
+              if (hadConstructor) {
+                this.raise(element3.start, "Duplicate constructor in the same class");
+              }
+              hadConstructor = true;
+            } else if (element3.key && element3.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element3)) {
+              this.raiseRecoverable(element3.key.start, "Identifier '#" + element3.key.name + "' has already been declared");
+            }
+          }
+        }
+        this.strict = oldStrict;
+        this.next();
+        node.body = this.finishNode(classBody, "ClassBody");
+        this.exitClassBody();
+        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
+      };
+      pp$82.parseClassElement = function(constructorAllowsSuper) {
+        if (this.eat(types$12.semi)) {
+          return null;
+        }
+        var ecmaVersion2 = this.options.ecmaVersion;
+        var node = this.startNode();
+        var keyName = "";
+        var isGenerator = false;
+        var isAsync = false;
+        var kind = "method";
+        var isStatic = false;
+        if (this.eatContextual("static")) {
+          if (ecmaVersion2 >= 13 && this.eat(types$12.braceL)) {
+            this.parseClassStaticBlock(node);
+            return node;
+          }
+          if (this.isClassElementNameStart() || this.type === types$12.star) {
+            isStatic = true;
+          } else {
+            keyName = "static";
+          }
+        }
+        node.static = isStatic;
+        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
+          if ((this.isClassElementNameStart() || this.type === types$12.star) && !this.canInsertSemicolon()) {
+            isAsync = true;
+          } else {
+            keyName = "async";
+          }
+        }
+        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$12.star)) {
+          isGenerator = true;
+        }
+        if (!keyName && !isAsync && !isGenerator) {
+          var lastValue = this.value;
+          if (this.eatContextual("get") || this.eatContextual("set")) {
+            if (this.isClassElementNameStart()) {
+              kind = lastValue;
+            } else {
+              keyName = lastValue;
+            }
+          }
+        }
+        if (keyName) {
+          node.computed = false;
+          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
+          node.key.name = keyName;
+          this.finishNode(node.key, "Identifier");
+        } else {
+          this.parseClassElementName(node);
+        }
+        if (ecmaVersion2 < 13 || this.type === types$12.parenL || kind !== "method" || isGenerator || isAsync) {
+          var isConstructor = !node.static && checkKeyName2(node, "constructor");
+          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
+          if (isConstructor && kind !== "method") {
+            this.raise(node.key.start, "Constructor can't have get/set modifier");
+          }
+          node.kind = isConstructor ? "constructor" : kind;
+          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
+        } else {
+          this.parseClassField(node);
+        }
+        return node;
+      };
+      pp$82.isClassElementNameStart = function() {
+        return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
+      };
+      pp$82.parseClassElementName = function(element3) {
+        if (this.type === types$12.privateId) {
+          if (this.value === "constructor") {
+            this.raise(this.start, "Classes can't have an element named '#constructor'");
+          }
+          element3.computed = false;
+          element3.key = this.parsePrivateIdent();
+        } else {
+          this.parsePropertyName(element3);
+        }
+      };
+      pp$82.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
+        var key = method.key;
+        if (method.kind === "constructor") {
+          if (isGenerator) {
+            this.raise(key.start, "Constructor can't be a generator");
+          }
+          if (isAsync) {
+            this.raise(key.start, "Constructor can't be an async method");
+          }
+        } else if (method.static && checkKeyName2(method, "prototype")) {
+          this.raise(key.start, "Classes may not have a static property named prototype");
+        }
+        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
+        if (method.kind === "get" && value.params.length !== 0) {
+          this.raiseRecoverable(value.start, "getter should have no params");
+        }
+        if (method.kind === "set" && value.params.length !== 1) {
+          this.raiseRecoverable(value.start, "setter should have exactly one param");
+        }
+        if (method.kind === "set" && value.params[0].type === "RestElement") {
+          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
+        }
+        return this.finishNode(method, "MethodDefinition");
+      };
+      pp$82.parseClassField = function(field) {
+        if (checkKeyName2(field, "constructor")) {
+          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
+        } else if (field.static && checkKeyName2(field, "prototype")) {
+          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
+        }
+        if (this.eat(types$12.eq)) {
+          var scope = this.currentThisScope();
+          var inClassFieldInit = scope.inClassFieldInit;
+          scope.inClassFieldInit = true;
+          field.value = this.parseMaybeAssign();
+          scope.inClassFieldInit = inClassFieldInit;
+        } else {
+          field.value = null;
+        }
+        this.semicolon();
+        return this.finishNode(field, "PropertyDefinition");
+      };
+      pp$82.parseClassStaticBlock = function(node) {
+        node.body = [];
+        var oldLabels = this.labels;
+        this.labels = [];
+        this.enterScope(SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_SUPER2);
+        while (this.type !== types$12.braceR) {
+          var stmt = this.parseStatement(null);
+          node.body.push(stmt);
+        }
+        this.next();
+        this.exitScope();
+        this.labels = oldLabels;
+        return this.finishNode(node, "StaticBlock");
+      };
+      pp$82.parseClassId = function(node, isStatement) {
+        if (this.type === types$12.name) {
+          node.id = this.parseIdent();
+          if (isStatement) {
+            this.checkLValSimple(node.id, BIND_LEXICAL2, false);
+          }
+        } else {
+          if (isStatement === true) {
+            this.unexpected();
+          }
+          node.id = null;
+        }
+      };
+      pp$82.parseClassSuper = function(node) {
+        node.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(false) : null;
+      };
+      pp$82.enterClassBody = function() {
+        var element3 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
+        this.privateNameStack.push(element3);
+        return element3.declared;
+      };
+      pp$82.exitClassBody = function() {
+        var ref3 = this.privateNameStack.pop();
+        var declared = ref3.declared;
+        var used = ref3.used;
+        var len = this.privateNameStack.length;
+        var parent = len === 0 ? null : this.privateNameStack[len - 1];
+        for (var i2 = 0; i2 < used.length; ++i2) {
+          var id = used[i2];
+          if (!hasOwn3(declared, id.name)) {
+            if (parent) {
+              parent.used.push(id);
+            } else {
+              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
+            }
+          }
+        }
+      };
+      function isPrivateNameConflicted2(privateNameMap, element3) {
+        var name3 = element3.key.name;
+        var curr = privateNameMap[name3];
+        var next = "true";
+        if (element3.type === "MethodDefinition" && (element3.kind === "get" || element3.kind === "set")) {
+          next = (element3.static ? "s" : "i") + element3.kind;
+        }
+        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
+          privateNameMap[name3] = "true";
+          return false;
+        } else if (!curr) {
+          privateNameMap[name3] = next;
+          return false;
+        } else {
+          return true;
+        }
+      }
+      function checkKeyName2(node, name3) {
+        var computed = node.computed;
+        var key = node.key;
+        return !computed && (key.type === "Identifier" && key.name === name3 || key.type === "Literal" && key.value === name3);
+      }
+      pp$82.parseExport = function(node, exports3) {
+        this.next();
+        if (this.eat(types$12.star)) {
+          if (this.options.ecmaVersion >= 11) {
+            if (this.eatContextual("as")) {
+              node.exported = this.parseModuleExportName();
+              this.checkExport(exports3, node.exported.name, this.lastTokStart);
+            } else {
+              node.exported = null;
+            }
+          }
+          this.expectContextual("from");
+          if (this.type !== types$12.string) {
+            this.unexpected();
+          }
+          node.source = this.parseExprAtom();
+          this.semicolon();
+          return this.finishNode(node, "ExportAllDeclaration");
+        }
+        if (this.eat(types$12._default)) {
+          this.checkExport(exports3, "default", this.lastTokStart);
+          var isAsync;
+          if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
+            var fNode = this.startNode();
+            this.next();
+            if (isAsync) {
+              this.next();
+            }
+            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT2 | FUNC_NULLABLE_ID2, false, isAsync);
+          } else if (this.type === types$12._class) {
+            var cNode = this.startNode();
+            node.declaration = this.parseClass(cNode, "nullableID");
+          } else {
+            node.declaration = this.parseMaybeAssign();
+            this.semicolon();
+          }
+          return this.finishNode(node, "ExportDefaultDeclaration");
+        }
+        if (this.shouldParseExportStatement()) {
+          node.declaration = this.parseStatement(null);
+          if (node.declaration.type === "VariableDeclaration") {
+            this.checkVariableExport(exports3, node.declaration.declarations);
+          } else {
+            this.checkExport(exports3, node.declaration.id.name, node.declaration.id.start);
+          }
+          node.specifiers = [];
+          node.source = null;
+        } else {
+          node.declaration = null;
+          node.specifiers = this.parseExportSpecifiers(exports3);
+          if (this.eatContextual("from")) {
+            if (this.type !== types$12.string) {
+              this.unexpected();
+            }
+            node.source = this.parseExprAtom();
+          } else {
+            for (var i2 = 0, list4 = node.specifiers; i2 < list4.length; i2 += 1) {
+              var spec = list4[i2];
+              this.checkUnreserved(spec.local);
+              this.checkLocalExport(spec.local);
+              if (spec.local.type === "Literal") {
+                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
+              }
+            }
+            node.source = null;
+          }
+          this.semicolon();
+        }
+        return this.finishNode(node, "ExportNamedDeclaration");
+      };
+      pp$82.checkExport = function(exports3, name3, pos) {
+        if (!exports3) {
+          return;
+        }
+        if (hasOwn3(exports3, name3)) {
+          this.raiseRecoverable(pos, "Duplicate export '" + name3 + "'");
+        }
+        exports3[name3] = true;
+      };
+      pp$82.checkPatternExport = function(exports3, pat) {
+        var type2 = pat.type;
+        if (type2 === "Identifier") {
+          this.checkExport(exports3, pat.name, pat.start);
+        } else if (type2 === "ObjectPattern") {
+          for (var i2 = 0, list4 = pat.properties; i2 < list4.length; i2 += 1) {
+            var prop = list4[i2];
+            this.checkPatternExport(exports3, prop);
+          }
+        } else if (type2 === "ArrayPattern") {
+          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
+            var elt = list$1[i$1];
+            if (elt) {
+              this.checkPatternExport(exports3, elt);
+            }
+          }
+        } else if (type2 === "Property") {
+          this.checkPatternExport(exports3, pat.value);
+        } else if (type2 === "AssignmentPattern") {
+          this.checkPatternExport(exports3, pat.left);
+        } else if (type2 === "RestElement") {
+          this.checkPatternExport(exports3, pat.argument);
+        } else if (type2 === "ParenthesizedExpression") {
+          this.checkPatternExport(exports3, pat.expression);
+        }
+      };
+      pp$82.checkVariableExport = function(exports3, decls) {
+        if (!exports3) {
+          return;
+        }
+        for (var i2 = 0, list4 = decls; i2 < list4.length; i2 += 1) {
+          var decl = list4[i2];
+          this.checkPatternExport(exports3, decl.id);
+        }
+      };
+      pp$82.shouldParseExportStatement = function() {
+        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
+      };
+      pp$82.parseExportSpecifiers = function(exports3) {
+        var nodes2 = [], first = true;
+        this.expect(types$12.braceL);
+        while (!this.eat(types$12.braceR)) {
+          if (!first) {
+            this.expect(types$12.comma);
+            if (this.afterTrailingComma(types$12.braceR)) {
+              break;
+            }
+          } else {
+            first = false;
+          }
+          var node = this.startNode();
+          node.local = this.parseModuleExportName();
+          node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
+          this.checkExport(exports3, node.exported[node.exported.type === "Identifier" ? "name" : "value"], node.exported.start);
+          nodes2.push(this.finishNode(node, "ExportSpecifier"));
+        }
+        return nodes2;
+      };
+      pp$82.parseImport = function(node) {
+        this.next();
+        if (this.type === types$12.string) {
+          node.specifiers = empty$12;
+          node.source = this.parseExprAtom();
+        } else {
+          node.specifiers = this.parseImportSpecifiers();
+          this.expectContextual("from");
+          node.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected();
+        }
+        this.semicolon();
+        return this.finishNode(node, "ImportDeclaration");
+      };
+      pp$82.parseImportSpecifiers = function() {
+        var nodes2 = [], first = true;
+        if (this.type === types$12.name) {
+          var node = this.startNode();
+          node.local = this.parseIdent();
+          this.checkLValSimple(node.local, BIND_LEXICAL2);
+          nodes2.push(this.finishNode(node, "ImportDefaultSpecifier"));
+          if (!this.eat(types$12.comma)) {
+            return nodes2;
+          }
+        }
+        if (this.type === types$12.star) {
+          var node$1 = this.startNode();
+          this.next();
+          this.expectContextual("as");
+          node$1.local = this.parseIdent();
+          this.checkLValSimple(node$1.local, BIND_LEXICAL2);
+          nodes2.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
+          return nodes2;
+        }
+        this.expect(types$12.braceL);
+        while (!this.eat(types$12.braceR)) {
+          if (!first) {
+            this.expect(types$12.comma);
+            if (this.afterTrailingComma(types$12.braceR)) {
+              break;
+            }
+          } else {
+            first = false;
+          }
+          var node$2 = this.startNode();
+          node$2.imported = this.parseModuleExportName();
+          if (this.eatContextual("as")) {
+            node$2.local = this.parseIdent();
+          } else {
+            this.checkUnreserved(node$2.imported);
+            node$2.local = node$2.imported;
+          }
+          this.checkLValSimple(node$2.local, BIND_LEXICAL2);
+          nodes2.push(this.finishNode(node$2, "ImportSpecifier"));
+        }
+        return nodes2;
+      };
+      pp$82.parseModuleExportName = function() {
+        if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
+          var stringLiteral = this.parseLiteral(this.value);
+          if (loneSurrogate2.test(stringLiteral.value)) {
+            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
+          }
+          return stringLiteral;
+        }
+        return this.parseIdent(true);
+      };
+      pp$82.adaptDirectivePrologue = function(statements) {
+        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
+          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
+        }
+      };
+      pp$82.isDirectiveCandidate = function(statement) {
+        return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
+      };
+      var pp$72 = Parser4.prototype;
+      pp$72.toAssignable = function(node, isBinding, refDestructuringErrors) {
+        if (this.options.ecmaVersion >= 6 && node) {
+          switch (node.type) {
+            case "Identifier":
+              if (this.inAsync && node.name === "await") {
+                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
+              }
+              break;
+            case "ObjectPattern":
+            case "ArrayPattern":
+            case "AssignmentPattern":
+            case "RestElement":
+              break;
+            case "ObjectExpression":
+              node.type = "ObjectPattern";
+              if (refDestructuringErrors) {
+                this.checkPatternErrors(refDestructuringErrors, true);
+              }
+              for (var i2 = 0, list4 = node.properties; i2 < list4.length; i2 += 1) {
+                var prop = list4[i2];
+                this.toAssignable(prop, isBinding);
+                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
+                  this.raise(prop.argument.start, "Unexpected token");
+                }
+              }
+              break;
+            case "Property":
+              if (node.kind !== "init") {
+                this.raise(node.key.start, "Object pattern can't contain getter or setter");
+              }
+              this.toAssignable(node.value, isBinding);
+              break;
+            case "ArrayExpression":
+              node.type = "ArrayPattern";
+              if (refDestructuringErrors) {
+                this.checkPatternErrors(refDestructuringErrors, true);
+              }
+              this.toAssignableList(node.elements, isBinding);
+              break;
+            case "SpreadElement":
+              node.type = "RestElement";
+              this.toAssignable(node.argument, isBinding);
+              if (node.argument.type === "AssignmentPattern") {
+                this.raise(node.argument.start, "Rest elements cannot have a default value");
+              }
+              break;
+            case "AssignmentExpression":
+              if (node.operator !== "=") {
+                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
+              }
+              node.type = "AssignmentPattern";
+              delete node.operator;
+              this.toAssignable(node.left, isBinding);
+              break;
+            case "ParenthesizedExpression":
+              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
+              break;
+            case "ChainExpression":
+              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
+              break;
+            case "MemberExpression":
+              if (!isBinding) {
+                break;
+              }
+            default:
+              this.raise(node.start, "Assigning to rvalue");
+          }
+        } else if (refDestructuringErrors) {
+          this.checkPatternErrors(refDestructuringErrors, true);
+        }
+        return node;
+      };
+      pp$72.toAssignableList = function(exprList, isBinding) {
+        var end = exprList.length;
+        for (var i2 = 0; i2 < end; i2++) {
+          var elt = exprList[i2];
+          if (elt) {
+            this.toAssignable(elt, isBinding);
+          }
+        }
+        if (end) {
+          var last = exprList[end - 1];
+          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
+            this.unexpected(last.argument.start);
+          }
+        }
+        return exprList;
+      };
+      pp$72.parseSpread = function(refDestructuringErrors) {
+        var node = this.startNode();
+        this.next();
+        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
+        return this.finishNode(node, "SpreadElement");
+      };
+      pp$72.parseRestBinding = function() {
+        var node = this.startNode();
+        this.next();
+        if (this.options.ecmaVersion === 6 && this.type !== types$12.name) {
+          this.unexpected();
+        }
+        node.argument = this.parseBindingAtom();
+        return this.finishNode(node, "RestElement");
+      };
+      pp$72.parseBindingAtom = function() {
+        if (this.options.ecmaVersion >= 6) {
+          switch (this.type) {
+            case types$12.bracketL:
+              var node = this.startNode();
+              this.next();
+              node.elements = this.parseBindingList(types$12.bracketR, true, true);
+              return this.finishNode(node, "ArrayPattern");
+            case types$12.braceL:
+              return this.parseObj(true);
+          }
+        }
+        return this.parseIdent();
+      };
+      pp$72.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
+        var elts = [], first = true;
+        while (!this.eat(close)) {
+          if (first) {
+            first = false;
+          } else {
+            this.expect(types$12.comma);
+          }
+          if (allowEmpty && this.type === types$12.comma) {
+            elts.push(null);
+          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
+            break;
+          } else if (this.type === types$12.ellipsis) {
+            var rest = this.parseRestBinding();
+            this.parseBindingListItem(rest);
+            elts.push(rest);
+            if (this.type === types$12.comma) {
+              this.raise(this.start, "Comma is not permitted after the rest element");
+            }
+            this.expect(close);
+            break;
+          } else {
+            var elem = this.parseMaybeDefault(this.start, this.startLoc);
+            this.parseBindingListItem(elem);
+            elts.push(elem);
+          }
+        }
+        return elts;
+      };
+      pp$72.parseBindingListItem = function(param) {
+        return param;
+      };
+      pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
+        left = left || this.parseBindingAtom();
+        if (this.options.ecmaVersion < 6 || !this.eat(types$12.eq)) {
+          return left;
+        }
+        var node = this.startNodeAt(startPos, startLoc);
+        node.left = left;
+        node.right = this.parseMaybeAssign();
+        return this.finishNode(node, "AssignmentPattern");
+      };
+      pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
+        if (bindingType === void 0)
+          bindingType = BIND_NONE2;
+        var isBind = bindingType !== BIND_NONE2;
+        switch (expr.type) {
+          case "Identifier":
+            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
+              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
+            }
+            if (isBind) {
+              if (bindingType === BIND_LEXICAL2 && expr.name === "let") {
+                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
+              }
+              if (checkClashes) {
+                if (hasOwn3(checkClashes, expr.name)) {
+                  this.raiseRecoverable(expr.start, "Argument name clash");
+                }
+                checkClashes[expr.name] = true;
+              }
+              if (bindingType !== BIND_OUTSIDE2) {
+                this.declareName(expr.name, bindingType, expr.start);
+              }
+            }
+            break;
+          case "ChainExpression":
+            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
+            break;
+          case "MemberExpression":
+            if (isBind) {
+              this.raiseRecoverable(expr.start, "Binding member expression");
+            }
+            break;
+          case "ParenthesizedExpression":
+            if (isBind) {
+              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
+            }
+            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
+          default:
+            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
+        }
+      };
+      pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
+        if (bindingType === void 0)
+          bindingType = BIND_NONE2;
+        switch (expr.type) {
+          case "ObjectPattern":
+            for (var i2 = 0, list4 = expr.properties; i2 < list4.length; i2 += 1) {
+              var prop = list4[i2];
+              this.checkLValInnerPattern(prop, bindingType, checkClashes);
+            }
+            break;
+          case "ArrayPattern":
+            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
+              var elem = list$1[i$1];
+              if (elem) {
+                this.checkLValInnerPattern(elem, bindingType, checkClashes);
+              }
+            }
+            break;
+          default:
+            this.checkLValSimple(expr, bindingType, checkClashes);
+        }
+      };
+      pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
+        if (bindingType === void 0)
+          bindingType = BIND_NONE2;
+        switch (expr.type) {
+          case "Property":
+            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
+            break;
+          case "AssignmentPattern":
+            this.checkLValPattern(expr.left, bindingType, checkClashes);
+            break;
+          case "RestElement":
+            this.checkLValPattern(expr.argument, bindingType, checkClashes);
+            break;
+          default:
+            this.checkLValPattern(expr, bindingType, checkClashes);
+        }
+      };
+      var TokContext3 = function TokContext4(token, isExpr, preserveSpace, override, generator) {
+        this.token = token;
+        this.isExpr = !!isExpr;
+        this.preserveSpace = !!preserveSpace;
+        this.override = override;
+        this.generator = !!generator;
+      };
+      var types3 = {
+        b_stat: new TokContext3("{", false),
+        b_expr: new TokContext3("{", true),
+        b_tmpl: new TokContext3("${", false),
+        p_stat: new TokContext3("(", false),
+        p_expr: new TokContext3("(", true),
+        q_tmpl: new TokContext3("`", true, true, function(p) {
+          return p.tryReadTemplateToken();
+        }),
+        f_stat: new TokContext3("function", false),
+        f_expr: new TokContext3("function", true),
+        f_expr_gen: new TokContext3("function", true, false, null, true),
+        f_gen: new TokContext3("function", false, false, null, true)
+      };
+      var pp$62 = Parser4.prototype;
+      pp$62.initialContext = function() {
+        return [types3.b_stat];
+      };
+      pp$62.curContext = function() {
+        return this.context[this.context.length - 1];
+      };
+      pp$62.braceIsBlock = function(prevType) {
+        var parent = this.curContext();
+        if (parent === types3.f_expr || parent === types3.f_stat) {
+          return true;
+        }
+        if (prevType === types$12.colon && (parent === types3.b_stat || parent === types3.b_expr)) {
+          return !parent.isExpr;
+        }
+        if (prevType === types$12._return || prevType === types$12.name && this.exprAllowed) {
+          return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
+        }
+        if (prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow) {
+          return true;
+        }
+        if (prevType === types$12.braceL) {
+          return parent === types3.b_stat;
+        }
+        if (prevType === types$12._var || prevType === types$12._const || prevType === types$12.name) {
+          return false;
+        }
+        return !this.exprAllowed;
+      };
+      pp$62.inGeneratorContext = function() {
+        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
+          var context = this.context[i2];
+          if (context.token === "function") {
+            return context.generator;
+          }
+        }
+        return false;
+      };
+      pp$62.updateContext = function(prevType) {
+        var update, type2 = this.type;
+        if (type2.keyword && prevType === types$12.dot) {
+          this.exprAllowed = false;
+        } else if (update = type2.updateContext) {
+          update.call(this, prevType);
+        } else {
+          this.exprAllowed = type2.beforeExpr;
+        }
+      };
+      pp$62.overrideContext = function(tokenCtx) {
+        if (this.curContext() !== tokenCtx) {
+          this.context[this.context.length - 1] = tokenCtx;
+        }
+      };
+      types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
+        if (this.context.length === 1) {
+          this.exprAllowed = true;
+          return;
+        }
+        var out = this.context.pop();
+        if (out === types3.b_stat && this.curContext().token === "function") {
+          out = this.context.pop();
+        }
+        this.exprAllowed = !out.isExpr;
+      };
+      types$12.braceL.updateContext = function(prevType) {
+        this.context.push(this.braceIsBlock(prevType) ? types3.b_stat : types3.b_expr);
+        this.exprAllowed = true;
+      };
+      types$12.dollarBraceL.updateContext = function() {
+        this.context.push(types3.b_tmpl);
+        this.exprAllowed = true;
+      };
+      types$12.parenL.updateContext = function(prevType) {
+        var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
+        this.context.push(statementParens ? types3.p_stat : types3.p_expr);
+        this.exprAllowed = true;
+      };
+      types$12.incDec.updateContext = function() {
+      };
+      types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
+        if (prevType.beforeExpr && prevType !== types$12._else && !(prevType === types$12.semi && this.curContext() !== types3.p_stat) && !(prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types3.b_stat)) {
+          this.context.push(types3.f_expr);
+        } else {
+          this.context.push(types3.f_stat);
+        }
+        this.exprAllowed = false;
+      };
+      types$12.backQuote.updateContext = function() {
+        if (this.curContext() === types3.q_tmpl) {
+          this.context.pop();
+        } else {
+          this.context.push(types3.q_tmpl);
+        }
+        this.exprAllowed = false;
+      };
+      types$12.star.updateContext = function(prevType) {
+        if (prevType === types$12._function) {
+          var index3 = this.context.length - 1;
+          if (this.context[index3] === types3.f_expr) {
+            this.context[index3] = types3.f_expr_gen;
+          } else {
+            this.context[index3] = types3.f_gen;
+          }
+        }
+        this.exprAllowed = true;
+      };
+      types$12.name.updateContext = function(prevType) {
+        var allowed = false;
+        if (this.options.ecmaVersion >= 6 && prevType !== types$12.dot) {
+          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
+            allowed = true;
+          }
+        }
+        this.exprAllowed = allowed;
+      };
+      var pp$52 = Parser4.prototype;
+      pp$52.checkPropClash = function(prop, propHash, refDestructuringErrors) {
+        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
+          return;
+        }
+        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
+          return;
+        }
+        var key = prop.key;
+        var name3;
+        switch (key.type) {
+          case "Identifier":
+            name3 = key.name;
+            break;
+          case "Literal":
+            name3 = String(key.value);
+            break;
+          default:
+            return;
+        }
+        var kind = prop.kind;
+        if (this.options.ecmaVersion >= 6) {
+          if (name3 === "__proto__" && kind === "init") {
+            if (propHash.proto) {
+              if (refDestructuringErrors) {
+                if (refDestructuringErrors.doubleProto < 0) {
+                  refDestructuringErrors.doubleProto = key.start;
+                }
+              } else {
+                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
+              }
+            }
+            propHash.proto = true;
+          }
+          return;
+        }
+        name3 = "$" + name3;
+        var other = propHash[name3];
+        if (other) {
+          var redefinition;
+          if (kind === "init") {
+            redefinition = this.strict && other.init || other.get || other.set;
+          } else {
+            redefinition = other.init || other[kind];
+          }
+          if (redefinition) {
+            this.raiseRecoverable(key.start, "Redefinition of property");
+          }
+        } else {
+          other = propHash[name3] = {
+            init: false,
+            get: false,
+            set: false
+          };
+        }
+        other[kind] = true;
+      };
+      pp$52.parseExpression = function(forInit, refDestructuringErrors) {
+        var startPos = this.start, startLoc = this.startLoc;
+        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
+        if (this.type === types$12.comma) {
+          var node = this.startNodeAt(startPos, startLoc);
+          node.expressions = [expr];
+          while (this.eat(types$12.comma)) {
+            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
+          }
+          return this.finishNode(node, "SequenceExpression");
+        }
+        return expr;
+      };
+      pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
+        if (this.isContextual("yield")) {
+          if (this.inGenerator) {
+            return this.parseYield(forInit);
+          } else {
+            this.exprAllowed = false;
+          }
+        }
+        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
+        if (refDestructuringErrors) {
+          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
+          oldTrailingComma = refDestructuringErrors.trailingComma;
+          oldDoubleProto = refDestructuringErrors.doubleProto;
+          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
+        } else {
+          refDestructuringErrors = new DestructuringErrors2();
+          ownDestructuringErrors = true;
+        }
+        var startPos = this.start, startLoc = this.startLoc;
+        if (this.type === types$12.parenL || this.type === types$12.name) {
+          this.potentialArrowAt = this.start;
+          this.potentialArrowInForAwait = forInit === "await";
+        }
+        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
+        if (afterLeftParse) {
+          left = afterLeftParse.call(this, left, startPos, startLoc);
+        }
+        if (this.type.isAssign) {
+          var node = this.startNodeAt(startPos, startLoc);
+          node.operator = this.value;
+          if (this.type === types$12.eq) {
+            left = this.toAssignable(left, false, refDestructuringErrors);
+          }
+          if (!ownDestructuringErrors) {
+            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
+          }
+          if (refDestructuringErrors.shorthandAssign >= left.start) {
+            refDestructuringErrors.shorthandAssign = -1;
+          }
+          if (this.type === types$12.eq) {
+            this.checkLValPattern(left);
+          } else {
+            this.checkLValSimple(left);
+          }
+          node.left = left;
+          this.next();
+          node.right = this.parseMaybeAssign(forInit);
+          if (oldDoubleProto > -1) {
+            refDestructuringErrors.doubleProto = oldDoubleProto;
+          }
+          return this.finishNode(node, "AssignmentExpression");
+        } else {
+          if (ownDestructuringErrors) {
+            this.checkExpressionErrors(refDestructuringErrors, true);
+          }
+        }
+        if (oldParenAssign > -1) {
+          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
+        }
+        if (oldTrailingComma > -1) {
+          refDestructuringErrors.trailingComma = oldTrailingComma;
+        }
+        return left;
+      };
+      pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
+        var startPos = this.start, startLoc = this.startLoc;
+        var expr = this.parseExprOps(forInit, refDestructuringErrors);
+        if (this.checkExpressionErrors(refDestructuringErrors)) {
+          return expr;
+        }
+        if (this.eat(types$12.question)) {
+          var node = this.startNodeAt(startPos, startLoc);
+          node.test = expr;
+          node.consequent = this.parseMaybeAssign();
+          this.expect(types$12.colon);
+          node.alternate = this.parseMaybeAssign(forInit);
+          return this.finishNode(node, "ConditionalExpression");
+        }
+        return expr;
+      };
+      pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
+        var startPos = this.start, startLoc = this.startLoc;
+        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
+        if (this.checkExpressionErrors(refDestructuringErrors)) {
+          return expr;
+        }
+        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
+      };
+      pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
+        var prec = this.type.binop;
+        if (prec != null && (!forInit || this.type !== types$12._in)) {
+          if (prec > minPrec) {
+            var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND;
+            var coalesce = this.type === types$12.coalesce;
+            if (coalesce) {
+              prec = types$12.logicalAND.binop;
+            }
+            var op = this.value;
+            this.next();
+            var startPos = this.start, startLoc = this.startLoc;
+            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
+            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
+            if (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) {
+              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
+            }
+            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
+          }
+        }
+        return left;
+      };
+      pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
+        if (right.type === "PrivateIdentifier") {
+          this.raise(right.start, "Private identifier can only be left side of binary expression");
+        }
+        var node = this.startNodeAt(startPos, startLoc);
+        node.left = left;
+        node.operator = op;
+        node.right = right;
+        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
+      };
+      pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
+        var startPos = this.start, startLoc = this.startLoc, expr;
+        if (this.isContextual("await") && this.canAwait) {
+          expr = this.parseAwait(forInit);
+          sawUnary = true;
+        } else if (this.type.prefix) {
+          var node = this.startNode(), update = this.type === types$12.incDec;
+          node.operator = this.value;
+          node.prefix = true;
+          this.next();
+          node.argument = this.parseMaybeUnary(null, true, update, forInit);
+          this.checkExpressionErrors(refDestructuringErrors, true);
+          if (update) {
+            this.checkLValSimple(node.argument);
+          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
+            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
+          } else if (node.operator === "delete" && isPrivateFieldAccess2(node.argument)) {
+            this.raiseRecoverable(node.start, "Private fields can not be deleted");
+          } else {
+            sawUnary = true;
+          }
+          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
+        } else if (!sawUnary && this.type === types$12.privateId) {
+          if (forInit || this.privateNameStack.length === 0) {
+            this.unexpected();
+          }
+          expr = this.parsePrivateIdent();
+          if (this.type !== types$12._in) {
+            this.unexpected();
+          }
+        } else {
+          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
+          if (this.checkExpressionErrors(refDestructuringErrors)) {
+            return expr;
+          }
+          while (this.type.postfix && !this.canInsertSemicolon()) {
+            var node$1 = this.startNodeAt(startPos, startLoc);
+            node$1.operator = this.value;
+            node$1.prefix = false;
+            node$1.argument = expr;
+            this.checkLValSimple(expr);
+            this.next();
+            expr = this.finishNode(node$1, "UpdateExpression");
+          }
+        }
+        if (!incDec && this.eat(types$12.starstar)) {
+          if (sawUnary) {
+            this.unexpected(this.lastTokStart);
+          } else {
+            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
+          }
+        } else {
+          return expr;
+        }
+      };
+      function isPrivateFieldAccess2(node) {
+        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess2(node.expression);
+      }
+      pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
+        var startPos = this.start, startLoc = this.startLoc;
+        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
+        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
+          return expr;
+        }
+        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
+        if (refDestructuringErrors && result.type === "MemberExpression") {
+          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
+            refDestructuringErrors.parenthesizedAssign = -1;
+          }
+          if (refDestructuringErrors.parenthesizedBind >= result.start) {
+            refDestructuringErrors.parenthesizedBind = -1;
+          }
+          if (refDestructuringErrors.trailingComma >= result.start) {
+            refDestructuringErrors.trailingComma = -1;
+          }
+        }
+        return result;
+      };
+      pp$52.parseSubscripts = function(base3, startPos, startLoc, noCalls, forInit) {
+        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base3.type === "Identifier" && base3.name === "async" && this.lastTokEnd === base3.end && !this.canInsertSemicolon() && base3.end - base3.start === 5 && this.potentialArrowAt === base3.start;
+        var optionalChained = false;
+        while (true) {
+          var element3 = this.parseSubscript(base3, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
+          if (element3.optional) {
+            optionalChained = true;
+          }
+          if (element3 === base3 || element3.type === "ArrowFunctionExpression") {
+            if (optionalChained) {
+              var chainNode = this.startNodeAt(startPos, startLoc);
+              chainNode.expression = element3;
+              element3 = this.finishNode(chainNode, "ChainExpression");
+            }
+            return element3;
+          }
+          base3 = element3;
+        }
+      };
+      pp$52.parseSubscript = function(base3, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
+        var optionalSupported = this.options.ecmaVersion >= 11;
+        var optional = optionalSupported && this.eat(types$12.questionDot);
+        if (noCalls && optional) {
+          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
+        }
+        var computed = this.eat(types$12.bracketL);
+        if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
+          var node = this.startNodeAt(startPos, startLoc);
+          node.object = base3;
+          if (computed) {
+            node.property = this.parseExpression();
+            this.expect(types$12.bracketR);
+          } else if (this.type === types$12.privateId && base3.type !== "Super") {
+            node.property = this.parsePrivateIdent();
+          } else {
+            node.property = this.parseIdent(this.options.allowReserved !== "never");
+          }
+          node.computed = !!computed;
+          if (optionalSupported) {
+            node.optional = optional;
+          }
+          base3 = this.finishNode(node, "MemberExpression");
+        } else if (!noCalls && this.eat(types$12.parenL)) {
+          var refDestructuringErrors = new DestructuringErrors2(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
+          this.yieldPos = 0;
+          this.awaitPos = 0;
+          this.awaitIdentPos = 0;
+          var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
+          if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$12.arrow)) {
+            this.checkPatternErrors(refDestructuringErrors, false);
+            this.checkYieldAwaitInDefaultParams();
+            if (this.awaitIdentPos > 0) {
+              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
+            }
+            this.yieldPos = oldYieldPos;
+            this.awaitPos = oldAwaitPos;
+            this.awaitIdentPos = oldAwaitIdentPos;
+            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
+          }
+          this.checkExpressionErrors(refDestructuringErrors, true);
+          this.yieldPos = oldYieldPos || this.yieldPos;
+          this.awaitPos = oldAwaitPos || this.awaitPos;
+          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
+          var node$1 = this.startNodeAt(startPos, startLoc);
+          node$1.callee = base3;
+          node$1.arguments = exprList;
+          if (optionalSupported) {
+            node$1.optional = optional;
+          }
+          base3 = this.finishNode(node$1, "CallExpression");
+        } else if (this.type === types$12.backQuote) {
+          if (optional || optionalChained) {
+            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
+          }
+          var node$2 = this.startNodeAt(startPos, startLoc);
+          node$2.tag = base3;
+          node$2.quasi = this.parseTemplate({ isTagged: true });
+          base3 = this.finishNode(node$2, "TaggedTemplateExpression");
+        }
+        return base3;
+      };
+      pp$52.parseExprAtom = function(refDestructuringErrors, forInit) {
+        if (this.type === types$12.slash) {
+          this.readRegexp();
+        }
+        var node, canBeArrow = this.potentialArrowAt === this.start;
+        switch (this.type) {
+          case types$12._super:
+            if (!this.allowSuper) {
+              this.raise(this.start, "'super' keyword outside a method");
+            }
+            node = this.startNode();
+            this.next();
+            if (this.type === types$12.parenL && !this.allowDirectSuper) {
+              this.raise(node.start, "super() call outside constructor of a subclass");
+            }
+            if (this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL) {
+              this.unexpected();
+            }
+            return this.finishNode(node, "Super");
+          case types$12._this:
+            node = this.startNode();
+            this.next();
+            return this.finishNode(node, "ThisExpression");
+          case types$12.name:
+            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
+            var id = this.parseIdent(false);
+            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$12._function)) {
+              this.overrideContext(types3.f_expr);
+              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
+            }
+            if (canBeArrow && !this.canInsertSemicolon()) {
+              if (this.eat(types$12.arrow)) {
+                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
+              }
+              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
+                id = this.parseIdent(false);
+                if (this.canInsertSemicolon() || !this.eat(types$12.arrow)) {
+                  this.unexpected();
+                }
+                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
+              }
+            }
+            return id;
+          case types$12.regexp:
+            var value = this.value;
+            node = this.parseLiteral(value.value);
+            node.regex = { pattern: value.pattern, flags: value.flags };
+            return node;
+          case types$12.num:
+          case types$12.string:
+            return this.parseLiteral(this.value);
+          case types$12._null:
+          case types$12._true:
+          case types$12._false:
+            node = this.startNode();
+            node.value = this.type === types$12._null ? null : this.type === types$12._true;
+            node.raw = this.type.keyword;
+            this.next();
+            return this.finishNode(node, "Literal");
+          case types$12.parenL:
+            var start3 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
+            if (refDestructuringErrors) {
+              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
+                refDestructuringErrors.parenthesizedAssign = start3;
+              }
+              if (refDestructuringErrors.parenthesizedBind < 0) {
+                refDestructuringErrors.parenthesizedBind = start3;
+              }
+            }
+            return expr;
+          case types$12.bracketL:
+            node = this.startNode();
+            this.next();
+            node.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors);
+            return this.finishNode(node, "ArrayExpression");
+          case types$12.braceL:
+            this.overrideContext(types3.b_expr);
+            return this.parseObj(false, refDestructuringErrors);
+          case types$12._function:
+            node = this.startNode();
+            this.next();
+            return this.parseFunction(node, 0);
+          case types$12._class:
+            return this.parseClass(this.startNode(), false);
+          case types$12._new:
+            return this.parseNew();
+          case types$12.backQuote:
+            return this.parseTemplate();
+          case types$12._import:
+            if (this.options.ecmaVersion >= 11) {
+              return this.parseExprImport();
+            } else {
+              return this.unexpected();
+            }
+          default:
+            this.unexpected();
+        }
+      };
+      pp$52.parseExprImport = function() {
+        var node = this.startNode();
+        if (this.containsEsc) {
+          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
+        }
+        var meta = this.parseIdent(true);
+        switch (this.type) {
+          case types$12.parenL:
+            return this.parseDynamicImport(node);
+          case types$12.dot:
+            node.meta = meta;
+            return this.parseImportMeta(node);
+          default:
+            this.unexpected();
+        }
+      };
+      pp$52.parseDynamicImport = function(node) {
+        this.next();
+        node.source = this.parseMaybeAssign();
+        if (!this.eat(types$12.parenR)) {
+          var errorPos = this.start;
+          if (this.eat(types$12.comma) && this.eat(types$12.parenR)) {
+            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
+          } else {
+            this.unexpected(errorPos);
+          }
+        }
+        return this.finishNode(node, "ImportExpression");
+      };
+      pp$52.parseImportMeta = function(node) {
+        this.next();
+        var containsEsc = this.containsEsc;
+        node.property = this.parseIdent(true);
+        if (node.property.name !== "meta") {
+          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
+        }
+        if (containsEsc) {
+          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
+        }
+        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
+          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
+        }
+        return this.finishNode(node, "MetaProperty");
+      };
+      pp$52.parseLiteral = function(value) {
+        var node = this.startNode();
+        node.value = value;
+        node.raw = this.input.slice(this.start, this.end);
+        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
+          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
+        }
+        this.next();
+        return this.finishNode(node, "Literal");
+      };
+      pp$52.parseParenExpression = function() {
+        this.expect(types$12.parenL);
+        var val = this.parseExpression();
+        this.expect(types$12.parenR);
+        return val;
+      };
+      pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
+        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
+        if (this.options.ecmaVersion >= 6) {
+          this.next();
+          var innerStartPos = this.start, innerStartLoc = this.startLoc;
+          var exprList = [], first = true, lastIsComma = false;
+          var refDestructuringErrors = new DestructuringErrors2(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
+          this.yieldPos = 0;
+          this.awaitPos = 0;
+          while (this.type !== types$12.parenR) {
+            first ? first = false : this.expect(types$12.comma);
+            if (allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
+              lastIsComma = true;
+              break;
+            } else if (this.type === types$12.ellipsis) {
+              spreadStart = this.start;
+              exprList.push(this.parseParenItem(this.parseRestBinding()));
+              if (this.type === types$12.comma) {
+                this.raise(this.start, "Comma is not permitted after the rest element");
+              }
+              break;
+            } else {
+              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
+            }
+          }
+          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
+          this.expect(types$12.parenR);
+          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$12.arrow)) {
+            this.checkPatternErrors(refDestructuringErrors, false);
+            this.checkYieldAwaitInDefaultParams();
+            this.yieldPos = oldYieldPos;
+            this.awaitPos = oldAwaitPos;
+            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
+          }
+          if (!exprList.length || lastIsComma) {
+            this.unexpected(this.lastTokStart);
+          }
+          if (spreadStart) {
+            this.unexpected(spreadStart);
+          }
+          this.checkExpressionErrors(refDestructuringErrors, true);
+          this.yieldPos = oldYieldPos || this.yieldPos;
+          this.awaitPos = oldAwaitPos || this.awaitPos;
+          if (exprList.length > 1) {
+            val = this.startNodeAt(innerStartPos, innerStartLoc);
+            val.expressions = exprList;
+            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
+          } else {
+            val = exprList[0];
+          }
+        } else {
+          val = this.parseParenExpression();
+        }
+        if (this.options.preserveParens) {
+          var par = this.startNodeAt(startPos, startLoc);
+          par.expression = val;
+          return this.finishNode(par, "ParenthesizedExpression");
+        } else {
+          return val;
+        }
+      };
+      pp$52.parseParenItem = function(item) {
+        return item;
+      };
+      pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
+        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
+      };
+      var empty3 = [];
+      pp$52.parseNew = function() {
+        if (this.containsEsc) {
+          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
+        }
+        var node = this.startNode();
+        var meta = this.parseIdent(true);
+        if (this.options.ecmaVersion >= 6 && this.eat(types$12.dot)) {
+          node.meta = meta;
+          var containsEsc = this.containsEsc;
+          node.property = this.parseIdent(true);
+          if (node.property.name !== "target") {
+            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
+          }
+          if (containsEsc) {
+            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
+          }
+          if (!this.allowNewDotTarget) {
+            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
+          }
+          return this.finishNode(node, "MetaProperty");
+        }
+        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$12._import;
+        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
+        if (isImport && node.callee.type === "ImportExpression") {
+          this.raise(startPos, "Cannot use new with import()");
+        }
+        if (this.eat(types$12.parenL)) {
+          node.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false);
+        } else {
+          node.arguments = empty3;
+        }
+        return this.finishNode(node, "NewExpression");
+      };
+      pp$52.parseTemplateElement = function(ref3) {
+        var isTagged = ref3.isTagged;
+        var elem = this.startNode();
+        if (this.type === types$12.invalidTemplate) {
+          if (!isTagged) {
+            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
+          }
+          elem.value = {
+            raw: this.value,
+            cooked: null
+          };
+        } else {
+          elem.value = {
+            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
+            cooked: this.value
+          };
+        }
+        this.next();
+        elem.tail = this.type === types$12.backQuote;
+        return this.finishNode(elem, "TemplateElement");
+      };
+      pp$52.parseTemplate = function(ref3) {
+        if (ref3 === void 0)
+          ref3 = {};
+        var isTagged = ref3.isTagged;
+        if (isTagged === void 0)
+          isTagged = false;
+        var node = this.startNode();
+        this.next();
+        node.expressions = [];
+        var curElt = this.parseTemplateElement({ isTagged });
+        node.quasis = [curElt];
+        while (!curElt.tail) {
+          if (this.type === types$12.eof) {
+            this.raise(this.pos, "Unterminated template literal");
+          }
+          this.expect(types$12.dollarBraceL);
+          node.expressions.push(this.parseExpression());
+          this.expect(types$12.braceR);
+          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
+        }
+        this.next();
+        return this.finishNode(node, "TemplateLiteral");
+      };
+      pp$52.isAsyncProp = function(prop) {
+        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
+      };
+      pp$52.parseObj = function(isPattern, refDestructuringErrors) {
+        var node = this.startNode(), first = true, propHash = {};
+        node.properties = [];
+        this.next();
+        while (!this.eat(types$12.braceR)) {
+          if (!first) {
+            this.expect(types$12.comma);
+            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR)) {
+              break;
+            }
+          } else {
+            first = false;
+          }
+          var prop = this.parseProperty(isPattern, refDestructuringErrors);
+          if (!isPattern) {
+            this.checkPropClash(prop, propHash, refDestructuringErrors);
+          }
+          node.properties.push(prop);
+        }
+        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
+      };
+      pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
+        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
+        if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis)) {
+          if (isPattern) {
+            prop.argument = this.parseIdent(false);
+            if (this.type === types$12.comma) {
+              this.raise(this.start, "Comma is not permitted after the rest element");
+            }
+            return this.finishNode(prop, "RestElement");
+          }
+          if (this.type === types$12.parenL && refDestructuringErrors) {
+            if (refDestructuringErrors.parenthesizedAssign < 0) {
+              refDestructuringErrors.parenthesizedAssign = this.start;
+            }
+            if (refDestructuringErrors.parenthesizedBind < 0) {
+              refDestructuringErrors.parenthesizedBind = this.start;
+            }
+          }
+          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
+          if (this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
+            refDestructuringErrors.trailingComma = this.start;
+          }
+          return this.finishNode(prop, "SpreadElement");
+        }
+        if (this.options.ecmaVersion >= 6) {
+          prop.method = false;
+          prop.shorthand = false;
+          if (isPattern || refDestructuringErrors) {
+            startPos = this.start;
+            startLoc = this.startLoc;
+          }
+          if (!isPattern) {
+            isGenerator = this.eat(types$12.star);
+          }
+        }
+        var containsEsc = this.containsEsc;
+        this.parsePropertyName(prop);
+        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
+          isAsync = true;
+          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$12.star);
+          this.parsePropertyName(prop, refDestructuringErrors);
+        } else {
+          isAsync = false;
+        }
+        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
+        return this.finishNode(prop, "Property");
+      };
+      pp$52.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
+        if ((isGenerator || isAsync) && this.type === types$12.colon) {
+          this.unexpected();
+        }
+        if (this.eat(types$12.colon)) {
+          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
+          prop.kind = "init";
+        } else if (this.options.ecmaVersion >= 6 && this.type === types$12.parenL) {
+          if (isPattern) {
+            this.unexpected();
+          }
+          prop.kind = "init";
+          prop.method = true;
+          prop.value = this.parseMethod(isGenerator, isAsync);
+        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$12.comma && this.type !== types$12.braceR && this.type !== types$12.eq)) {
+          if (isGenerator || isAsync) {
+            this.unexpected();
+          }
+          prop.kind = prop.key.name;
+          this.parsePropertyName(prop);
+          prop.value = this.parseMethod(false);
+          var paramCount = prop.kind === "get" ? 0 : 1;
+          if (prop.value.params.length !== paramCount) {
+            var start3 = prop.value.start;
+            if (prop.kind === "get") {
+              this.raiseRecoverable(start3, "getter should have no params");
+            } else {
+              this.raiseRecoverable(start3, "setter should have exactly one param");
+            }
+          } else {
+            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
+              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
+            }
+          }
+        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
+          if (isGenerator || isAsync) {
+            this.unexpected();
+          }
+          this.checkUnreserved(prop.key);
+          if (prop.key.name === "await" && !this.awaitIdentPos) {
+            this.awaitIdentPos = startPos;
+          }
+          prop.kind = "init";
+          if (isPattern) {
+            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
+          } else if (this.type === types$12.eq && refDestructuringErrors) {
+            if (refDestructuringErrors.shorthandAssign < 0) {
+              refDestructuringErrors.shorthandAssign = this.start;
+            }
+            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
+          } else {
+            prop.value = this.copyNode(prop.key);
+          }
+          prop.shorthand = true;
+        } else {
+          this.unexpected();
+        }
+      };
+      pp$52.parsePropertyName = function(prop) {
+        if (this.options.ecmaVersion >= 6) {
+          if (this.eat(types$12.bracketL)) {
+            prop.computed = true;
+            prop.key = this.parseMaybeAssign();
+            this.expect(types$12.bracketR);
+            return prop.key;
+          } else {
+            prop.computed = false;
+          }
+        }
+        return prop.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
+      };
+      pp$52.initFunction = function(node) {
+        node.id = null;
+        if (this.options.ecmaVersion >= 6) {
+          node.generator = node.expression = false;
+        }
+        if (this.options.ecmaVersion >= 8) {
+          node.async = false;
+        }
+      };
+      pp$52.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
+        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
+        this.initFunction(node);
+        if (this.options.ecmaVersion >= 6) {
+          node.generator = isGenerator;
+        }
+        if (this.options.ecmaVersion >= 8) {
+          node.async = !!isAsync;
+        }
+        this.yieldPos = 0;
+        this.awaitPos = 0;
+        this.awaitIdentPos = 0;
+        this.enterScope(functionFlags2(isAsync, node.generator) | SCOPE_SUPER2 | (allowDirectSuper ? SCOPE_DIRECT_SUPER2 : 0));
+        this.expect(types$12.parenL);
+        node.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
+        this.checkYieldAwaitInDefaultParams();
+        this.parseFunctionBody(node, false, true, false);
+        this.yieldPos = oldYieldPos;
+        this.awaitPos = oldAwaitPos;
+        this.awaitIdentPos = oldAwaitIdentPos;
+        return this.finishNode(node, "FunctionExpression");
+      };
+      pp$52.parseArrowExpression = function(node, params, isAsync, forInit) {
+        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
+        this.enterScope(functionFlags2(isAsync, false) | SCOPE_ARROW2);
+        this.initFunction(node);
+        if (this.options.ecmaVersion >= 8) {
+          node.async = !!isAsync;
+        }
+        this.yieldPos = 0;
+        this.awaitPos = 0;
+        this.awaitIdentPos = 0;
+        node.params = this.toAssignableList(params, true);
+        this.parseFunctionBody(node, true, false, forInit);
+        this.yieldPos = oldYieldPos;
+        this.awaitPos = oldAwaitPos;
+        this.awaitIdentPos = oldAwaitIdentPos;
+        return this.finishNode(node, "ArrowFunctionExpression");
+      };
+      pp$52.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
+        var isExpression = isArrowFunction && this.type !== types$12.braceL;
+        var oldStrict = this.strict, useStrict = false;
+        if (isExpression) {
+          node.body = this.parseMaybeAssign(forInit);
+          node.expression = true;
+          this.checkParams(node, false);
+        } else {
+          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
+          if (!oldStrict || nonSimple) {
+            useStrict = this.strictDirective(this.end);
+            if (useStrict && nonSimple) {
+              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
+            }
+          }
+          var oldLabels = this.labels;
+          this.labels = [];
+          if (useStrict) {
+            this.strict = true;
+          }
+          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
+          if (this.strict && node.id) {
+            this.checkLValSimple(node.id, BIND_OUTSIDE2);
+          }
+          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
+          node.expression = false;
+          this.adaptDirectivePrologue(node.body.body);
+          this.labels = oldLabels;
+        }
+        this.exitScope();
+      };
+      pp$52.isSimpleParamList = function(params) {
+        for (var i2 = 0, list4 = params; i2 < list4.length; i2 += 1) {
+          var param = list4[i2];
+          if (param.type !== "Identifier") {
+            return false;
+          }
+        }
+        return true;
+      };
+      pp$52.checkParams = function(node, allowDuplicates) {
+        var nameHash = /* @__PURE__ */ Object.create(null);
+        for (var i2 = 0, list4 = node.params; i2 < list4.length; i2 += 1) {
+          var param = list4[i2];
+          this.checkLValInnerPattern(param, BIND_VAR2, allowDuplicates ? null : nameHash);
+        }
+      };
+      pp$52.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
+        var elts = [], first = true;
+        while (!this.eat(close)) {
+          if (!first) {
+            this.expect(types$12.comma);
+            if (allowTrailingComma && this.afterTrailingComma(close)) {
+              break;
+            }
+          } else {
+            first = false;
+          }
+          var elt = void 0;
+          if (allowEmpty && this.type === types$12.comma) {
+            elt = null;
+          } else if (this.type === types$12.ellipsis) {
+            elt = this.parseSpread(refDestructuringErrors);
+            if (refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0) {
+              refDestructuringErrors.trailingComma = this.start;
+            }
+          } else {
+            elt = this.parseMaybeAssign(false, refDestructuringErrors);
+          }
+          elts.push(elt);
+        }
+        return elts;
+      };
+      pp$52.checkUnreserved = function(ref3) {
+        var start3 = ref3.start;
+        var end = ref3.end;
+        var name3 = ref3.name;
+        if (this.inGenerator && name3 === "yield") {
+          this.raiseRecoverable(start3, "Cannot use 'yield' as identifier inside a generator");
+        }
+        if (this.inAsync && name3 === "await") {
+          this.raiseRecoverable(start3, "Cannot use 'await' as identifier inside an async function");
+        }
+        if (this.currentThisScope().inClassFieldInit && name3 === "arguments") {
+          this.raiseRecoverable(start3, "Cannot use 'arguments' in class field initializer");
+        }
+        if (this.inClassStaticBlock && (name3 === "arguments" || name3 === "await")) {
+          this.raise(start3, "Cannot use " + name3 + " in class static initialization block");
+        }
+        if (this.keywords.test(name3)) {
+          this.raise(start3, "Unexpected keyword '" + name3 + "'");
+        }
+        if (this.options.ecmaVersion < 6 && this.input.slice(start3, end).indexOf("\\") !== -1) {
+          return;
+        }
+        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
+        if (re.test(name3)) {
+          if (!this.inAsync && name3 === "await") {
+            this.raiseRecoverable(start3, "Cannot use keyword 'await' outside an async function");
+          }
+          this.raiseRecoverable(start3, "The keyword '" + name3 + "' is reserved");
+        }
+      };
+      pp$52.parseIdent = function(liberal, isBinding) {
+        var node = this.startNode();
+        if (this.type === types$12.name) {
+          node.name = this.value;
+        } else if (this.type.keyword) {
+          node.name = this.type.keyword;
+          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
+            this.context.pop();
+          }
+        } else {
+          this.unexpected();
+        }
+        this.next(!!liberal);
+        this.finishNode(node, "Identifier");
+        if (!liberal) {
+          this.checkUnreserved(node);
+          if (node.name === "await" && !this.awaitIdentPos) {
+            this.awaitIdentPos = node.start;
+          }
+        }
+        return node;
+      };
+      pp$52.parsePrivateIdent = function() {
+        var node = this.startNode();
+        if (this.type === types$12.privateId) {
+          node.name = this.value;
+        } else {
+          this.unexpected();
+        }
+        this.next();
+        this.finishNode(node, "PrivateIdentifier");
+        if (this.privateNameStack.length === 0) {
+          this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
+        } else {
+          this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
+        }
+        return node;
+      };
+      pp$52.parseYield = function(forInit) {
+        if (!this.yieldPos) {
+          this.yieldPos = this.start;
+        }
+        var node = this.startNode();
+        this.next();
+        if (this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr) {
+          node.delegate = false;
+          node.argument = null;
+        } else {
+          node.delegate = this.eat(types$12.star);
+          node.argument = this.parseMaybeAssign(forInit);
+        }
+        return this.finishNode(node, "YieldExpression");
+      };
+      pp$52.parseAwait = function(forInit) {
+        if (!this.awaitPos) {
+          this.awaitPos = this.start;
+        }
+        var node = this.startNode();
+        this.next();
+        node.argument = this.parseMaybeUnary(null, true, false, forInit);
+        return this.finishNode(node, "AwaitExpression");
+      };
+      var pp$42 = Parser4.prototype;
+      pp$42.raise = function(pos, message) {
+        var loc = getLineInfo2(this.input, pos);
+        message += " (" + loc.line + ":" + loc.column + ")";
+        var err = new SyntaxError(message);
+        err.pos = pos;
+        err.loc = loc;
+        err.raisedAt = this.pos;
+        throw err;
+      };
+      pp$42.raiseRecoverable = pp$42.raise;
+      pp$42.curPosition = function() {
+        if (this.options.locations) {
+          return new Position3(this.curLine, this.pos - this.lineStart);
+        }
+      };
+      var pp$32 = Parser4.prototype;
+      var Scope4 = function Scope5(flags) {
+        this.flags = flags;
+        this.var = [];
+        this.lexical = [];
+        this.functions = [];
+        this.inClassFieldInit = false;
+      };
+      pp$32.enterScope = function(flags) {
+        this.scopeStack.push(new Scope4(flags));
+      };
+      pp$32.exitScope = function() {
+        this.scopeStack.pop();
+      };
+      pp$32.treatFunctionsAsVarInScope = function(scope) {
+        return scope.flags & SCOPE_FUNCTION2 || !this.inModule && scope.flags & SCOPE_TOP2;
+      };
+      pp$32.declareName = function(name3, bindingType, pos) {
+        var redeclared = false;
+        if (bindingType === BIND_LEXICAL2) {
+          var scope = this.currentScope();
+          redeclared = scope.lexical.indexOf(name3) > -1 || scope.functions.indexOf(name3) > -1 || scope.var.indexOf(name3) > -1;
+          scope.lexical.push(name3);
+          if (this.inModule && scope.flags & SCOPE_TOP2) {
+            delete this.undefinedExports[name3];
+          }
+        } else if (bindingType === BIND_SIMPLE_CATCH2) {
+          var scope$1 = this.currentScope();
+          scope$1.lexical.push(name3);
+        } else if (bindingType === BIND_FUNCTION2) {
+          var scope$2 = this.currentScope();
+          if (this.treatFunctionsAsVar) {
+            redeclared = scope$2.lexical.indexOf(name3) > -1;
+          } else {
+            redeclared = scope$2.lexical.indexOf(name3) > -1 || scope$2.var.indexOf(name3) > -1;
+          }
+          scope$2.functions.push(name3);
+        } else {
+          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
+            var scope$3 = this.scopeStack[i2];
+            if (scope$3.lexical.indexOf(name3) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH2 && scope$3.lexical[0] === name3) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name3) > -1) {
+              redeclared = true;
+              break;
+            }
+            scope$3.var.push(name3);
+            if (this.inModule && scope$3.flags & SCOPE_TOP2) {
+              delete this.undefinedExports[name3];
+            }
+            if (scope$3.flags & SCOPE_VAR2) {
+              break;
+            }
+          }
+        }
+        if (redeclared) {
+          this.raiseRecoverable(pos, "Identifier '" + name3 + "' has already been declared");
+        }
+      };
+      pp$32.checkLocalExport = function(id) {
+        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
+          this.undefinedExports[id.name] = id;
+        }
+      };
+      pp$32.currentScope = function() {
+        return this.scopeStack[this.scopeStack.length - 1];
+      };
+      pp$32.currentVarScope = function() {
+        for (var i2 = this.scopeStack.length - 1; ; i2--) {
+          var scope = this.scopeStack[i2];
+          if (scope.flags & SCOPE_VAR2) {
+            return scope;
+          }
+        }
+      };
+      pp$32.currentThisScope = function() {
+        for (var i2 = this.scopeStack.length - 1; ; i2--) {
+          var scope = this.scopeStack[i2];
+          if (scope.flags & SCOPE_VAR2 && !(scope.flags & SCOPE_ARROW2)) {
+            return scope;
+          }
+        }
+      };
+      var Node3 = function Node4(parser2, pos, loc) {
+        this.type = "";
+        this.start = pos;
+        this.end = 0;
+        if (parser2.options.locations) {
+          this.loc = new SourceLocation3(parser2, loc);
+        }
+        if (parser2.options.directSourceFile) {
+          this.sourceFile = parser2.options.directSourceFile;
+        }
+        if (parser2.options.ranges) {
+          this.range = [pos, 0];
+        }
+      };
+      var pp$22 = Parser4.prototype;
+      pp$22.startNode = function() {
+        return new Node3(this, this.start, this.startLoc);
+      };
+      pp$22.startNodeAt = function(pos, loc) {
+        return new Node3(this, pos, loc);
+      };
+      function finishNodeAt2(node, type2, pos, loc) {
+        node.type = type2;
+        node.end = pos;
+        if (this.options.locations) {
+          node.loc.end = loc;
+        }
+        if (this.options.ranges) {
+          node.range[1] = pos;
+        }
+        return node;
+      }
+      pp$22.finishNode = function(node, type2) {
+        return finishNodeAt2.call(this, node, type2, this.lastTokEnd, this.lastTokEndLoc);
+      };
+      pp$22.finishNodeAt = function(node, type2, pos, loc) {
+        return finishNodeAt2.call(this, node, type2, pos, loc);
+      };
+      pp$22.copyNode = function(node) {
+        var newNode = new Node3(this, node.start, this.startLoc);
+        for (var prop in node) {
+          newNode[prop] = node[prop];
+        }
+        return newNode;
+      };
+      var ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
+      var ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic";
+      var ecma11BinaryProperties2 = ecma10BinaryProperties2;
+      var ecma12BinaryProperties2 = ecma11BinaryProperties2 + " EBase EComp EMod EPres ExtPict";
+      var ecma13BinaryProperties2 = ecma12BinaryProperties2;
+      var unicodeBinaryProperties2 = {
+        9: ecma9BinaryProperties2,
+        10: ecma10BinaryProperties2,
+        11: ecma11BinaryProperties2,
+        12: ecma12BinaryProperties2,
+        13: ecma13BinaryProperties2
+      };
+      var unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
+      var ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
+      var ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
+      var ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
+      var ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
+      var ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
+      var unicodeScriptValues2 = {
+        9: ecma9ScriptValues2,
+        10: ecma10ScriptValues2,
+        11: ecma11ScriptValues2,
+        12: ecma12ScriptValues2,
+        13: ecma13ScriptValues2
+      };
+      var data2 = {};
+      function buildUnicodeData2(ecmaVersion2) {
+        var d = data2[ecmaVersion2] = {
+          binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion2] + " " + unicodeGeneralCategoryValues2),
+          nonBinary: {
+            General_Category: wordsRegexp2(unicodeGeneralCategoryValues2),
+            Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion2])
+          }
+        };
+        d.nonBinary.Script_Extensions = d.nonBinary.Script;
+        d.nonBinary.gc = d.nonBinary.General_Category;
+        d.nonBinary.sc = d.nonBinary.Script;
+        d.nonBinary.scx = d.nonBinary.Script_Extensions;
+      }
+      for (var i = 0, list3 = [9, 10, 11, 12, 13]; i < list3.length; i += 1) {
+        var ecmaVersion = list3[i];
+        buildUnicodeData2(ecmaVersion);
+      }
+      var pp$12 = Parser4.prototype;
+      var RegExpValidationState3 = function RegExpValidationState4(parser2) {
+        this.parser = parser2;
+        this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
+        this.unicodeProperties = data2[parser2.options.ecmaVersion >= 13 ? 13 : parser2.options.ecmaVersion];
+        this.source = "";
+        this.flags = "";
+        this.start = 0;
+        this.switchU = false;
+        this.switchN = false;
+        this.pos = 0;
+        this.lastIntValue = 0;
+        this.lastStringValue = "";
+        this.lastAssertionIsQuantifiable = false;
+        this.numCapturingParens = 0;
+        this.maxBackReference = 0;
+        this.groupNames = [];
+        this.backReferenceNames = [];
+      };
+      RegExpValidationState3.prototype.reset = function reset2(start3, pattern, flags) {
+        var unicode2 = flags.indexOf("u") !== -1;
+        this.start = start3 | 0;
+        this.source = pattern + "";
+        this.flags = flags;
+        this.switchU = unicode2 && this.parser.options.ecmaVersion >= 6;
+        this.switchN = unicode2 && this.parser.options.ecmaVersion >= 9;
+      };
+      RegExpValidationState3.prototype.raise = function raise2(message) {
+        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
+      };
+      RegExpValidationState3.prototype.at = function at2(i2, forceU) {
+        if (forceU === void 0)
+          forceU = false;
+        var s2 = this.source;
+        var l = s2.length;
+        if (i2 >= l) {
+          return -1;
+        }
+        var c = s2.charCodeAt(i2);
+        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
+          return c;
+        }
+        var next = s2.charCodeAt(i2 + 1);
+        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
+      };
+      RegExpValidationState3.prototype.nextIndex = function nextIndex2(i2, forceU) {
+        if (forceU === void 0)
+          forceU = false;
+        var s2 = this.source;
+        var l = s2.length;
+        if (i2 >= l) {
+          return l;
+        }
+        var c = s2.charCodeAt(i2), next;
+        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s2.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
+          return i2 + 1;
+        }
+        return i2 + 2;
+      };
+      RegExpValidationState3.prototype.current = function current2(forceU) {
+        if (forceU === void 0)
+          forceU = false;
+        return this.at(this.pos, forceU);
+      };
+      RegExpValidationState3.prototype.lookahead = function lookahead2(forceU) {
+        if (forceU === void 0)
+          forceU = false;
+        return this.at(this.nextIndex(this.pos, forceU), forceU);
+      };
+      RegExpValidationState3.prototype.advance = function advance2(forceU) {
+        if (forceU === void 0)
+          forceU = false;
+        this.pos = this.nextIndex(this.pos, forceU);
+      };
+      RegExpValidationState3.prototype.eat = function eat2(ch, forceU) {
+        if (forceU === void 0)
+          forceU = false;
+        if (this.current(forceU) === ch) {
+          this.advance(forceU);
+          return true;
+        }
+        return false;
+      };
+      function codePointToString$12(ch) {
+        if (ch <= 65535) {
+          return String.fromCharCode(ch);
+        }
+        ch -= 65536;
+        return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
+      }
+      pp$12.validateRegExpFlags = function(state) {
+        var validFlags = state.validFlags;
+        var flags = state.flags;
+        for (var i2 = 0; i2 < flags.length; i2++) {
+          var flag = flags.charAt(i2);
+          if (validFlags.indexOf(flag) === -1) {
+            this.raise(state.start, "Invalid regular expression flag");
+          }
+          if (flags.indexOf(flag, i2 + 1) > -1) {
+            this.raise(state.start, "Duplicate regular expression flag");
+          }
+        }
+      };
+      pp$12.validateRegExpPattern = function(state) {
+        this.regexp_pattern(state);
+        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
+          state.switchN = true;
+          this.regexp_pattern(state);
+        }
+      };
+      pp$12.regexp_pattern = function(state) {
+        state.pos = 0;
+        state.lastIntValue = 0;
+        state.lastStringValue = "";
+        state.lastAssertionIsQuantifiable = false;
+        state.numCapturingParens = 0;
+        state.maxBackReference = 0;
+        state.groupNames.length = 0;
+        state.backReferenceNames.length = 0;
+        this.regexp_disjunction(state);
+        if (state.pos !== state.source.length) {
+          if (state.eat(41)) {
+            state.raise("Unmatched ')'");
+          }
+          if (state.eat(93) || state.eat(125)) {
+            state.raise("Lone quantifier brackets");
+          }
+        }
+        if (state.maxBackReference > state.numCapturingParens) {
+          state.raise("Invalid escape");
+        }
+        for (var i2 = 0, list4 = state.backReferenceNames; i2 < list4.length; i2 += 1) {
+          var name3 = list4[i2];
+          if (state.groupNames.indexOf(name3) === -1) {
+            state.raise("Invalid named capture referenced");
+          }
+        }
+      };
+      pp$12.regexp_disjunction = function(state) {
+        this.regexp_alternative(state);
+        while (state.eat(124)) {
+          this.regexp_alternative(state);
+        }
+        if (this.regexp_eatQuantifier(state, true)) {
+          state.raise("Nothing to repeat");
+        }
+        if (state.eat(123)) {
+          state.raise("Lone quantifier brackets");
+        }
+      };
+      pp$12.regexp_alternative = function(state) {
+        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
+        }
+      };
+      pp$12.regexp_eatTerm = function(state) {
+        if (this.regexp_eatAssertion(state)) {
+          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
+            if (state.switchU) {
+              state.raise("Invalid quantifier");
+            }
+          }
+          return true;
+        }
+        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
+          this.regexp_eatQuantifier(state);
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatAssertion = function(state) {
+        var start3 = state.pos;
+        state.lastAssertionIsQuantifiable = false;
+        if (state.eat(94) || state.eat(36)) {
+          return true;
+        }
+        if (state.eat(92)) {
+          if (state.eat(66) || state.eat(98)) {
+            return true;
+          }
+          state.pos = start3;
+        }
+        if (state.eat(40) && state.eat(63)) {
+          var lookbehind = false;
+          if (this.options.ecmaVersion >= 9) {
+            lookbehind = state.eat(60);
+          }
+          if (state.eat(61) || state.eat(33)) {
+            this.regexp_disjunction(state);
+            if (!state.eat(41)) {
+              state.raise("Unterminated group");
+            }
+            state.lastAssertionIsQuantifiable = !lookbehind;
+            return true;
+          }
+        }
+        state.pos = start3;
+        return false;
+      };
+      pp$12.regexp_eatQuantifier = function(state, noError) {
+        if (noError === void 0)
+          noError = false;
+        if (this.regexp_eatQuantifierPrefix(state, noError)) {
+          state.eat(63);
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatQuantifierPrefix = function(state, noError) {
+        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
+      };
+      pp$12.regexp_eatBracedQuantifier = function(state, noError) {
+        var start3 = state.pos;
+        if (state.eat(123)) {
+          var min = 0, max = -1;
+          if (this.regexp_eatDecimalDigits(state)) {
+            min = state.lastIntValue;
+            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
+              max = state.lastIntValue;
+            }
+            if (state.eat(125)) {
+              if (max !== -1 && max < min && !noError) {
+                state.raise("numbers out of order in {} quantifier");
+              }
+              return true;
+            }
+          }
+          if (state.switchU && !noError) {
+            state.raise("Incomplete quantifier");
+          }
+          state.pos = start3;
+        }
+        return false;
+      };
+      pp$12.regexp_eatAtom = function(state) {
+        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
+      };
+      pp$12.regexp_eatReverseSolidusAtomEscape = function(state) {
+        var start3 = state.pos;
+        if (state.eat(92)) {
+          if (this.regexp_eatAtomEscape(state)) {
+            return true;
+          }
+          state.pos = start3;
+        }
+        return false;
+      };
+      pp$12.regexp_eatUncapturingGroup = function(state) {
+        var start3 = state.pos;
+        if (state.eat(40)) {
+          if (state.eat(63) && state.eat(58)) {
+            this.regexp_disjunction(state);
+            if (state.eat(41)) {
+              return true;
+            }
+            state.raise("Unterminated group");
+          }
+          state.pos = start3;
+        }
+        return false;
+      };
+      pp$12.regexp_eatCapturingGroup = function(state) {
+        if (state.eat(40)) {
+          if (this.options.ecmaVersion >= 9) {
+            this.regexp_groupSpecifier(state);
+          } else if (state.current() === 63) {
+            state.raise("Invalid group");
+          }
+          this.regexp_disjunction(state);
+          if (state.eat(41)) {
+            state.numCapturingParens += 1;
+            return true;
+          }
+          state.raise("Unterminated group");
+        }
+        return false;
+      };
+      pp$12.regexp_eatExtendedAtom = function(state) {
+        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
+      };
+      pp$12.regexp_eatInvalidBracedQuantifier = function(state) {
+        if (this.regexp_eatBracedQuantifier(state, true)) {
+          state.raise("Nothing to repeat");
+        }
+        return false;
+      };
+      pp$12.regexp_eatSyntaxCharacter = function(state) {
+        var ch = state.current();
+        if (isSyntaxCharacter2(ch)) {
+          state.lastIntValue = ch;
+          state.advance();
+          return true;
+        }
+        return false;
+      };
+      function isSyntaxCharacter2(ch) {
+        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
+      }
+      pp$12.regexp_eatPatternCharacters = function(state) {
+        var start3 = state.pos;
+        var ch = 0;
+        while ((ch = state.current()) !== -1 && !isSyntaxCharacter2(ch)) {
+          state.advance();
+        }
+        return state.pos !== start3;
+      };
+      pp$12.regexp_eatExtendedPatternCharacter = function(state) {
+        var ch = state.current();
+        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
+          state.advance();
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_groupSpecifier = function(state) {
+        if (state.eat(63)) {
+          if (this.regexp_eatGroupName(state)) {
+            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
+              state.raise("Duplicate capture group name");
+            }
+            state.groupNames.push(state.lastStringValue);
+            return;
+          }
+          state.raise("Invalid group");
+        }
+      };
+      pp$12.regexp_eatGroupName = function(state) {
+        state.lastStringValue = "";
+        if (state.eat(60)) {
+          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
+            return true;
+          }
+          state.raise("Invalid capture group name");
+        }
+        return false;
+      };
+      pp$12.regexp_eatRegExpIdentifierName = function(state) {
+        state.lastStringValue = "";
+        if (this.regexp_eatRegExpIdentifierStart(state)) {
+          state.lastStringValue += codePointToString$12(state.lastIntValue);
+          while (this.regexp_eatRegExpIdentifierPart(state)) {
+            state.lastStringValue += codePointToString$12(state.lastIntValue);
+          }
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatRegExpIdentifierStart = function(state) {
+        var start3 = state.pos;
+        var forceU = this.options.ecmaVersion >= 11;
+        var ch = state.current(forceU);
+        state.advance(forceU);
+        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
+          ch = state.lastIntValue;
+        }
+        if (isRegExpIdentifierStart2(ch)) {
+          state.lastIntValue = ch;
+          return true;
+        }
+        state.pos = start3;
+        return false;
+      };
+      function isRegExpIdentifierStart2(ch) {
+        return isIdentifierStart2(ch, true) || ch === 36 || ch === 95;
+      }
+      pp$12.regexp_eatRegExpIdentifierPart = function(state) {
+        var start3 = state.pos;
+        var forceU = this.options.ecmaVersion >= 11;
+        var ch = state.current(forceU);
+        state.advance(forceU);
+        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
+          ch = state.lastIntValue;
+        }
+        if (isRegExpIdentifierPart2(ch)) {
+          state.lastIntValue = ch;
+          return true;
+        }
+        state.pos = start3;
+        return false;
+      };
+      function isRegExpIdentifierPart2(ch) {
+        return isIdentifierChar2(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
+      }
+      pp$12.regexp_eatAtomEscape = function(state) {
+        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
+          return true;
+        }
+        if (state.switchU) {
+          if (state.current() === 99) {
+            state.raise("Invalid unicode escape");
+          }
+          state.raise("Invalid escape");
+        }
+        return false;
+      };
+      pp$12.regexp_eatBackReference = function(state) {
+        var start3 = state.pos;
+        if (this.regexp_eatDecimalEscape(state)) {
+          var n = state.lastIntValue;
+          if (state.switchU) {
+            if (n > state.maxBackReference) {
+              state.maxBackReference = n;
+            }
+            return true;
+          }
+          if (n <= state.numCapturingParens) {
+            return true;
+          }
+          state.pos = start3;
+        }
+        return false;
+      };
+      pp$12.regexp_eatKGroupName = function(state) {
+        if (state.eat(107)) {
+          if (this.regexp_eatGroupName(state)) {
+            state.backReferenceNames.push(state.lastStringValue);
+            return true;
+          }
+          state.raise("Invalid named reference");
+        }
+        return false;
+      };
+      pp$12.regexp_eatCharacterEscape = function(state) {
+        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
+      };
+      pp$12.regexp_eatCControlLetter = function(state) {
+        var start3 = state.pos;
+        if (state.eat(99)) {
+          if (this.regexp_eatControlLetter(state)) {
+            return true;
+          }
+          state.pos = start3;
+        }
+        return false;
+      };
+      pp$12.regexp_eatZero = function(state) {
+        if (state.current() === 48 && !isDecimalDigit2(state.lookahead())) {
+          state.lastIntValue = 0;
+          state.advance();
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatControlEscape = function(state) {
+        var ch = state.current();
+        if (ch === 116) {
+          state.lastIntValue = 9;
+          state.advance();
+          return true;
+        }
+        if (ch === 110) {
+          state.lastIntValue = 10;
+          state.advance();
+          return true;
+        }
+        if (ch === 118) {
+          state.lastIntValue = 11;
+          state.advance();
+          return true;
+        }
+        if (ch === 102) {
+          state.lastIntValue = 12;
+          state.advance();
+          return true;
+        }
+        if (ch === 114) {
+          state.lastIntValue = 13;
+          state.advance();
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatControlLetter = function(state) {
+        var ch = state.current();
+        if (isControlLetter2(ch)) {
+          state.lastIntValue = ch % 32;
+          state.advance();
+          return true;
+        }
+        return false;
+      };
+      function isControlLetter2(ch) {
+        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
+      }
+      pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
+        if (forceU === void 0)
+          forceU = false;
+        var start3 = state.pos;
+        var switchU = forceU || state.switchU;
+        if (state.eat(117)) {
+          if (this.regexp_eatFixedHexDigits(state, 4)) {
+            var lead = state.lastIntValue;
+            if (switchU && lead >= 55296 && lead <= 56319) {
+              var leadSurrogateEnd = state.pos;
+              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
+                var trail = state.lastIntValue;
+                if (trail >= 56320 && trail <= 57343) {
+                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
+                  return true;
+                }
+              }
+              state.pos = leadSurrogateEnd;
+              state.lastIntValue = lead;
+            }
+            return true;
+          }
+          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode2(state.lastIntValue)) {
+            return true;
+          }
+          if (switchU) {
+            state.raise("Invalid unicode escape");
+          }
+          state.pos = start3;
+        }
+        return false;
+      };
+      function isValidUnicode2(ch) {
+        return ch >= 0 && ch <= 1114111;
+      }
+      pp$12.regexp_eatIdentityEscape = function(state) {
+        if (state.switchU) {
+          if (this.regexp_eatSyntaxCharacter(state)) {
+            return true;
+          }
+          if (state.eat(47)) {
+            state.lastIntValue = 47;
+            return true;
+          }
+          return false;
+        }
+        var ch = state.current();
+        if (ch !== 99 && (!state.switchN || ch !== 107)) {
+          state.lastIntValue = ch;
+          state.advance();
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatDecimalEscape = function(state) {
+        state.lastIntValue = 0;
+        var ch = state.current();
+        if (ch >= 49 && ch <= 57) {
+          do {
+            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
+            state.advance();
+          } while ((ch = state.current()) >= 48 && ch <= 57);
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatCharacterClassEscape = function(state) {
+        var ch = state.current();
+        if (isCharacterClassEscape2(ch)) {
+          state.lastIntValue = -1;
+          state.advance();
+          return true;
+        }
+        if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
+          state.lastIntValue = -1;
+          state.advance();
+          if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
+            return true;
+          }
+          state.raise("Invalid property name");
+        }
+        return false;
+      };
+      function isCharacterClassEscape2(ch) {
+        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
+      }
+      pp$12.regexp_eatUnicodePropertyValueExpression = function(state) {
+        var start3 = state.pos;
+        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
+          var name3 = state.lastStringValue;
+          if (this.regexp_eatUnicodePropertyValue(state)) {
+            var value = state.lastStringValue;
+            this.regexp_validateUnicodePropertyNameAndValue(state, name3, value);
+            return true;
+          }
+        }
+        state.pos = start3;
+        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
+          var nameOrValue = state.lastStringValue;
+          this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_validateUnicodePropertyNameAndValue = function(state, name3, value) {
+        if (!hasOwn3(state.unicodeProperties.nonBinary, name3)) {
+          state.raise("Invalid property name");
+        }
+        if (!state.unicodeProperties.nonBinary[name3].test(value)) {
+          state.raise("Invalid property value");
+        }
+      };
+      pp$12.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
+        if (!state.unicodeProperties.binary.test(nameOrValue)) {
+          state.raise("Invalid property name");
+        }
+      };
+      pp$12.regexp_eatUnicodePropertyName = function(state) {
+        var ch = 0;
+        state.lastStringValue = "";
+        while (isUnicodePropertyNameCharacter2(ch = state.current())) {
+          state.lastStringValue += codePointToString$12(ch);
+          state.advance();
+        }
+        return state.lastStringValue !== "";
+      };
+      function isUnicodePropertyNameCharacter2(ch) {
+        return isControlLetter2(ch) || ch === 95;
+      }
+      pp$12.regexp_eatUnicodePropertyValue = function(state) {
+        var ch = 0;
+        state.lastStringValue = "";
+        while (isUnicodePropertyValueCharacter2(ch = state.current())) {
+          state.lastStringValue += codePointToString$12(ch);
+          state.advance();
+        }
+        return state.lastStringValue !== "";
+      };
+      function isUnicodePropertyValueCharacter2(ch) {
+        return isUnicodePropertyNameCharacter2(ch) || isDecimalDigit2(ch);
+      }
+      pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
+        return this.regexp_eatUnicodePropertyValue(state);
+      };
+      pp$12.regexp_eatCharacterClass = function(state) {
+        if (state.eat(91)) {
+          state.eat(94);
+          this.regexp_classRanges(state);
+          if (state.eat(93)) {
+            return true;
+          }
+          state.raise("Unterminated character class");
+        }
+        return false;
+      };
+      pp$12.regexp_classRanges = function(state) {
+        while (this.regexp_eatClassAtom(state)) {
+          var left = state.lastIntValue;
+          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
+            var right = state.lastIntValue;
+            if (state.switchU && (left === -1 || right === -1)) {
+              state.raise("Invalid character class");
+            }
+            if (left !== -1 && right !== -1 && left > right) {
+              state.raise("Range out of order in character class");
+            }
+          }
+        }
+      };
+      pp$12.regexp_eatClassAtom = function(state) {
+        var start3 = state.pos;
+        if (state.eat(92)) {
+          if (this.regexp_eatClassEscape(state)) {
+            return true;
+          }
+          if (state.switchU) {
+            var ch$1 = state.current();
+            if (ch$1 === 99 || isOctalDigit2(ch$1)) {
+              state.raise("Invalid class escape");
+            }
+            state.raise("Invalid escape");
+          }
+          state.pos = start3;
+        }
+        var ch = state.current();
+        if (ch !== 93) {
+          state.lastIntValue = ch;
+          state.advance();
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatClassEscape = function(state) {
+        var start3 = state.pos;
+        if (state.eat(98)) {
+          state.lastIntValue = 8;
+          return true;
+        }
+        if (state.switchU && state.eat(45)) {
+          state.lastIntValue = 45;
+          return true;
+        }
+        if (!state.switchU && state.eat(99)) {
+          if (this.regexp_eatClassControlLetter(state)) {
+            return true;
+          }
+          state.pos = start3;
+        }
+        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
+      };
+      pp$12.regexp_eatClassControlLetter = function(state) {
+        var ch = state.current();
+        if (isDecimalDigit2(ch) || ch === 95) {
+          state.lastIntValue = ch % 32;
+          state.advance();
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatHexEscapeSequence = function(state) {
+        var start3 = state.pos;
+        if (state.eat(120)) {
+          if (this.regexp_eatFixedHexDigits(state, 2)) {
+            return true;
+          }
+          if (state.switchU) {
+            state.raise("Invalid escape");
+          }
+          state.pos = start3;
+        }
+        return false;
+      };
+      pp$12.regexp_eatDecimalDigits = function(state) {
+        var start3 = state.pos;
+        var ch = 0;
+        state.lastIntValue = 0;
+        while (isDecimalDigit2(ch = state.current())) {
+          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
+          state.advance();
+        }
+        return state.pos !== start3;
+      };
+      function isDecimalDigit2(ch) {
+        return ch >= 48 && ch <= 57;
+      }
+      pp$12.regexp_eatHexDigits = function(state) {
+        var start3 = state.pos;
+        var ch = 0;
+        state.lastIntValue = 0;
+        while (isHexDigit2(ch = state.current())) {
+          state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
+          state.advance();
+        }
+        return state.pos !== start3;
+      };
+      function isHexDigit2(ch) {
+        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
+      }
+      function hexToInt2(ch) {
+        if (ch >= 65 && ch <= 70) {
+          return 10 + (ch - 65);
+        }
+        if (ch >= 97 && ch <= 102) {
+          return 10 + (ch - 97);
+        }
+        return ch - 48;
+      }
+      pp$12.regexp_eatLegacyOctalEscapeSequence = function(state) {
+        if (this.regexp_eatOctalDigit(state)) {
+          var n1 = state.lastIntValue;
+          if (this.regexp_eatOctalDigit(state)) {
+            var n2 = state.lastIntValue;
+            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
+              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
+            } else {
+              state.lastIntValue = n1 * 8 + n2;
+            }
+          } else {
+            state.lastIntValue = n1;
+          }
+          return true;
+        }
+        return false;
+      };
+      pp$12.regexp_eatOctalDigit = function(state) {
+        var ch = state.current();
+        if (isOctalDigit2(ch)) {
+          state.lastIntValue = ch - 48;
+          state.advance();
+          return true;
+        }
+        state.lastIntValue = 0;
+        return false;
+      };
+      function isOctalDigit2(ch) {
+        return ch >= 48 && ch <= 55;
+      }
+      pp$12.regexp_eatFixedHexDigits = function(state, length) {
+        var start3 = state.pos;
+        state.lastIntValue = 0;
+        for (var i2 = 0; i2 < length; ++i2) {
+          var ch = state.current();
+          if (!isHexDigit2(ch)) {
+            state.pos = start3;
+            return false;
+          }
+          state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
+          state.advance();
+        }
+        return true;
+      };
+      var Token3 = function Token4(p) {
+        this.type = p.type;
+        this.value = p.value;
+        this.start = p.start;
+        this.end = p.end;
+        if (p.options.locations) {
+          this.loc = new SourceLocation3(p, p.startLoc, p.endLoc);
+        }
+        if (p.options.ranges) {
+          this.range = [p.start, p.end];
+        }
+      };
+      var pp2 = Parser4.prototype;
+      pp2.next = function(ignoreEscapeSequenceInKeyword) {
+        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
+          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
+        }
+        if (this.options.onToken) {
+          this.options.onToken(new Token3(this));
+        }
+        this.lastTokEnd = this.end;
+        this.lastTokStart = this.start;
+        this.lastTokEndLoc = this.endLoc;
+        this.lastTokStartLoc = this.startLoc;
+        this.nextToken();
+      };
+      pp2.getToken = function() {
+        this.next();
+        return new Token3(this);
+      };
+      if (typeof Symbol !== "undefined") {
+        pp2[Symbol.iterator] = function() {
+          var this$1$1 = this;
+          return {
+            next: function() {
+              var token = this$1$1.getToken();
+              return {
+                done: token.type === types$12.eof,
+                value: token
+              };
+            }
+          };
+        };
+      }
+      pp2.nextToken = function() {
+        var curContext = this.curContext();
+        if (!curContext || !curContext.preserveSpace) {
+          this.skipSpace();
+        }
+        this.start = this.pos;
+        if (this.options.locations) {
+          this.startLoc = this.curPosition();
+        }
+        if (this.pos >= this.input.length) {
+          return this.finishToken(types$12.eof);
+        }
+        if (curContext.override) {
+          return curContext.override(this);
+        } else {
+          this.readToken(this.fullCharCodeAtPos());
+        }
+      };
+      pp2.readToken = function(code3) {
+        if (isIdentifierStart2(code3, this.options.ecmaVersion >= 6) || code3 === 92) {
+          return this.readWord();
+        }
+        return this.getTokenFromCode(code3);
+      };
+      pp2.fullCharCodeAtPos = function() {
+        var code3 = this.input.charCodeAt(this.pos);
+        if (code3 <= 55295 || code3 >= 56320) {
+          return code3;
+        }
+        var next = this.input.charCodeAt(this.pos + 1);
+        return next <= 56319 || next >= 57344 ? code3 : (code3 << 10) + next - 56613888;
+      };
+      pp2.skipBlockComment = function() {
+        var startLoc = this.options.onComment && this.curPosition();
+        var start3 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
+        if (end === -1) {
+          this.raise(this.pos - 2, "Unterminated comment");
+        }
+        this.pos = end + 2;
+        if (this.options.locations) {
+          for (var nextBreak = void 0, pos = start3; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
+            ++this.curLine;
+            pos = this.lineStart = nextBreak;
+          }
+        }
+        if (this.options.onComment) {
+          this.options.onComment(true, this.input.slice(start3 + 2, end), start3, this.pos, startLoc, this.curPosition());
+        }
+      };
+      pp2.skipLineComment = function(startSkip) {
+        var start3 = this.pos;
+        var startLoc = this.options.onComment && this.curPosition();
+        var ch = this.input.charCodeAt(this.pos += startSkip);
+        while (this.pos < this.input.length && !isNewLine2(ch)) {
+          ch = this.input.charCodeAt(++this.pos);
+        }
+        if (this.options.onComment) {
+          this.options.onComment(false, this.input.slice(start3 + startSkip, this.pos), start3, this.pos, startLoc, this.curPosition());
+        }
+      };
+      pp2.skipSpace = function() {
+        loop:
+          while (this.pos < this.input.length) {
+            var ch = this.input.charCodeAt(this.pos);
+            switch (ch) {
+              case 32:
+              case 160:
+                ++this.pos;
+                break;
+              case 13:
+                if (this.input.charCodeAt(this.pos + 1) === 10) {
+                  ++this.pos;
+                }
+              case 10:
+              case 8232:
+              case 8233:
+                ++this.pos;
+                if (this.options.locations) {
+                  ++this.curLine;
+                  this.lineStart = this.pos;
+                }
+                break;
+              case 47:
+                switch (this.input.charCodeAt(this.pos + 1)) {
+                  case 42:
+                    this.skipBlockComment();
+                    break;
+                  case 47:
+                    this.skipLineComment(2);
+                    break;
+                  default:
+                    break loop;
+                }
+                break;
+              default:
+                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch))) {
+                  ++this.pos;
+                } else {
+                  break loop;
+                }
+            }
+          }
+      };
+      pp2.finishToken = function(type2, val) {
+        this.end = this.pos;
+        if (this.options.locations) {
+          this.endLoc = this.curPosition();
+        }
+        var prevType = this.type;
+        this.type = type2;
+        this.value = val;
+        this.updateContext(prevType);
+      };
+      pp2.readToken_dot = function() {
+        var next = this.input.charCodeAt(this.pos + 1);
+        if (next >= 48 && next <= 57) {
+          return this.readNumber(true);
+        }
+        var next2 = this.input.charCodeAt(this.pos + 2);
+        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
+          this.pos += 3;
+          return this.finishToken(types$12.ellipsis);
+        } else {
+          ++this.pos;
+          return this.finishToken(types$12.dot);
+        }
+      };
+      pp2.readToken_slash = function() {
+        var next = this.input.charCodeAt(this.pos + 1);
+        if (this.exprAllowed) {
+          ++this.pos;
+          return this.readRegexp();
+        }
+        if (next === 61) {
+          return this.finishOp(types$12.assign, 2);
+        }
+        return this.finishOp(types$12.slash, 1);
+      };
+      pp2.readToken_mult_modulo_exp = function(code3) {
+        var next = this.input.charCodeAt(this.pos + 1);
+        var size = 1;
+        var tokentype = code3 === 42 ? types$12.star : types$12.modulo;
+        if (this.options.ecmaVersion >= 7 && code3 === 42 && next === 42) {
+          ++size;
+          tokentype = types$12.starstar;
+          next = this.input.charCodeAt(this.pos + 2);
+        }
+        if (next === 61) {
+          return this.finishOp(types$12.assign, size + 1);
+        }
+        return this.finishOp(tokentype, size);
+      };
+      pp2.readToken_pipe_amp = function(code3) {
+        var next = this.input.charCodeAt(this.pos + 1);
+        if (next === code3) {
+          if (this.options.ecmaVersion >= 12) {
+            var next2 = this.input.charCodeAt(this.pos + 2);
+            if (next2 === 61) {
+              return this.finishOp(types$12.assign, 3);
+            }
+          }
+          return this.finishOp(code3 === 124 ? types$12.logicalOR : types$12.logicalAND, 2);
+        }
+        if (next === 61) {
+          return this.finishOp(types$12.assign, 2);
+        }
+        return this.finishOp(code3 === 124 ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
+      };
+      pp2.readToken_caret = function() {
+        var next = this.input.charCodeAt(this.pos + 1);
+        if (next === 61) {
+          return this.finishOp(types$12.assign, 2);
+        }
+        return this.finishOp(types$12.bitwiseXOR, 1);
+      };
+      pp2.readToken_plus_min = function(code3) {
+        var next = this.input.charCodeAt(this.pos + 1);
+        if (next === code3) {
+          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
+            this.skipLineComment(3);
+            this.skipSpace();
+            return this.nextToken();
+          }
+          return this.finishOp(types$12.incDec, 2);
+        }
+        if (next === 61) {
+          return this.finishOp(types$12.assign, 2);
+        }
+        return this.finishOp(types$12.plusMin, 1);
+      };
+      pp2.readToken_lt_gt = function(code3) {
+        var next = this.input.charCodeAt(this.pos + 1);
+        var size = 1;
+        if (next === code3) {
+          size = code3 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
+          if (this.input.charCodeAt(this.pos + size) === 61) {
+            return this.finishOp(types$12.assign, size + 1);
+          }
+          return this.finishOp(types$12.bitShift, size);
+        }
+        if (next === 33 && code3 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
+          this.skipLineComment(4);
+          this.skipSpace();
+          return this.nextToken();
+        }
+        if (next === 61) {
+          size = 2;
+        }
+        return this.finishOp(types$12.relational, size);
+      };
+      pp2.readToken_eq_excl = function(code3) {
+        var next = this.input.charCodeAt(this.pos + 1);
+        if (next === 61) {
+          return this.finishOp(types$12.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
+        }
+        if (code3 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
+          this.pos += 2;
+          return this.finishToken(types$12.arrow);
+        }
+        return this.finishOp(code3 === 61 ? types$12.eq : types$12.prefix, 1);
+      };
+      pp2.readToken_question = function() {
+        var ecmaVersion2 = this.options.ecmaVersion;
+        if (ecmaVersion2 >= 11) {
+          var next = this.input.charCodeAt(this.pos + 1);
+          if (next === 46) {
+            var next2 = this.input.charCodeAt(this.pos + 2);
+            if (next2 < 48 || next2 > 57) {
+              return this.finishOp(types$12.questionDot, 2);
+            }
+          }
+          if (next === 63) {
+            if (ecmaVersion2 >= 12) {
+              var next2$1 = this.input.charCodeAt(this.pos + 2);
+              if (next2$1 === 61) {
+                return this.finishOp(types$12.assign, 3);
+              }
+            }
+            return this.finishOp(types$12.coalesce, 2);
+          }
+        }
+        return this.finishOp(types$12.question, 1);
+      };
+      pp2.readToken_numberSign = function() {
+        var ecmaVersion2 = this.options.ecmaVersion;
+        var code3 = 35;
+        if (ecmaVersion2 >= 13) {
+          ++this.pos;
+          code3 = this.fullCharCodeAtPos();
+          if (isIdentifierStart2(code3, true) || code3 === 92) {
+            return this.finishToken(types$12.privateId, this.readWord1());
+          }
+        }
+        this.raise(this.pos, "Unexpected character '" + codePointToString2(code3) + "'");
+      };
+      pp2.getTokenFromCode = function(code3) {
+        switch (code3) {
+          case 46:
+            return this.readToken_dot();
+          case 40:
+            ++this.pos;
+            return this.finishToken(types$12.parenL);
+          case 41:
+            ++this.pos;
+            return this.finishToken(types$12.parenR);
+          case 59:
+            ++this.pos;
+            return this.finishToken(types$12.semi);
+          case 44:
+            ++this.pos;
+            return this.finishToken(types$12.comma);
+          case 91:
+            ++this.pos;
+            return this.finishToken(types$12.bracketL);
+          case 93:
+            ++this.pos;
+            return this.finishToken(types$12.bracketR);
+          case 123:
+            ++this.pos;
+            return this.finishToken(types$12.braceL);
+          case 125:
+            ++this.pos;
+            return this.finishToken(types$12.braceR);
+          case 58:
+            ++this.pos;
+            return this.finishToken(types$12.colon);
+          case 96:
+            if (this.options.ecmaVersion < 6) {
+              break;
+            }
+            ++this.pos;
+            return this.finishToken(types$12.backQuote);
+          case 48:
+            var next = this.input.charCodeAt(this.pos + 1);
+            if (next === 120 || next === 88) {
+              return this.readRadixNumber(16);
+            }
+            if (this.options.ecmaVersion >= 6) {
+              if (next === 111 || next === 79) {
+                return this.readRadixNumber(8);
+              }
+              if (next === 98 || next === 66) {
+                return this.readRadixNumber(2);
+              }
+            }
+          case 49:
+          case 50:
+          case 51:
+          case 52:
+          case 53:
+          case 54:
+          case 55:
+          case 56:
+          case 57:
+            return this.readNumber(false);
+          case 34:
+          case 39:
+            return this.readString(code3);
+          case 47:
+            return this.readToken_slash();
+          case 37:
+          case 42:
+            return this.readToken_mult_modulo_exp(code3);
+          case 124:
+          case 38:
+            return this.readToken_pipe_amp(code3);
+          case 94:
+            return this.readToken_caret();
+          case 43:
+          case 45:
+            return this.readToken_plus_min(code3);
+          case 60:
+          case 62:
+            return this.readToken_lt_gt(code3);
+          case 61:
+          case 33:
+            return this.readToken_eq_excl(code3);
+          case 63:
+            return this.readToken_question();
+          case 126:
+            return this.finishOp(types$12.prefix, 1);
+          case 35:
+            return this.readToken_numberSign();
+        }
+        this.raise(this.pos, "Unexpected character '" + codePointToString2(code3) + "'");
+      };
+      pp2.finishOp = function(type2, size) {
+        var str = this.input.slice(this.pos, this.pos + size);
+        this.pos += size;
+        return this.finishToken(type2, str);
+      };
+      pp2.readRegexp = function() {
+        var escaped, inClass, start3 = this.pos;
+        for (; ; ) {
+          if (this.pos >= this.input.length) {
+            this.raise(start3, "Unterminated regular expression");
+          }
+          var ch = this.input.charAt(this.pos);
+          if (lineBreak2.test(ch)) {
+            this.raise(start3, "Unterminated regular expression");
+          }
+          if (!escaped) {
+            if (ch === "[") {
+              inClass = true;
+            } else if (ch === "]" && inClass) {
+              inClass = false;
+            } else if (ch === "/" && !inClass) {
+              break;
+            }
+            escaped = ch === "\\";
+          } else {
+            escaped = false;
+          }
+          ++this.pos;
+        }
+        var pattern = this.input.slice(start3, this.pos);
+        ++this.pos;
+        var flagsStart = this.pos;
+        var flags = this.readWord1();
+        if (this.containsEsc) {
+          this.unexpected(flagsStart);
+        }
+        var state = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
+        state.reset(start3, pattern, flags);
+        this.validateRegExpFlags(state);
+        this.validateRegExpPattern(state);
+        var value = null;
+        try {
+          value = new RegExp(pattern, flags);
+        } catch (e) {
+        }
+        return this.finishToken(types$12.regexp, { pattern, flags, value });
+      };
+      pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
+        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
+        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
+        var start3 = this.pos, total = 0, lastCode = 0;
+        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
+          var code3 = this.input.charCodeAt(this.pos), val = void 0;
+          if (allowSeparators && code3 === 95) {
+            if (isLegacyOctalNumericLiteral) {
+              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
+            }
+            if (lastCode === 95) {
+              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
+            }
+            if (i2 === 0) {
+              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
+            }
+            lastCode = code3;
+            continue;
+          }
+          if (code3 >= 97) {
+            val = code3 - 97 + 10;
+          } else if (code3 >= 65) {
+            val = code3 - 65 + 10;
+          } else if (code3 >= 48 && code3 <= 57) {
+            val = code3 - 48;
+          } else {
+            val = Infinity;
+          }
+          if (val >= radix) {
+            break;
+          }
+          lastCode = code3;
+          total = total * radix + val;
+        }
+        if (allowSeparators && lastCode === 95) {
+          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
+        }
+        if (this.pos === start3 || len != null && this.pos - start3 !== len) {
+          return null;
+        }
+        return total;
+      };
+      function stringToNumber2(str, isLegacyOctalNumericLiteral) {
+        if (isLegacyOctalNumericLiteral) {
+          return parseInt(str, 8);
+        }
+        return parseFloat(str.replace(/_/g, ""));
+      }
+      function stringToBigInt2(str) {
+        if (typeof BigInt !== "function") {
+          return null;
+        }
+        return BigInt(str.replace(/_/g, ""));
+      }
+      pp2.readRadixNumber = function(radix) {
+        var start3 = this.pos;
+        this.pos += 2;
+        var val = this.readInt(radix);
+        if (val == null) {
+          this.raise(this.start + 2, "Expected number in radix " + radix);
+        }
+        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
+          val = stringToBigInt2(this.input.slice(start3, this.pos));
+          ++this.pos;
+        } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
+          this.raise(this.pos, "Identifier directly after number");
+        }
+        return this.finishToken(types$12.num, val);
+      };
+      pp2.readNumber = function(startsWithDot) {
+        var start3 = this.pos;
+        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
+          this.raise(start3, "Invalid number");
+        }
+        var octal = this.pos - start3 >= 2 && this.input.charCodeAt(start3) === 48;
+        if (octal && this.strict) {
+          this.raise(start3, "Invalid number");
+        }
+        var next = this.input.charCodeAt(this.pos);
+        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
+          var val$1 = stringToBigInt2(this.input.slice(start3, this.pos));
+          ++this.pos;
+          if (isIdentifierStart2(this.fullCharCodeAtPos())) {
+            this.raise(this.pos, "Identifier directly after number");
+          }
+          return this.finishToken(types$12.num, val$1);
+        }
+        if (octal && /[89]/.test(this.input.slice(start3, this.pos))) {
+          octal = false;
+        }
+        if (next === 46 && !octal) {
+          ++this.pos;
+          this.readInt(10);
+          next = this.input.charCodeAt(this.pos);
+        }
+        if ((next === 69 || next === 101) && !octal) {
+          next = this.input.charCodeAt(++this.pos);
+          if (next === 43 || next === 45) {
+            ++this.pos;
+          }
+          if (this.readInt(10) === null) {
+            this.raise(start3, "Invalid number");
+          }
+        }
+        if (isIdentifierStart2(this.fullCharCodeAtPos())) {
+          this.raise(this.pos, "Identifier directly after number");
+        }
+        var val = stringToNumber2(this.input.slice(start3, this.pos), octal);
+        return this.finishToken(types$12.num, val);
+      };
+      pp2.readCodePoint = function() {
+        var ch = this.input.charCodeAt(this.pos), code3;
+        if (ch === 123) {
+          if (this.options.ecmaVersion < 6) {
+            this.unexpected();
+          }
+          var codePos = ++this.pos;
+          code3 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
+          ++this.pos;
+          if (code3 > 1114111) {
+            this.invalidStringToken(codePos, "Code point out of bounds");
+          }
+        } else {
+          code3 = this.readHexChar(4);
+        }
+        return code3;
+      };
+      function codePointToString2(code3) {
+        if (code3 <= 65535) {
+          return String.fromCharCode(code3);
+        }
+        code3 -= 65536;
+        return String.fromCharCode((code3 >> 10) + 55296, (code3 & 1023) + 56320);
+      }
+      pp2.readString = function(quote) {
+        var out = "", chunkStart = ++this.pos;
+        for (; ; ) {
+          if (this.pos >= this.input.length) {
+            this.raise(this.start, "Unterminated string constant");
+          }
+          var ch = this.input.charCodeAt(this.pos);
+          if (ch === quote) {
+            break;
+          }
+          if (ch === 92) {
+            out += this.input.slice(chunkStart, this.pos);
+            out += this.readEscapedChar(false);
+            chunkStart = this.pos;
+          } else if (ch === 8232 || ch === 8233) {
+            if (this.options.ecmaVersion < 10) {
+              this.raise(this.start, "Unterminated string constant");
+            }
+            ++this.pos;
+            if (this.options.locations) {
+              this.curLine++;
+              this.lineStart = this.pos;
+            }
+          } else {
+            if (isNewLine2(ch)) {
+              this.raise(this.start, "Unterminated string constant");
+            }
+            ++this.pos;
+          }
+        }
+        out += this.input.slice(chunkStart, this.pos++);
+        return this.finishToken(types$12.string, out);
+      };
+      var INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
+      pp2.tryReadTemplateToken = function() {
+        this.inTemplateElement = true;
+        try {
+          this.readTmplToken();
+        } catch (err) {
+          if (err === INVALID_TEMPLATE_ESCAPE_ERROR2) {
+            this.readInvalidTemplateToken();
+          } else {
+            throw err;
+          }
+        }
+        this.inTemplateElement = false;
+      };
+      pp2.invalidStringToken = function(position4, message) {
+        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
+          throw INVALID_TEMPLATE_ESCAPE_ERROR2;
+        } else {
+          this.raise(position4, message);
+        }
+      };
+      pp2.readTmplToken = function() {
+        var out = "", chunkStart = this.pos;
+        for (; ; ) {
+          if (this.pos >= this.input.length) {
+            this.raise(this.start, "Unterminated template");
+          }
+          var ch = this.input.charCodeAt(this.pos);
+          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
+            if (this.pos === this.start && (this.type === types$12.template || this.type === types$12.invalidTemplate)) {
+              if (ch === 36) {
+                this.pos += 2;
+                return this.finishToken(types$12.dollarBraceL);
+              } else {
+                ++this.pos;
+                return this.finishToken(types$12.backQuote);
+              }
+            }
+            out += this.input.slice(chunkStart, this.pos);
+            return this.finishToken(types$12.template, out);
+          }
+          if (ch === 92) {
+            out += this.input.slice(chunkStart, this.pos);
+            out += this.readEscapedChar(true);
+            chunkStart = this.pos;
+          } else if (isNewLine2(ch)) {
+            out += this.input.slice(chunkStart, this.pos);
+            ++this.pos;
+            switch (ch) {
+              case 13:
+                if (this.input.charCodeAt(this.pos) === 10) {
+                  ++this.pos;
+                }
+              case 10:
+                out += "\n";
+                break;
+              default:
+                out += String.fromCharCode(ch);
+                break;
+            }
+            if (this.options.locations) {
+              ++this.curLine;
+              this.lineStart = this.pos;
+            }
+            chunkStart = this.pos;
+          } else {
+            ++this.pos;
+          }
+        }
+      };
+      pp2.readInvalidTemplateToken = function() {
+        for (; this.pos < this.input.length; this.pos++) {
+          switch (this.input[this.pos]) {
+            case "\\":
+              ++this.pos;
+              break;
+            case "$":
+              if (this.input[this.pos + 1] !== "{") {
+                break;
+              }
+            case "`":
+              return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
+          }
+        }
+        this.raise(this.start, "Unterminated template");
+      };
+      pp2.readEscapedChar = function(inTemplate) {
+        var ch = this.input.charCodeAt(++this.pos);
+        ++this.pos;
+        switch (ch) {
+          case 110:
+            return "\n";
+          case 114:
+            return "\r";
+          case 120:
+            return String.fromCharCode(this.readHexChar(2));
+          case 117:
+            return codePointToString2(this.readCodePoint());
+          case 116:
+            return "	";
+          case 98:
+            return "\b";
+          case 118:
+            return "\v";
+          case 102:
+            return "\f";
+          case 13:
+            if (this.input.charCodeAt(this.pos) === 10) {
+              ++this.pos;
+            }
+          case 10:
+            if (this.options.locations) {
+              this.lineStart = this.pos;
+              ++this.curLine;
+            }
+            return "";
+          case 56:
+          case 57:
+            if (this.strict) {
+              this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
+            }
+            if (inTemplate) {
+              var codePos = this.pos - 1;
+              this.invalidStringToken(codePos, "Invalid escape sequence in template string");
+              return null;
+            }
+          default:
+            if (ch >= 48 && ch <= 55) {
+              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
+              var octal = parseInt(octalStr, 8);
+              if (octal > 255) {
+                octalStr = octalStr.slice(0, -1);
+                octal = parseInt(octalStr, 8);
+              }
+              this.pos += octalStr.length - 1;
+              ch = this.input.charCodeAt(this.pos);
+              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
+                this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
+              }
+              return String.fromCharCode(octal);
+            }
+            if (isNewLine2(ch)) {
+              return "";
+            }
+            return String.fromCharCode(ch);
+        }
+      };
+      pp2.readHexChar = function(len) {
+        var codePos = this.pos;
+        var n = this.readInt(16, len);
+        if (n === null) {
+          this.invalidStringToken(codePos, "Bad character escape sequence");
+        }
+        return n;
+      };
+      pp2.readWord1 = function() {
+        this.containsEsc = false;
+        var word = "", first = true, chunkStart = this.pos;
+        var astral = this.options.ecmaVersion >= 6;
+        while (this.pos < this.input.length) {
+          var ch = this.fullCharCodeAtPos();
+          if (isIdentifierChar2(ch, astral)) {
+            this.pos += ch <= 65535 ? 1 : 2;
+          } else if (ch === 92) {
+            this.containsEsc = true;
+            word += this.input.slice(chunkStart, this.pos);
+            var escStart = this.pos;
+            if (this.input.charCodeAt(++this.pos) !== 117) {
+              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
+            }
+            ++this.pos;
+            var esc = this.readCodePoint();
+            if (!(first ? isIdentifierStart2 : isIdentifierChar2)(esc, astral)) {
+              this.invalidStringToken(escStart, "Invalid Unicode escape");
+            }
+            word += codePointToString2(esc);
+            chunkStart = this.pos;
+          } else {
+            break;
+          }
+          first = false;
+        }
+        return word + this.input.slice(chunkStart, this.pos);
+      };
+      pp2.readWord = function() {
+        var word = this.readWord1();
+        var type2 = types$12.name;
+        if (this.keywords.test(word)) {
+          type2 = keywords2[word];
+        }
+        return this.finishToken(type2, word);
+      };
+      var version2 = "8.7.0";
+      Parser4.acorn = {
+        Parser: Parser4,
+        version: version2,
+        defaultOptions: defaultOptions2,
+        Position: Position3,
+        SourceLocation: SourceLocation3,
+        getLineInfo: getLineInfo2,
+        Node: Node3,
+        TokenType: TokenType3,
+        tokTypes: types$12,
+        keywordTypes: keywords2,
+        TokContext: TokContext3,
+        tokContexts: types3,
+        isIdentifierChar: isIdentifierChar2,
+        isIdentifierStart: isIdentifierStart2,
+        Token: Token3,
+        isNewLine: isNewLine2,
+        lineBreak: lineBreak2,
+        lineBreakG: lineBreakG2,
+        nonASCIIwhitespace: nonASCIIwhitespace2
+      };
+      function parse5(input, options) {
+        return Parser4.parse(input, options);
+      }
+      function parseExpressionAt2(input, pos, options) {
+        return Parser4.parseExpressionAt(input, pos, options);
+      }
+      function tokenizer3(input, options) {
+        return Parser4.tokenizer(input, options);
+      }
+      exports2.Node = Node3;
+      exports2.Parser = Parser4;
+      exports2.Position = Position3;
+      exports2.SourceLocation = SourceLocation3;
+      exports2.TokContext = TokContext3;
+      exports2.Token = Token3;
+      exports2.TokenType = TokenType3;
+      exports2.defaultOptions = defaultOptions2;
+      exports2.getLineInfo = getLineInfo2;
+      exports2.isIdentifierChar = isIdentifierChar2;
+      exports2.isIdentifierStart = isIdentifierStart2;
+      exports2.isNewLine = isNewLine2;
+      exports2.keywordTypes = keywords2;
+      exports2.lineBreak = lineBreak2;
+      exports2.lineBreakG = lineBreakG2;
+      exports2.nonASCIIwhitespace = nonASCIIwhitespace2;
+      exports2.parse = parse5;
+      exports2.parseExpressionAt = parseExpressionAt2;
+      exports2.tokContexts = types3;
+      exports2.tokTypes = types$12;
+      exports2.tokenizer = tokenizer3;
+      exports2.version = version2;
+      Object.defineProperty(exports2, "__esModule", { value: true });
+    });
+  }
+});
+
+// ../../node_modules/.pnpm/acorn-jsx@5.3.2_acorn@8.7.0/node_modules/acorn-jsx/index.js
+var require_acorn_jsx = __commonJS({
+  "../../node_modules/.pnpm/acorn-jsx@5.3.2_acorn@8.7.0/node_modules/acorn-jsx/index.js"(exports, module) {
+    "use strict";
+    var XHTMLEntities = require_xhtml();
+    var hexNumber = /^[\da-fA-F]+$/;
+    var decimalNumber = /^\d+$/;
+    var acornJsxMap = /* @__PURE__ */ new WeakMap();
+    function getJsxTokens(acorn) {
+      acorn = acorn.Parser.acorn || acorn;
+      let acornJsx2 = acornJsxMap.get(acorn);
+      if (!acornJsx2) {
+        const tt = acorn.tokTypes;
+        const TokContext3 = acorn.TokContext;
+        const TokenType3 = acorn.TokenType;
+        const tc_oTag = new TokContext3("<tag", false);
+        const tc_cTag = new TokContext3("</tag", false);
+        const tc_expr = new TokContext3("<tag>...</tag>", true, true);
+        const tokContexts = {
+          tc_oTag,
+          tc_cTag,
+          tc_expr
+        };
+        const tokTypes = {
+          jsxName: new TokenType3("jsxName"),
+          jsxText: new TokenType3("jsxText", { beforeExpr: true }),
+          jsxTagStart: new TokenType3("jsxTagStart", { startsExpr: true }),
+          jsxTagEnd: new TokenType3("jsxTagEnd")
+        };
+        tokTypes.jsxTagStart.updateContext = function() {
+          this.context.push(tc_expr);
+          this.context.push(tc_oTag);
+          this.exprAllowed = false;
+        };
+        tokTypes.jsxTagEnd.updateContext = function(prevType) {
+          let out = this.context.pop();
+          if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
+            this.context.pop();
+            this.exprAllowed = this.curContext() === tc_expr;
+          } else {
+            this.exprAllowed = true;
+          }
+        };
+        acornJsx2 = { tokContexts, tokTypes };
+        acornJsxMap.set(acorn, acornJsx2);
+      }
+      return acornJsx2;
+    }
+    function getQualifiedJSXName(object) {
+      if (!object)
+        return object;
+      if (object.type === "JSXIdentifier")
+        return object.name;
+      if (object.type === "JSXNamespacedName")
+        return object.namespace.name + ":" + object.name.name;
+      if (object.type === "JSXMemberExpression")
+        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
+    }
+    module.exports = function(options) {
+      options = options || {};
+      return function(Parser4) {
+        return plugin({
+          allowNamespaces: options.allowNamespaces !== false,
+          allowNamespacedObjects: !!options.allowNamespacedObjects
+        }, Parser4);
+      };
+    };
+    Object.defineProperty(module.exports, "tokTypes", {
+      get: function get_tokTypes() {
+        return getJsxTokens(require_acorn()).tokTypes;
+      },
+      configurable: true,
+      enumerable: true
+    });
+    function plugin(options, Parser4) {
+      const acorn = Parser4.acorn || require_acorn();
+      const acornJsx2 = getJsxTokens(acorn);
+      const tt = acorn.tokTypes;
+      const tok = acornJsx2.tokTypes;
+      const tokContexts = acorn.tokContexts;
+      const tc_oTag = acornJsx2.tokContexts.tc_oTag;
+      const tc_cTag = acornJsx2.tokContexts.tc_cTag;
+      const tc_expr = acornJsx2.tokContexts.tc_expr;
+      const isNewLine2 = acorn.isNewLine;
+      const isIdentifierStart2 = acorn.isIdentifierStart;
+      const isIdentifierChar2 = acorn.isIdentifierChar;
+      return class extends Parser4 {
+        static get acornJsx() {
+          return acornJsx2;
+        }
+        jsx_readToken() {
+          let out = "", chunkStart = this.pos;
+          for (; ; ) {
+            if (this.pos >= this.input.length)
+              this.raise(this.start, "Unterminated JSX contents");
+            let ch = this.input.charCodeAt(this.pos);
+            switch (ch) {
+              case 60:
+              case 123:
+                if (this.pos === this.start) {
+                  if (ch === 60 && this.exprAllowed) {
+                    ++this.pos;
+                    return this.finishToken(tok.jsxTagStart);
+                  }
+                  return this.getTokenFromCode(ch);
+                }
+                out += this.input.slice(chunkStart, this.pos);
+                return this.finishToken(tok.jsxText, out);
+              case 38:
+                out += this.input.slice(chunkStart, this.pos);
+                out += this.jsx_readEntity();
+                chunkStart = this.pos;
+                break;
+              case 62:
+              case 125:
+                this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?');
+              default:
+                if (isNewLine2(ch)) {
+                  out += this.input.slice(chunkStart, this.pos);
+                  out += this.jsx_readNewLine(true);
+                  chunkStart = this.pos;
+                } else {
+                  ++this.pos;
+                }
+            }
+          }
+        }
+        jsx_readNewLine(normalizeCRLF) {
+          let ch = this.input.charCodeAt(this.pos);
+          let out;
+          ++this.pos;
+          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
+            ++this.pos;
+            out = normalizeCRLF ? "\n" : "\r\n";
+          } else {
+            out = String.fromCharCode(ch);
+          }
+          if (this.options.locations) {
+            ++this.curLine;
+            this.lineStart = this.pos;
+          }
+          return out;
+        }
+        jsx_readString(quote) {
+          let out = "", chunkStart = ++this.pos;
+          for (; ; ) {
+            if (this.pos >= this.input.length)
+              this.raise(this.start, "Unterminated string constant");
+            let ch = this.input.charCodeAt(this.pos);
+            if (ch === quote)
+              break;
+            if (ch === 38) {
+              out += this.input.slice(chunkStart, this.pos);
+              out += this.jsx_readEntity();
+              chunkStart = this.pos;
+            } else if (isNewLine2(ch)) {
+              out += this.input.slice(chunkStart, this.pos);
+              out += this.jsx_readNewLine(false);
+              chunkStart = this.pos;
+            } else {
+              ++this.pos;
+            }
+          }
+          out += this.input.slice(chunkStart, this.pos++);
+          return this.finishToken(tt.string, out);
+        }
+        jsx_readEntity() {
+          let str = "", count = 0, entity;
+          let ch = this.input[this.pos];
+          if (ch !== "&")
+            this.raise(this.pos, "Entity must start with an ampersand");
+          let startPos = ++this.pos;
+          while (this.pos < this.input.length && count++ < 10) {
+            ch = this.input[this.pos++];
+            if (ch === ";") {
+              if (str[0] === "#") {
+                if (str[1] === "x") {
+                  str = str.substr(2);
+                  if (hexNumber.test(str))
+                    entity = String.fromCharCode(parseInt(str, 16));
+                } else {
+                  str = str.substr(1);
+                  if (decimalNumber.test(str))
+                    entity = String.fromCharCode(parseInt(str, 10));
+                }
+              } else {
+                entity = XHTMLEntities[str];
+              }
+              break;
+            }
+            str += ch;
+          }
+          if (!entity) {
+            this.pos = startPos;
+            return "&";
+          }
+          return entity;
+        }
+        jsx_readWord() {
+          let ch, start3 = this.pos;
+          do {
+            ch = this.input.charCodeAt(++this.pos);
+          } while (isIdentifierChar2(ch) || ch === 45);
+          return this.finishToken(tok.jsxName, this.input.slice(start3, this.pos));
+        }
+        jsx_parseIdentifier() {
+          let node = this.startNode();
+          if (this.type === tok.jsxName)
+            node.name = this.value;
+          else if (this.type.keyword)
+            node.name = this.type.keyword;
+          else
+            this.unexpected();
+          this.next();
+          return this.finishNode(node, "JSXIdentifier");
+        }
+        jsx_parseNamespacedName() {
+          let startPos = this.start, startLoc = this.startLoc;
+          let name3 = this.jsx_parseIdentifier();
+          if (!options.allowNamespaces || !this.eat(tt.colon))
+            return name3;
+          var node = this.startNodeAt(startPos, startLoc);
+          node.namespace = name3;
+          node.name = this.jsx_parseIdentifier();
+          return this.finishNode(node, "JSXNamespacedName");
+        }
+        jsx_parseElementName() {
+          if (this.type === tok.jsxTagEnd)
+            return "";
+          let startPos = this.start, startLoc = this.startLoc;
+          let node = this.jsx_parseNamespacedName();
+          if (this.type === tt.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
+            this.unexpected();
+          }
+          while (this.eat(tt.dot)) {
+            let newNode = this.startNodeAt(startPos, startLoc);
+            newNode.object = node;
+            newNode.property = this.jsx_parseIdentifier();
+            node = this.finishNode(newNode, "JSXMemberExpression");
+          }
+          return node;
+        }
+        jsx_parseAttributeValue() {
+          switch (this.type) {
+            case tt.braceL:
+              let node = this.jsx_parseExpressionContainer();
+              if (node.expression.type === "JSXEmptyExpression")
+                this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
+              return node;
+            case tok.jsxTagStart:
+            case tt.string:
+              return this.parseExprAtom();
+            default:
+              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
+          }
+        }
+        jsx_parseEmptyExpression() {
+          let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
+          return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
+        }
+        jsx_parseExpressionContainer() {
+          let node = this.startNode();
+          this.next();
+          node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
+          this.expect(tt.braceR);
+          return this.finishNode(node, "JSXExpressionContainer");
+        }
+        jsx_parseAttribute() {
+          let node = this.startNode();
+          if (this.eat(tt.braceL)) {
+            this.expect(tt.ellipsis);
+            node.argument = this.parseMaybeAssign();
+            this.expect(tt.braceR);
+            return this.finishNode(node, "JSXSpreadAttribute");
+          }
+          node.name = this.jsx_parseNamespacedName();
+          node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
+          return this.finishNode(node, "JSXAttribute");
+        }
+        jsx_parseOpeningElementAt(startPos, startLoc) {
+          let node = this.startNodeAt(startPos, startLoc);
+          node.attributes = [];
+          let nodeName = this.jsx_parseElementName();
+          if (nodeName)
+            node.name = nodeName;
+          while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
+            node.attributes.push(this.jsx_parseAttribute());
+          node.selfClosing = this.eat(tt.slash);
+          this.expect(tok.jsxTagEnd);
+          return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
+        }
+        jsx_parseClosingElementAt(startPos, startLoc) {
+          let node = this.startNodeAt(startPos, startLoc);
+          let nodeName = this.jsx_parseElementName();
+          if (nodeName)
+            node.name = nodeName;
+          this.expect(tok.jsxTagEnd);
+          return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
+        }
+        jsx_parseElementAt(startPos, startLoc) {
+          let node = this.startNodeAt(startPos, startLoc);
+          let children = [];
+          let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
+          let closingElement = null;
+          if (!openingElement.selfClosing) {
+            contents:
+              for (; ; ) {
+                switch (this.type) {
+                  case tok.jsxTagStart:
+                    startPos = this.start;
+                    startLoc = this.startLoc;
+                    this.next();
+                    if (this.eat(tt.slash)) {
+                      closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
+                      break contents;
+                    }
+                    children.push(this.jsx_parseElementAt(startPos, startLoc));
+                    break;
+                  case tok.jsxText:
+                    children.push(this.parseExprAtom());
+                    break;
+                  case tt.braceL:
+                    children.push(this.jsx_parseExpressionContainer());
+                    break;
+                  default:
+                    this.unexpected();
+                }
+              }
+            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
+              this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
+            }
+          }
+          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
+          node["opening" + fragmentOrElement] = openingElement;
+          node["closing" + fragmentOrElement] = closingElement;
+          node.children = children;
+          if (this.type === tt.relational && this.value === "<") {
+            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
+          }
+          return this.finishNode(node, "JSX" + fragmentOrElement);
+        }
+        jsx_parseText() {
+          let node = this.parseLiteral(this.value);
+          node.type = "JSXText";
+          return node;
+        }
+        jsx_parseElement() {
+          let startPos = this.start, startLoc = this.startLoc;
+          this.next();
+          return this.jsx_parseElementAt(startPos, startLoc);
+        }
+        parseExprAtom(refShortHandDefaultPos) {
+          if (this.type === tok.jsxText)
+            return this.jsx_parseText();
+          else if (this.type === tok.jsxTagStart)
+            return this.jsx_parseElement();
+          else
+            return super.parseExprAtom(refShortHandDefaultPos);
+        }
+        readToken(code3) {
+          let context = this.curContext();
+          if (context === tc_expr)
+            return this.jsx_readToken();
+          if (context === tc_oTag || context === tc_cTag) {
+            if (isIdentifierStart2(code3))
+              return this.jsx_readWord();
+            if (code3 == 62) {
+              ++this.pos;
+              return this.finishToken(tok.jsxTagEnd);
+            }
+            if ((code3 === 34 || code3 === 39) && context == tc_oTag)
+              return this.jsx_readString(code3);
+          }
+          if (code3 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
+            ++this.pos;
+            return this.finishToken(tok.jsxTagStart);
+          }
+          return super.readToken(code3);
+        }
+        updateContext(prevType) {
+          if (this.type == tt.braceL) {
+            var curContext = this.curContext();
+            if (curContext == tc_oTag)
+              this.context.push(tokContexts.b_expr);
+            else if (curContext == tc_expr)
+              this.context.push(tokContexts.b_tmpl);
+            else
+              super.updateContext(prevType);
+            this.exprAllowed = true;
+          } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
+            this.context.length -= 2;
+            this.context.push(tc_cTag);
+            this.exprAllowed = false;
+          } else {
+            return super.updateContext(prevType);
+          }
+        }
+      };
+    }
+  }
+});
+
+// ../../node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/encode.js
+var require_encode = __commonJS({
+  "../../node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/encode.js"(exports, module) {
+    "use strict";
+    var encodeCache = {};
+    function getEncodeCache(exclude) {
+      var i, ch, cache = encodeCache[exclude];
+      if (cache) {
+        return cache;
+      }
+      cache = encodeCache[exclude] = [];
+      for (i = 0; i < 128; i++) {
+        ch = String.fromCharCode(i);
+        if (/^[0-9a-z]$/i.test(ch)) {
+          cache.push(ch);
+        } else {
+          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
+        }
+      }
+      for (i = 0; i < exclude.length; i++) {
+        cache[exclude.charCodeAt(i)] = exclude[i];
+      }
+      return cache;
+    }
+    function encode2(string3, exclude, keepEscaped) {
+      var i, l, code3, nextCode, cache, result = "";
+      if (typeof exclude !== "string") {
+        keepEscaped = exclude;
+        exclude = encode2.defaultChars;
+      }
+      if (typeof keepEscaped === "undefined") {
+        keepEscaped = true;
+      }
+      cache = getEncodeCache(exclude);
+      for (i = 0, l = string3.length; i < l; i++) {
+        code3 = string3.charCodeAt(i);
+        if (keepEscaped && code3 === 37 && i + 2 < l) {
+          if (/^[0-9a-f]{2}$/i.test(string3.slice(i + 1, i + 3))) {
+            result += string3.slice(i, i + 3);
+            i += 2;
+            continue;
+          }
+        }
+        if (code3 < 128) {
+          result += cache[code3];
+          continue;
+        }
+        if (code3 >= 55296 && code3 <= 57343) {
+          if (code3 >= 55296 && code3 <= 56319 && i + 1 < l) {
+            nextCode = string3.charCodeAt(i + 1);
+            if (nextCode >= 56320 && nextCode <= 57343) {
+              result += encodeURIComponent(string3[i] + string3[i + 1]);
+              i++;
+              continue;
+            }
+          }
+          result += "%EF%BF%BD";
+          continue;
+        }
+        result += encodeURIComponent(string3[i]);
+      }
+      return result;
+    }
+    encode2.defaultChars = ";/?:@&=+$,-_.!~*'()#";
+    encode2.componentChars = "-_.!~*'()";
+    module.exports = encode2;
+  }
+});
+
+// ../../node_modules/.pnpm/inline-style-parser@0.1.1/node_modules/inline-style-parser/index.js
+var require_inline_style_parser = __commonJS({
+  "../../node_modules/.pnpm/inline-style-parser@0.1.1/node_modules/inline-style-parser/index.js"(exports, module) {
+    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
+    var NEWLINE_REGEX = /\n/g;
+    var WHITESPACE_REGEX = /^\s*/;
+    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
+    var COLON_REGEX = /^:\s*/;
+    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
+    var SEMICOLON_REGEX = /^[;\s]*/;
+    var TRIM_REGEX = /^\s+|\s+$/g;
+    var NEWLINE = "\n";
+    var FORWARD_SLASH = "/";
+    var ASTERISK = "*";
+    var EMPTY_STRING = "";
+    var TYPE_COMMENT = "comment";
+    var TYPE_DECLARATION = "declaration";
+    module.exports = function(style3, options) {
+      if (typeof style3 !== "string") {
+        throw new TypeError("First argument must be a string");
+      }
+      if (!style3)
+        return [];
+      options = options || {};
+      var lineno = 1;
+      var column = 1;
+      function updatePosition(str) {
+        var lines = str.match(NEWLINE_REGEX);
+        if (lines)
+          lineno += lines.length;
+        var i = str.lastIndexOf(NEWLINE);
+        column = ~i ? str.length - i : column + str.length;
+      }
+      function position4() {
+        var start3 = { line: lineno, column };
+        return function(node) {
+          node.position = new Position3(start3);
+          whitespace2();
+          return node;
+        };
+      }
+      function Position3(start3) {
+        this.start = start3;
+        this.end = { line: lineno, column };
+        this.source = options.source;
+      }
+      Position3.prototype.content = style3;
+      var errorsList = [];
+      function error(msg) {
+        var err = new Error(options.source + ":" + lineno + ":" + column + ": " + msg);
+        err.reason = msg;
+        err.filename = options.source;
+        err.line = lineno;
+        err.column = column;
+        err.source = style3;
+        if (options.silent) {
+          errorsList.push(err);
+        } else {
+          throw err;
+        }
+      }
+      function match(re) {
+        var m = re.exec(style3);
+        if (!m)
+          return;
+        var str = m[0];
+        updatePosition(str);
+        style3 = style3.slice(str.length);
+        return m;
+      }
+      function whitespace2() {
+        match(WHITESPACE_REGEX);
+      }
+      function comments(rules) {
+        var c;
+        rules = rules || [];
+        while (c = comment3()) {
+          if (c !== false) {
+            rules.push(c);
+          }
+        }
+        return rules;
+      }
+      function comment3() {
+        var pos = position4();
+        if (FORWARD_SLASH != style3.charAt(0) || ASTERISK != style3.charAt(1))
+          return;
+        var i = 2;
+        while (EMPTY_STRING != style3.charAt(i) && (ASTERISK != style3.charAt(i) || FORWARD_SLASH != style3.charAt(i + 1))) {
+          ++i;
+        }
+        i += 2;
+        if (EMPTY_STRING === style3.charAt(i - 1)) {
+          return error("End of comment missing");
+        }
+        var str = style3.slice(2, i - 2);
+        column += 2;
+        updatePosition(str);
+        style3 = style3.slice(i);
+        column += 2;
+        return pos({
+          type: TYPE_COMMENT,
+          comment: str
+        });
+      }
+      function declaration() {
+        var pos = position4();
+        var prop = match(PROPERTY_REGEX);
+        if (!prop)
+          return;
+        comment3();
+        if (!match(COLON_REGEX))
+          return error("property missing ':'");
+        var val = match(VALUE_REGEX);
+        var ret = pos({
+          type: TYPE_DECLARATION,
+          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
+          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
+        });
+        match(SEMICOLON_REGEX);
+        return ret;
+      }
+      function declarations() {
+        var decls = [];
+        comments(decls);
+        var decl;
+        while (decl = declaration()) {
+          if (decl !== false) {
+            decls.push(decl);
+            comments(decls);
+          }
+        }
+        return decls;
+      }
+      whitespace2();
+      return declarations();
+    };
+    function trim(str) {
+      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
+    }
+  }
+});
+
+// ../../node_modules/.pnpm/style-to-object@0.3.0/node_modules/style-to-object/index.js
+var require_style_to_object = __commonJS({
+  "../../node_modules/.pnpm/style-to-object@0.3.0/node_modules/style-to-object/index.js"(exports, module) {
+    var parse5 = require_inline_style_parser();
+    function StyleToObject(style3, iterator) {
+      var output = null;
+      if (!style3 || typeof style3 !== "string") {
+        return output;
+      }
+      var declaration;
+      var declarations = parse5(style3);
+      var hasIterator = typeof iterator === "function";
+      var property;
+      var value;
+      for (var i = 0, len = declarations.length; i < len; i++) {
+        declaration = declarations[i];
+        property = declaration.property;
+        value = declaration.value;
+        if (hasIterator) {
+          iterator(property, value, declaration);
+        } else if (value) {
+          output || (output = {});
+          output[property] = value;
+        }
+      }
+      return output;
+    }
+    module.exports = StyleToObject;
+  }
+});
+
+// ../../node_modules/.pnpm/parse-numeric-range@1.3.0/node_modules/parse-numeric-range/index.js
+var require_parse_numeric_range = __commonJS({
+  "../../node_modules/.pnpm/parse-numeric-range@1.3.0/node_modules/parse-numeric-range/index.js"(exports, module) {
+    function parsePart(string3) {
+      let res = [];
+      let m;
+      for (let str of string3.split(",").map((str2) => str2.trim())) {
+        if (/^-?\d+$/.test(str)) {
+          res.push(parseInt(str, 10));
+        } else if (m = str.match(/^(-?\d+)(-|\.\.\.?|\u2025|\u2026|\u22EF)(-?\d+)$/)) {
+          let [_, lhs, sep, rhs] = m;
+          if (lhs && rhs) {
+            lhs = parseInt(lhs);
+            rhs = parseInt(rhs);
+            const incr = lhs < rhs ? 1 : -1;
+            if (sep === "-" || sep === ".." || sep === "\u2025")
+              rhs += incr;
+            for (let i = lhs; i !== rhs; i += incr)
+              res.push(i);
+          }
+        }
+      }
+      return res;
+    }
+    exports.default = parsePart;
+    module.exports = parsePart;
+  }
+});
+
+// ../../node_modules/.pnpm/vscode-oniguruma@1.6.1/node_modules/vscode-oniguruma/release/main.js
+var require_main = __commonJS({
+  "../../node_modules/.pnpm/vscode-oniguruma@1.6.1/node_modules/vscode-oniguruma/release/main.js"(exports, module) {
+    !function(t, n) {
+      typeof exports == "object" && typeof module == "object" ? module.exports = n() : typeof define == "function" && define.amd ? define([], n) : typeof exports == "object" ? exports.onig = n() : t.onig = n();
+    }(exports, function() {
+      return t = { 770: function(t2, n2, e) {
+        "use strict";
+        var r = this && this.__importDefault || function(t3) {
+          return t3 && t3.__esModule ? t3 : { default: t3 };
+        };
+        Object.defineProperty(n2, "__esModule", { value: true }), n2.setDefaultDebugCall = n2.createOnigScanner = n2.createOnigString = n2.loadWASM = n2.OnigScanner = n2.OnigString = void 0;
+        const i = r(e(418));
+        let o = null, a = false;
+        class f {
+          constructor(t3) {
+            const n3 = t3.length, e2 = f._utf8ByteLength(t3), r2 = e2 !== n3, i2 = r2 ? new Uint32Array(n3 + 1) : null;
+            r2 && (i2[n3] = e2);
+            const o2 = r2 ? new Uint32Array(e2 + 1) : null;
+            r2 && (o2[e2] = n3);
+            const a2 = new Uint8Array(e2);
+            let s3 = 0;
+            for (let e3 = 0; e3 < n3; e3++) {
+              const f2 = t3.charCodeAt(e3);
+              let u3 = f2, c2 = false;
+              if (f2 >= 55296 && f2 <= 56319 && e3 + 1 < n3) {
+                const n4 = t3.charCodeAt(e3 + 1);
+                n4 >= 56320 && n4 <= 57343 && (u3 = 65536 + (f2 - 55296 << 10) | n4 - 56320, c2 = true);
+              }
+              r2 && (i2[e3] = s3, c2 && (i2[e3 + 1] = s3), u3 <= 127 ? o2[s3 + 0] = e3 : u3 <= 2047 ? (o2[s3 + 0] = e3, o2[s3 + 1] = e3) : u3 <= 65535 ? (o2[s3 + 0] = e3, o2[s3 + 1] = e3, o2[s3 + 2] = e3) : (o2[s3 + 0] = e3, o2[s3 + 1] = e3, o2[s3 + 2] = e3, o2[s3 + 3] = e3)), u3 <= 127 ? a2[s3++] = u3 : u3 <= 2047 ? (a2[s3++] = 192 | (1984 & u3) >>> 6, a2[s3++] = 128 | (63 & u3) >>> 0) : u3 <= 65535 ? (a2[s3++] = 224 | (61440 & u3) >>> 12, a2[s3++] = 128 | (4032 & u3) >>> 6, a2[s3++] = 128 | (63 & u3) >>> 0) : (a2[s3++] = 240 | (1835008 & u3) >>> 18, a2[s3++] = 128 | (258048 & u3) >>> 12, a2[s3++] = 128 | (4032 & u3) >>> 6, a2[s3++] = 128 | (63 & u3) >>> 0), c2 && e3++;
+            }
+            this.utf16Length = n3, this.utf8Length = e2, this.utf16Value = t3, this.utf8Value = a2, this.utf16OffsetToUtf8 = i2, this.utf8OffsetToUtf16 = o2;
+          }
+          static _utf8ByteLength(t3) {
+            let n3 = 0;
+            for (let e2 = 0, r2 = t3.length; e2 < r2; e2++) {
+              const i2 = t3.charCodeAt(e2);
+              let o2 = i2, a2 = false;
+              if (i2 >= 55296 && i2 <= 56319 && e2 + 1 < r2) {
+                const n4 = t3.charCodeAt(e2 + 1);
+                n4 >= 56320 && n4 <= 57343 && (o2 = 65536 + (i2 - 55296 << 10) | n4 - 56320, a2 = true);
+              }
+              n3 += o2 <= 127 ? 1 : o2 <= 2047 ? 2 : o2 <= 65535 ? 3 : 4, a2 && e2++;
+            }
+            return n3;
+          }
+          createString(t3) {
+            const n3 = t3._omalloc(this.utf8Length);
+            return t3.HEAPU8.set(this.utf8Value, n3), n3;
+          }
+        }
+        class s2 {
+          constructor(t3) {
+            if (this.id = ++s2.LAST_ID, !o)
+              throw new Error("Must invoke loadWASM first.");
+            this._onigBinding = o, this.content = t3;
+            const n3 = new f(t3);
+            this.utf16Length = n3.utf16Length, this.utf8Length = n3.utf8Length, this.utf16OffsetToUtf8 = n3.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = n3.utf8OffsetToUtf16, this.utf8Length < 1e4 && !s2._sharedPtrInUse ? (s2._sharedPtr || (s2._sharedPtr = o._omalloc(1e4)), s2._sharedPtrInUse = true, o.HEAPU8.set(n3.utf8Value, s2._sharedPtr), this.ptr = s2._sharedPtr) : this.ptr = n3.createString(o);
+          }
+          convertUtf8OffsetToUtf16(t3) {
+            return this.utf8OffsetToUtf16 ? t3 < 0 ? 0 : t3 > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t3] : t3;
+          }
+          convertUtf16OffsetToUtf8(t3) {
+            return this.utf16OffsetToUtf8 ? t3 < 0 ? 0 : t3 > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t3] : t3;
+          }
+          dispose() {
+            this.ptr === s2._sharedPtr ? s2._sharedPtrInUse = false : this._onigBinding._ofree(this.ptr);
+          }
+        }
+        n2.OnigString = s2, s2.LAST_ID = 0, s2._sharedPtr = 0, s2._sharedPtrInUse = false;
+        class u2 {
+          constructor(t3) {
+            if (!o)
+              throw new Error("Must invoke loadWASM first.");
+            const n3 = [], e2 = [];
+            for (let r3 = 0, i3 = t3.length; r3 < i3; r3++) {
+              const i4 = new f(t3[r3]);
+              n3[r3] = i4.createString(o), e2[r3] = i4.utf8Length;
+            }
+            const r2 = o._omalloc(4 * t3.length);
+            o.HEAPU32.set(n3, r2 / 4);
+            const i2 = o._omalloc(4 * t3.length);
+            o.HEAPU32.set(e2, i2 / 4);
+            const a2 = o._createOnigScanner(r2, i2, t3.length);
+            for (let e3 = 0, r3 = t3.length; e3 < r3; e3++)
+              o._ofree(n3[e3]);
+            o._ofree(i2), o._ofree(r2), a2 === 0 && function(t4) {
+              throw new Error(t4.UTF8ToString(t4._getLastOnigError()));
+            }(o), this._onigBinding = o, this._ptr = a2;
+          }
+          dispose() {
+            this._onigBinding._freeOnigScanner(this._ptr);
+          }
+          findNextMatchSync(t3, n3, e2) {
+            let r2 = a, i2 = 0;
+            if (typeof e2 == "number" ? (8 & e2 && (r2 = true), i2 = e2) : typeof e2 == "boolean" && (r2 = e2), typeof t3 == "string") {
+              t3 = new s2(t3);
+              const e3 = this._findNextMatchSync(t3, n3, r2, i2);
+              return t3.dispose(), e3;
+            }
+            return this._findNextMatchSync(t3, n3, r2, i2);
+          }
+          _findNextMatchSync(t3, n3, e2, r2) {
+            const i2 = this._onigBinding;
+            let o2;
+            if (o2 = e2 ? i2._findNextOnigScannerMatchDbg(this._ptr, t3.id, t3.ptr, t3.utf8Length, t3.convertUtf16OffsetToUtf8(n3), r2) : i2._findNextOnigScannerMatch(this._ptr, t3.id, t3.ptr, t3.utf8Length, t3.convertUtf16OffsetToUtf8(n3), r2), o2 === 0)
+              return null;
+            const a2 = i2.HEAPU32;
+            let f2 = o2 / 4;
+            const s3 = a2[f2++], u3 = a2[f2++];
+            let c2 = [];
+            for (let n4 = 0; n4 < u3; n4++) {
+              const e3 = t3.convertUtf8OffsetToUtf16(a2[f2++]), r3 = t3.convertUtf8OffsetToUtf16(a2[f2++]);
+              c2[n4] = { start: e3, end: r3, length: r3 - e3 };
+            }
+            return { index: s3, captureIndices: c2 };
+          }
+        }
+        n2.OnigScanner = u2;
+        let c = false, l = null;
+        n2.loadWASM = function(t3) {
+          if (c)
+            return l;
+          let n3, e2, r2, a2;
+          if (c = true, function(t4) {
+            return typeof t4.instantiator == "function";
+          }(t3))
+            n3 = t3.instantiator, e2 = t3.print;
+          else {
+            let r3;
+            t3 instanceof ArrayBuffer || t3 instanceof Response ? r3 = t3 : (r3 = t3.data, e2 = t3.print), n3 = r3 instanceof ArrayBuffer ? function(t4) {
+              return (n4) => WebAssembly.instantiate(t4, n4);
+            }(r3) : r3 instanceof Response && typeof WebAssembly.instantiateStreaming == "function" ? function(t4) {
+              return (n4) => WebAssembly.instantiateStreaming(t4, n4);
+            }(r3) : function(t4) {
+              return (n4) => __async(this, null, function* () {
+                const e3 = yield t4.arrayBuffer();
+                return WebAssembly.instantiate(e3, n4);
+              });
+            }(r3);
+          }
+          return l = new Promise((t4, n4) => {
+            r2 = t4, a2 = n4;
+          }), function(t4, n4, e3, r3) {
+            i.default({ print: n4, instantiateWasm: (n5, e4) => {
+              if (typeof performance == "undefined") {
+                const t5 = () => Date.now();
+                n5.env.emscripten_get_now = t5, n5.wasi_snapshot_preview1.emscripten_get_now = t5;
+              }
+              return t4(n5).then((t5) => e4(t5.instance), r3), {};
+            } }).then((t5) => {
+              o = t5, e3();
+            });
+          }(n3, e2, r2, a2), l;
+        }, n2.createOnigString = function(t3) {
+          return new s2(t3);
+        }, n2.createOnigScanner = function(t3) {
+          return new u2(t3);
+        }, n2.setDefaultDebugCall = function(t3) {
+          a = t3;
+        };
+      }, 418: (t2) => {
+        var n2 = (typeof document != "undefined" && document.currentScript && document.currentScript.src, function(t3) {
+          var n3, e, r = (t3 = t3 || {}) !== void 0 ? t3 : {};
+          r.ready = new Promise(function(t4, r2) {
+            n3 = t4, e = r2;
+          });
+          var i, o = {};
+          for (i in r)
+            r.hasOwnProperty(i) && (o[i] = r[i]);
+          var a, f = [], s2 = false, u2 = false, c = true, l = "";
+          function p(t4) {
+            return r.locateFile ? r.locateFile(t4, l) : l + t4;
+          }
+          c && (a = function(t4) {
+            var n4;
+            return typeof readbuffer == "function" ? new Uint8Array(readbuffer(t4)) : (v(typeof (n4 = read(t4, "binary")) == "object"), n4);
+          }, typeof scriptArgs != "undefined" ? f = scriptArgs : arguments !== void 0 && (f = arguments), typeof onig_print != "undefined" && (typeof console == "undefined" && (console = {}), console.log = onig_print, console.warn = console.error = typeof printErr != "undefined" ? printErr : onig_print));
+          var h2 = r.print || console.log.bind(console), g = r.printErr || console.warn.bind(console);
+          for (i in o)
+            o.hasOwnProperty(i) && (r[i] = o[i]);
+          o = null, r.arguments && (f = r.arguments), r.thisProgram && r.thisProgram, r.quit && r.quit;
+          var d, _, m = function(t4) {
+          };
+          r.wasmBinary && (d = r.wasmBinary), r.noExitRuntime, typeof WebAssembly != "object" && z("no native wasm support detected");
+          var y = false;
+          function v(t4, n4) {
+            t4 || z("Assertion failed: " + n4);
+          }
+          var w, S, A, b = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
+          function O(t4, n4, e2) {
+            for (var r2 = n4 + e2, i2 = n4; t4[i2] && !(i2 >= r2); )
+              ++i2;
+            if (i2 - n4 > 16 && t4.subarray && b)
+              return b.decode(t4.subarray(n4, i2));
+            for (var o2 = ""; n4 < i2; ) {
+              var a2 = t4[n4++];
+              if (128 & a2) {
+                var f2 = 63 & t4[n4++];
+                if ((224 & a2) != 192) {
+                  var s3 = 63 & t4[n4++];
+                  if ((a2 = (240 & a2) == 224 ? (15 & a2) << 12 | f2 << 6 | s3 : (7 & a2) << 18 | f2 << 12 | s3 << 6 | 63 & t4[n4++]) < 65536)
+                    o2 += String.fromCharCode(a2);
+                  else {
+                    var u3 = a2 - 65536;
+                    o2 += String.fromCharCode(55296 | u3 >> 10, 56320 | 1023 & u3);
+                  }
+                } else
+                  o2 += String.fromCharCode((31 & a2) << 6 | f2);
+              } else
+                o2 += String.fromCharCode(a2);
+            }
+            return o2;
+          }
+          function U(t4, n4) {
+            return t4 ? O(S, t4, n4) : "";
+          }
+          function x(t4, n4) {
+            return t4 % n4 > 0 && (t4 += n4 - t4 % n4), t4;
+          }
+          function P(t4) {
+            w = t4, r.HEAP8 = new Int8Array(t4), r.HEAP16 = new Int16Array(t4), r.HEAP32 = A = new Int32Array(t4), r.HEAPU8 = S = new Uint8Array(t4), r.HEAPU16 = new Uint16Array(t4), r.HEAPU32 = new Uint32Array(t4), r.HEAPF32 = new Float32Array(t4), r.HEAPF64 = new Float64Array(t4);
+          }
+          typeof TextDecoder != "undefined" && new TextDecoder("utf-16le"), r.INITIAL_MEMORY;
+          var T, R = [], E = [], M = [], L = [];
+          function I() {
+            if (r.preRun)
+              for (typeof r.preRun == "function" && (r.preRun = [r.preRun]); r.preRun.length; )
+                N(r.preRun.shift());
+            $2(R);
+          }
+          function D() {
+            $2(E);
+          }
+          function W() {
+            $2(M);
+          }
+          function C() {
+            if (r.postRun)
+              for (typeof r.postRun == "function" && (r.postRun = [r.postRun]); r.postRun.length; )
+                B(r.postRun.shift());
+            $2(L);
+          }
+          function N(t4) {
+            R.unshift(t4);
+          }
+          function B(t4) {
+            L.unshift(t4);
+          }
+          E.push({ func: function() {
+            ut();
+          } });
+          var k = 0, H = null, j = null;
+          function F(t4) {
+            k++, r.monitorRunDependencies && r.monitorRunDependencies(k);
+          }
+          function V(t4) {
+            if (k--, r.monitorRunDependencies && r.monitorRunDependencies(k), k == 0 && (H !== null && (clearInterval(H), H = null), j)) {
+              var n4 = j;
+              j = null, n4();
+            }
+          }
+          function z(t4) {
+            r.onAbort && r.onAbort(t4), g(t4 += ""), y = true, t4 = "abort(" + t4 + "). Build with -s ASSERTIONS=1 for more info.";
+            var n4 = new WebAssembly.RuntimeError(t4);
+            throw e(n4), n4;
+          }
+          function q(t4, n4) {
+            return String.prototype.startsWith ? t4.startsWith(n4) : t4.indexOf(n4) === 0;
+          }
+          r.preloadedImages = {}, r.preloadedAudios = {};
+          var Y = "data:application/octet-stream;base64,";
+          function G(t4) {
+            return q(t4, Y);
+          }
+          var J, K = "onig.wasm";
+          function Q(t4) {
+            try {
+              if (t4 == K && d)
+                return new Uint8Array(d);
+              if (a)
+                return a(t4);
+              throw "both async and sync fetching of the wasm failed";
+            } catch (t5) {
+              z(t5);
+            }
+          }
+          function X() {
+            return d || !s2 && !u2 || typeof fetch != "function" ? Promise.resolve().then(function() {
+              return Q(K);
+            }) : fetch(K, { credentials: "same-origin" }).then(function(t4) {
+              if (!t4.ok)
+                throw "failed to load wasm binary file at '" + K + "'";
+              return t4.arrayBuffer();
+            }).catch(function() {
+              return Q(K);
+            });
+          }
+          function Z() {
+            var t4 = { env: st, wasi_snapshot_preview1: st };
+            function n4(t5, n5) {
+              var e2 = t5.exports;
+              r.asm = e2, P((_ = r.asm.memory).buffer), T = r.asm.__indirect_function_table, V();
+            }
+            function i2(t5) {
+              n4(t5.instance);
+            }
+            function o2(n5) {
+              return X().then(function(n6) {
+                return WebAssembly.instantiate(n6, t4);
+              }).then(n5, function(t5) {
+                g("failed to asynchronously prepare wasm: " + t5), z(t5);
+              });
+            }
+            if (F(), r.instantiateWasm)
+              try {
+                return r.instantiateWasm(t4, n4);
+              } catch (t5) {
+                return g("Module.instantiateWasm callback failed with error: " + t5), false;
+              }
+            return (d || typeof WebAssembly.instantiateStreaming != "function" || G(K) || typeof fetch != "function" ? o2(i2) : fetch(K, { credentials: "same-origin" }).then(function(n5) {
+              return WebAssembly.instantiateStreaming(n5, t4).then(i2, function(t5) {
+                return g("wasm streaming compile failed: " + t5), g("falling back to ArrayBuffer instantiation"), o2(i2);
+              });
+            })).catch(e), {};
+          }
+          function $2(t4) {
+            for (; t4.length > 0; ) {
+              var n4 = t4.shift();
+              if (typeof n4 != "function") {
+                var e2 = n4.func;
+                typeof e2 == "number" ? n4.arg === void 0 ? T.get(e2)() : T.get(e2)(n4.arg) : e2(n4.arg === void 0 ? null : n4.arg);
+              } else
+                n4(r);
+            }
+          }
+          function tt(t4, n4, e2) {
+            S.copyWithin(t4, n4, n4 + e2);
+          }
+          function nt() {
+            return S.length;
+          }
+          function et(t4) {
+            try {
+              return _.grow(t4 - w.byteLength + 65535 >>> 16), P(_.buffer), 1;
+            } catch (t5) {
+            }
+          }
+          function rt(t4) {
+            var n4 = nt(), e2 = 2147483648;
+            if (t4 > e2)
+              return false;
+            for (var r2 = 1; r2 <= 4; r2 *= 2) {
+              var i2 = n4 * (1 + 0.2 / r2);
+              if (i2 = Math.min(i2, t4 + 100663296), et(Math.min(e2, x(Math.max(t4, i2), 65536))))
+                return true;
+            }
+            return false;
+          }
+          G(K) || (K = p(K)), J = typeof dateNow != "undefined" ? dateNow : function() {
+            return performance.now();
+          };
+          var it = { mappings: {}, buffers: [null, [], []], printChar: function(t4, n4) {
+            var e2 = it.buffers[t4];
+            n4 === 0 || n4 === 10 ? ((t4 === 1 ? h2 : g)(O(e2, 0)), e2.length = 0) : e2.push(n4);
+          }, varargs: void 0, get: function() {
+            return it.varargs += 4, A[it.varargs - 4 >> 2];
+          }, getStr: function(t4) {
+            return U(t4);
+          }, get64: function(t4, n4) {
+            return t4;
+          } };
+          function ot(t4, n4, e2, r2) {
+            for (var i2 = 0, o2 = 0; o2 < e2; o2++) {
+              for (var a2 = A[n4 + 8 * o2 >> 2], f2 = A[n4 + (8 * o2 + 4) >> 2], s3 = 0; s3 < f2; s3++)
+                it.printChar(t4, S[a2 + s3]);
+              i2 += f2;
+            }
+            return A[r2 >> 2] = i2, 0;
+          }
+          function at2(t4) {
+            m(0 | t4);
+          }
+          var ft, st = { emscripten_get_now: J, emscripten_memcpy_big: tt, emscripten_resize_heap: rt, fd_write: ot, setTempRet0: at2 }, ut = (Z(), r.___wasm_call_ctors = function() {
+            return (ut = r.___wasm_call_ctors = r.asm.__wasm_call_ctors).apply(null, arguments);
+          });
+          function ct(t4) {
+            function e2() {
+              ft || (ft = true, r.calledRun = true, y || (D(), W(), n3(r), r.onRuntimeInitialized && r.onRuntimeInitialized(), C()));
+            }
+            t4 = t4 || f, k > 0 || (I(), k > 0 || (r.setStatus ? (r.setStatus("Running..."), setTimeout(function() {
+              setTimeout(function() {
+                r.setStatus("");
+              }, 1), e2();
+            }, 1)) : e2()));
+          }
+          if (r.___errno_location = function() {
+            return (r.___errno_location = r.asm.__errno_location).apply(null, arguments);
+          }, r._omalloc = function() {
+            return (r._omalloc = r.asm.omalloc).apply(null, arguments);
+          }, r._ofree = function() {
+            return (r._ofree = r.asm.ofree).apply(null, arguments);
+          }, r._getLastOnigError = function() {
+            return (r._getLastOnigError = r.asm.getLastOnigError).apply(null, arguments);
+          }, r._createOnigScanner = function() {
+            return (r._createOnigScanner = r.asm.createOnigScanner).apply(null, arguments);
+          }, r._freeOnigScanner = function() {
+            return (r._freeOnigScanner = r.asm.freeOnigScanner).apply(null, arguments);
+          }, r._findNextOnigScannerMatch = function() {
+            return (r._findNextOnigScannerMatch = r.asm.findNextOnigScannerMatch).apply(null, arguments);
+          }, r._findNextOnigScannerMatchDbg = function() {
+            return (r._findNextOnigScannerMatchDbg = r.asm.findNextOnigScannerMatchDbg).apply(null, arguments);
+          }, r.stackSave = function() {
+            return (r.stackSave = r.asm.stackSave).apply(null, arguments);
+          }, r.stackRestore = function() {
+            return (r.stackRestore = r.asm.stackRestore).apply(null, arguments);
+          }, r.stackAlloc = function() {
+            return (r.stackAlloc = r.asm.stackAlloc).apply(null, arguments);
+          }, r.dynCall_jiji = function() {
+            return (r.dynCall_jiji = r.asm.dynCall_jiji).apply(null, arguments);
+          }, r.UTF8ToString = U, j = function t4() {
+            ft || ct(), ft || (j = t4);
+          }, r.run = ct, r.preInit)
+            for (typeof r.preInit == "function" && (r.preInit = [r.preInit]); r.preInit.length > 0; )
+              r.preInit.pop()();
+          return ct(), t3.ready;
+        });
+        t2.exports = n2;
+      } }, n = {}, function e(r) {
+        var i = n[r];
+        if (i !== void 0)
+          return i.exports;
+        var o = n[r] = { exports: {} };
+        return t[r].call(o.exports, o, o.exports, e), o.exports;
+      }(770);
+      var t, n;
+    });
+  }
+});
+
+// ../../node_modules/.pnpm/vscode-textmate@5.2.0/node_modules/vscode-textmate/release/main.js
+var require_main2 = __commonJS({
+  "../../node_modules/.pnpm/vscode-textmate@5.2.0/node_modules/vscode-textmate/release/main.js"(exports, module) {
+    !function(e, t) {
+      typeof exports == "object" && typeof module == "object" ? module.exports = t() : typeof define == "function" && define.amd ? define([], t) : typeof exports == "object" ? exports.vscodetextmate = t() : e.vscodetextmate = t();
+    }(exports, function() {
+      return function(e) {
+        var t = {};
+        function n(r) {
+          if (t[r])
+            return t[r].exports;
+          var i = t[r] = { i: r, l: false, exports: {} };
+          return e[r].call(i.exports, i, i.exports, n), i.l = true, i.exports;
+        }
+        return n.m = e, n.c = t, n.d = function(e2, t2, r) {
+          n.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: r });
+        }, n.r = function(e2) {
+          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
+        }, n.t = function(e2, t2) {
+          if (1 & t2 && (e2 = n(e2)), 8 & t2)
+            return e2;
+          if (4 & t2 && typeof e2 == "object" && e2 && e2.__esModule)
+            return e2;
+          var r = /* @__PURE__ */ Object.create(null);
+          if (n.r(r), Object.defineProperty(r, "default", { enumerable: true, value: e2 }), 2 & t2 && typeof e2 != "string")
+            for (var i in e2)
+              n.d(r, i, function(t3) {
+                return e2[t3];
+              }.bind(null, i));
+          return r;
+        }, n.n = function(e2) {
+          var t2 = e2 && e2.__esModule ? function() {
+            return e2.default;
+          } : function() {
+            return e2;
+          };
+          return n.d(t2, "a", t2), t2;
+        }, n.o = function(e2, t2) {
+          return Object.prototype.hasOwnProperty.call(e2, t2);
+        }, n.p = "", n(n.s = 3);
+      }([function(e, t, n) {
+        "use strict";
+        Object.defineProperty(t, "__esModule", { value: true });
+        var r = n(1), i = n(5), o = n(6), s2 = n(2), a = typeof performance == "undefined" ? function() {
+          return Date.now();
+        } : function() {
+          return performance.now();
+        };
+        t.createGrammar = function(e2, t2, n2, r2, i2, o2) {
+          return new v(e2, t2, n2, r2, i2, o2);
+        };
+        var c = function(e2) {
+          this.scopeName = e2;
+        };
+        t.FullScopeDependency = c;
+        var u2 = function() {
+          function e2(e3, t2) {
+            this.scopeName = e3, this.include = t2;
+          }
+          return e2.prototype.toKey = function() {
+            return this.scopeName + "#" + this.include;
+          }, e2;
+        }();
+        t.PartialScopeDependency = u2;
+        var l = function() {
+          function e2() {
+            this.full = [], this.partial = [], this.visitedRule = /* @__PURE__ */ new Set(), this._seenFull = /* @__PURE__ */ new Set(), this._seenPartial = /* @__PURE__ */ new Set();
+          }
+          return e2.prototype.add = function(e3) {
+            e3 instanceof c ? this._seenFull.has(e3.scopeName) || (this._seenFull.add(e3.scopeName), this.full.push(e3)) : this._seenPartial.has(e3.toKey()) || (this._seenPartial.add(e3.toKey()), this.partial.push(e3));
+          }, e2;
+        }();
+        function h2(e2, t2, n2, i2, o2) {
+          for (var s3 = 0, a2 = i2; s3 < a2.length; s3++) {
+            var l2 = a2[s3];
+            if (!e2.visitedRule.has(l2)) {
+              e2.visitedRule.add(l2);
+              var d2 = l2.repository ? r.mergeObjects({}, o2, l2.repository) : o2;
+              Array.isArray(l2.patterns) && h2(e2, t2, n2, l2.patterns, d2);
+              var g2 = l2.include;
+              if (g2)
+                if (g2 === "$base" || g2 === t2.scopeName)
+                  f(e2, t2, t2);
+                else if (g2 === "$self" || g2 === n2.scopeName)
+                  f(e2, t2, n2);
+                else if (g2.charAt(0) === "#")
+                  p(e2, t2, n2, g2.substring(1), d2);
+                else {
+                  var m2 = g2.indexOf("#");
+                  if (m2 >= 0) {
+                    var _2 = g2.substring(0, m2), y2 = g2.substring(m2 + 1);
+                    _2 === t2.scopeName ? p(e2, t2, t2, y2, d2) : _2 === n2.scopeName ? p(e2, t2, n2, y2, d2) : e2.add(new u2(_2, g2.substring(m2 + 1)));
+                  } else
+                    e2.add(new c(g2));
+                }
+            }
+          }
+        }
+        function p(e2, t2, n2, r2, i2) {
+          (i2 === void 0 && (i2 = n2.repository), i2 && i2[r2]) && h2(e2, t2, n2, [i2[r2]], i2);
+        }
+        function f(e2, t2, n2) {
+          if (n2.patterns && Array.isArray(n2.patterns) && h2(e2, t2, n2, n2.patterns, n2.repository), n2.injections) {
+            var r2 = [];
+            for (var i2 in n2.injections)
+              r2.push(n2.injections[i2]);
+            h2(e2, t2, n2, r2, n2.repository);
+          }
+        }
+        function d(e2, t2) {
+          if (!e2)
+            return false;
+          if (e2 === t2)
+            return true;
+          var n2 = t2.length;
+          return e2.length > n2 && e2.substr(0, n2) === t2 && e2[n2] === ".";
+        }
+        function g(e2, t2) {
+          if (t2.length < e2.length)
+            return false;
+          var n2 = 0;
+          return e2.every(function(e3) {
+            for (var r2 = n2; r2 < t2.length; r2++)
+              if (d(t2[r2], e3))
+                return n2 = r2 + 1, true;
+            return false;
+          });
+        }
+        function m(e2, t2, n2, r2, s3) {
+          for (var a2 = o.createMatchers(t2, g), c2 = i.RuleFactory.getCompiledRuleId(n2, r2, s3.repository), u3 = 0, l2 = a2; u3 < l2.length; u3++) {
+            var h3 = l2[u3];
+            e2.push({ matcher: h3.matcher, ruleId: c2, grammar: s3, priority: h3.priority });
+          }
+        }
+        t.ScopeDependencyCollector = l, t.collectSpecificDependencies = p, t.collectDependencies = f;
+        var _ = function(e2, t2, n2, r2) {
+          this.scopeName = e2, this.languageId = t2, this.tokenType = n2, this.themeData = r2;
+        };
+        t.ScopeMetadata = _;
+        var y = function() {
+          function e2(t2, n2, r2) {
+            if (this._initialLanguage = t2, this._themeProvider = n2, this._cache = /* @__PURE__ */ new Map(), this._defaultMetaData = new _("", this._initialLanguage, 0, [this._themeProvider.getDefaults()]), this._embeddedLanguages = /* @__PURE__ */ Object.create(null), r2)
+              for (var i2 = Object.keys(r2), o2 = 0, s3 = i2.length; o2 < s3; o2++) {
+                var a2 = i2[o2], c2 = r2[a2];
+                typeof c2 == "number" && c2 !== 0 ? this._embeddedLanguages[a2] = c2 : console.warn("Invalid embedded language found at scope " + a2 + ": <<" + c2 + ">>");
+              }
+            var u3 = Object.keys(this._embeddedLanguages).map(function(t3) {
+              return e2._escapeRegExpCharacters(t3);
+            });
+            u3.length === 0 ? this._embeddedLanguagesRegex = null : (u3.sort(), u3.reverse(), this._embeddedLanguagesRegex = new RegExp("^((" + u3.join(")|(") + "))($|\\.)", ""));
+          }
+          return e2.prototype.onDidChangeTheme = function() {
+            this._cache = /* @__PURE__ */ new Map(), this._defaultMetaData = new _("", this._initialLanguage, 0, [this._themeProvider.getDefaults()]);
+          }, e2.prototype.getDefaultMetadata = function() {
+            return this._defaultMetaData;
+          }, e2._escapeRegExpCharacters = function(e3) {
+            return e3.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
+          }, e2.prototype.getMetadataForScope = function(t2) {
+            if (t2 === null)
+              return e2._NULL_SCOPE_METADATA;
+            var n2 = this._cache.get(t2);
+            return n2 || (n2 = this._doGetMetadataForScope(t2), this._cache.set(t2, n2), n2);
+          }, e2.prototype._doGetMetadataForScope = function(e3) {
+            var t2 = this._scopeToLanguage(e3), n2 = this._toStandardTokenType(e3), r2 = this._themeProvider.themeMatch(e3);
+            return new _(e3, t2, n2, r2);
+          }, e2.prototype._scopeToLanguage = function(e3) {
+            if (!e3)
+              return 0;
+            if (!this._embeddedLanguagesRegex)
+              return 0;
+            var t2 = e3.match(this._embeddedLanguagesRegex);
+            if (!t2)
+              return 0;
+            var n2 = this._embeddedLanguages[t2[1]] || 0;
+            return n2 || 0;
+          }, e2.prototype._toStandardTokenType = function(t2) {
+            var n2 = t2.match(e2.STANDARD_TOKEN_TYPE_REGEXP);
+            if (!n2)
+              return 0;
+            switch (n2[1]) {
+              case "comment":
+                return 1;
+              case "string":
+                return 2;
+              case "regex":
+                return 4;
+              case "meta.embedded":
+                return 8;
+            }
+            throw new Error("Unexpected match for standard token type!");
+          }, e2._NULL_SCOPE_METADATA = new _("", 0, 0, null), e2.STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/, e2;
+        }(), v = function() {
+          function e2(e3, t2, n2, r2, i2, s3) {
+            if (this._scopeMetadataProvider = new y(t2, i2, n2), this._onigLib = s3, this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = i2, this._grammar = C(e3, null), this._injections = null, this._tokenTypeMatchers = [], r2)
+              for (var a2 = 0, c2 = Object.keys(r2); a2 < c2.length; a2++)
+                for (var u3 = c2[a2], l2 = 0, h3 = o.createMatchers(u3, g); l2 < h3.length; l2++) {
+                  var p2 = h3[l2];
+                  this._tokenTypeMatchers.push({ matcher: p2.matcher, type: r2[u3] });
+                }
+          }
+          return e2.prototype.dispose = function() {
+            for (var e3 = 0, t2 = this._ruleId2desc; e3 < t2.length; e3++) {
+              var n2 = t2[e3];
+              n2 && n2.dispose();
+            }
+          }, e2.prototype.createOnigScanner = function(e3) {
+            return this._onigLib.createOnigScanner(e3);
+          }, e2.prototype.createOnigString = function(e3) {
+            return this._onigLib.createOnigString(e3);
+          }, e2.prototype.onDidChangeTheme = function() {
+            this._scopeMetadataProvider.onDidChangeTheme();
+          }, e2.prototype.getMetadataForScope = function(e3) {
+            return this._scopeMetadataProvider.getMetadataForScope(e3);
+          }, e2.prototype.getInjections = function() {
+            var e3 = this;
+            if (this._injections === null) {
+              this._injections = [];
+              var t2 = this._grammar.injections;
+              if (t2)
+                for (var n2 in t2)
+                  m(this._injections, n2, t2[n2], this, this._grammar);
+              if (this._grammarRepository) {
+                var r2 = this._grammarRepository.injections(this._grammar.scopeName);
+                r2 && r2.forEach(function(t3) {
+                  var n3 = e3.getExternalGrammar(t3);
+                  if (n3) {
+                    var r3 = n3.injectionSelector;
+                    r3 && m(e3._injections, r3, n3, e3, n3);
+                  }
+                });
+              }
+              this._injections.sort(function(e4, t3) {
+                return e4.priority - t3.priority;
+              });
+            }
+            return this._injections;
+          }, e2.prototype.registerRule = function(e3) {
+            var t2 = ++this._lastRuleId, n2 = e3(t2);
+            return this._ruleId2desc[t2] = n2, n2;
+          }, e2.prototype.getRule = function(e3) {
+            return this._ruleId2desc[e3];
+          }, e2.prototype.getExternalGrammar = function(e3, t2) {
+            if (this._includedGrammars[e3])
+              return this._includedGrammars[e3];
+            if (this._grammarRepository) {
+              var n2 = this._grammarRepository.lookup(e3);
+              if (n2)
+                return this._includedGrammars[e3] = C(n2, t2 && t2.$base), this._includedGrammars[e3];
+            }
+            return null;
+          }, e2.prototype.tokenizeLine = function(e3, t2) {
+            var n2 = this._tokenize(e3, t2, false);
+            return { tokens: n2.lineTokens.getResult(n2.ruleStack, n2.lineLength), ruleStack: n2.ruleStack };
+          }, e2.prototype.tokenizeLine2 = function(e3, t2) {
+            var n2 = this._tokenize(e3, t2, true);
+            return { tokens: n2.lineTokens.getBinaryResult(n2.ruleStack, n2.lineLength), ruleStack: n2.ruleStack };
+          }, e2.prototype._tokenize = function(e3, t2, n2) {
+            var r2;
+            if (this._rootId === -1 && (this._rootId = i.RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository)), t2 && t2 !== I.NULL)
+              r2 = false, t2.reset();
+            else {
+              r2 = true;
+              var o2 = this._scopeMetadataProvider.getDefaultMetadata(), s3 = o2.themeData[0], a2 = P.set(0, o2.languageId, o2.tokenType, s3.fontStyle, s3.foreground, s3.background), c2 = this.getRule(this._rootId).getName(null, null), u3 = this._scopeMetadataProvider.getMetadataForScope(c2), l2 = x.mergeMetadata(a2, null, u3), h3 = new x(null, c2 === null ? "unknown" : c2, l2);
+              t2 = new I(null, this._rootId, -1, -1, false, null, h3, h3);
+            }
+            e3 += "\n";
+            var p2 = this.createOnigString(e3), f2 = p2.content.length, d2 = new T(n2, e3, this._tokenTypeMatchers), g2 = S(this, p2, r2, 0, t2, d2, true);
+            return b(p2), { lineLength: f2, lineTokens: d2, ruleStack: g2 };
+          }, e2;
+        }();
+        function b(e2) {
+          typeof e2.dispose == "function" && e2.dispose();
+        }
+        function C(e2, t2) {
+          return (e2 = r.clone(e2)).repository = e2.repository || {}, e2.repository.$self = { $vscodeTextmateLocation: e2.$vscodeTextmateLocation, patterns: e2.patterns, name: e2.scopeName }, e2.repository.$base = t2 || e2.repository.$self, e2;
+        }
+        function w(e2, t2, n2, r2, i2, o2, s3) {
+          if (o2.length !== 0) {
+            for (var a2 = t2.content, c2 = Math.min(o2.length, s3.length), u3 = [], l2 = s3[0].end, h3 = 0; h3 < c2; h3++) {
+              var p2 = o2[h3];
+              if (p2 !== null) {
+                var f2 = s3[h3];
+                if (f2.length !== 0) {
+                  if (f2.start > l2)
+                    break;
+                  for (; u3.length > 0 && u3[u3.length - 1].endPos <= f2.start; )
+                    i2.produceFromScopes(u3[u3.length - 1].scopes, u3[u3.length - 1].endPos), u3.pop();
+                  if (u3.length > 0 ? i2.produceFromScopes(u3[u3.length - 1].scopes, f2.start) : i2.produce(r2, f2.start), p2.retokenizeCapturedWithRuleId) {
+                    var d2 = p2.getName(a2, s3), g2 = r2.contentNameScopesList.push(e2, d2), m2 = p2.getContentName(a2, s3), _2 = g2.push(e2, m2), y2 = r2.push(p2.retokenizeCapturedWithRuleId, f2.start, -1, false, null, g2, _2), v2 = e2.createOnigString(a2.substring(0, f2.end));
+                    S(e2, v2, n2 && f2.start === 0, f2.start, y2, i2, false), b(v2);
+                  } else {
+                    var C2 = p2.getName(a2, s3);
+                    if (C2 !== null) {
+                      var w2 = (u3.length > 0 ? u3[u3.length - 1].scopes : r2.contentNameScopesList).push(e2, C2);
+                      u3.push(new A(w2, f2.end));
+                    }
+                  }
+                }
+              }
+            }
+            for (; u3.length > 0; )
+              i2.produceFromScopes(u3[u3.length - 1].scopes, u3[u3.length - 1].endPos), u3.pop();
+          }
+        }
+        function k(e2) {
+          for (var t2 = [], n2 = 0, r2 = e2.rules.length; n2 < r2; n2++)
+            t2.push("   - " + e2.rules[n2] + ": " + e2.debugRegExps[n2]);
+          return t2.join("\n");
+        }
+        function R(e2, t2, n2, r2, i2, o2) {
+          var c2 = function(e3, t3, n3, r3, i3, o3) {
+            var c3 = i3.getRule(e3), u4 = c3.compile(e3, i3.endRule, n3, r3 === o3), l3 = 0;
+            s2.DebugFlags.InDebugMode && (l3 = a());
+            var h4 = u4.scanner.findNextMatchSync(t3, r3);
+            if (s2.DebugFlags.InDebugMode) {
+              var p3 = a() - l3;
+              p3 > 5 && console.warn("Rule " + c3.debugName + " (" + c3.id + ") matching took " + p3 + " against '" + t3 + "'"), h4 && console.log("matched rule id: " + u4.rules[h4.index] + " from " + h4.captureIndices[0].start + " to " + h4.captureIndices[0].end);
+            }
+            return h4 ? { captureIndices: h4.captureIndices, matchedRuleId: u4.rules[h4.index] } : null;
+          }(e2, t2, n2, r2, i2, o2), u3 = e2.getInjections();
+          if (u3.length === 0)
+            return c2;
+          var l2 = function(e3, t3, n3, r3, i3, o3, a2) {
+            for (var c3, u4 = Number.MAX_VALUE, l3 = null, h4 = 0, p3 = o3.contentNameScopesList.generateScopes(), f2 = 0, d2 = e3.length; f2 < d2; f2++) {
+              var g2 = e3[f2];
+              if (g2.matcher(p3)) {
+                var m2 = t3.getRule(g2.ruleId).compile(t3, null, r3, i3 === a2), _2 = m2.scanner.findNextMatchSync(n3, i3);
+                if (s2.DebugFlags.InDebugMode && (console.log("  scanning for injections"), console.log(k(m2))), _2) {
+                  var y2 = _2.captureIndices[0].start;
+                  if (!(y2 >= u4) && (u4 = y2, l3 = _2.captureIndices, c3 = m2.rules[_2.index], h4 = g2.priority, u4 === i3))
+                    break;
+                }
+              }
+            }
+            return l3 ? { priorityMatch: h4 === -1, captureIndices: l3, matchedRuleId: c3 } : null;
+          }(u3, e2, t2, n2, r2, i2, o2);
+          if (!l2)
+            return c2;
+          if (!c2)
+            return l2;
+          var h3 = c2.captureIndices[0].start, p2 = l2.captureIndices[0].start;
+          return p2 < h3 || l2.priorityMatch && p2 === h3 ? l2 : c2;
+        }
+        function S(e2, t2, n2, r2, o2, a2, c2) {
+          var u3 = t2.content.length, l2 = false, h3 = -1;
+          if (c2) {
+            var p2 = function(e3, t3, n3, r3, o3, a3) {
+              for (var c3 = o3.beginRuleCapturedEOL ? 0 : -1, u4 = [], l3 = o3; l3; l3 = l3.pop()) {
+                var h4 = l3.getRule(e3);
+                h4 instanceof i.BeginWhileRule && u4.push({ rule: h4, stack: l3 });
+              }
+              for (var p3 = u4.pop(); p3; p3 = u4.pop()) {
+                var f3 = p3.rule.compileWhile(e3, p3.stack.endRule, n3, c3 === r3), d2 = f3.scanner.findNextMatchSync(t3, r3);
+                if (s2.DebugFlags.InDebugMode && (console.log("  scanning for while rule"), console.log(k(f3))), !d2) {
+                  s2.DebugFlags.InDebugMode && console.log("  popping " + p3.rule.debugName + " - " + p3.rule.debugWhileRegExp), o3 = p3.stack.pop();
+                  break;
+                }
+                if (f3.rules[d2.index] !== -2) {
+                  o3 = p3.stack.pop();
+                  break;
+                }
+                d2.captureIndices && d2.captureIndices.length && (a3.produce(p3.stack, d2.captureIndices[0].start), w(e3, t3, n3, p3.stack, a3, p3.rule.whileCaptures, d2.captureIndices), a3.produce(p3.stack, d2.captureIndices[0].end), c3 = d2.captureIndices[0].end, d2.captureIndices[0].end > r3 && (r3 = d2.captureIndices[0].end, n3 = false));
+              }
+              return { stack: o3, linePos: r3, anchorPosition: c3, isFirstLine: n3 };
+            }(e2, t2, n2, r2, o2, a2);
+            o2 = p2.stack, r2 = p2.linePos, n2 = p2.isFirstLine, h3 = p2.anchorPosition;
+          }
+          for (; !l2; )
+            f2();
+          function f2() {
+            s2.DebugFlags.InDebugMode && (console.log(""), console.log("@@scanNext " + r2 + ": |" + t2.content.substr(r2).replace(/\n$/, "\\n") + "|"));
+            var c3 = R(e2, t2, n2, r2, o2, h3);
+            if (!c3)
+              return s2.DebugFlags.InDebugMode && console.log("  no more matches."), a2.produce(o2, u3), void (l2 = true);
+            var p3 = c3.captureIndices, f3 = c3.matchedRuleId, d2 = !!(p3 && p3.length > 0) && p3[0].end > r2;
+            if (f3 === -1) {
+              var g2 = o2.getRule(e2);
+              s2.DebugFlags.InDebugMode && console.log("  popping " + g2.debugName + " - " + g2.debugEndRegExp), a2.produce(o2, p3[0].start), o2 = o2.setContentNameScopesList(o2.nameScopesList), w(e2, t2, n2, o2, a2, g2.endCaptures, p3), a2.produce(o2, p3[0].end);
+              var m2 = o2;
+              if (o2 = o2.pop(), h3 = m2.getAnchorPos(), !d2 && m2.getEnterPos() === r2)
+                return s2.DebugFlags.InDebugMode && console.error("[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing"), o2 = m2, a2.produce(o2, u3), void (l2 = true);
+            } else {
+              var _2 = e2.getRule(f3);
+              a2.produce(o2, p3[0].start);
+              var y2 = o2, v2 = _2.getName(t2.content, p3), b2 = o2.contentNameScopesList.push(e2, v2);
+              if (o2 = o2.push(f3, r2, h3, p3[0].end === u3, null, b2, b2), _2 instanceof i.BeginEndRule) {
+                var C2 = _2;
+                s2.DebugFlags.InDebugMode && console.log("  pushing " + C2.debugName + " - " + C2.debugBeginRegExp), w(e2, t2, n2, o2, a2, C2.beginCaptures, p3), a2.produce(o2, p3[0].end), h3 = p3[0].end;
+                var k2 = C2.getContentName(t2.content, p3), S2 = b2.push(e2, k2);
+                if (o2 = o2.setContentNameScopesList(S2), C2.endHasBackReferences && (o2 = o2.setEndRule(C2.getEndWithResolvedBackReferences(t2.content, p3))), !d2 && y2.hasSameRuleAs(o2))
+                  return s2.DebugFlags.InDebugMode && console.error("[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), o2 = o2.pop(), a2.produce(o2, u3), void (l2 = true);
+              } else if (_2 instanceof i.BeginWhileRule) {
+                C2 = _2;
+                s2.DebugFlags.InDebugMode && console.log("  pushing " + C2.debugName), w(e2, t2, n2, o2, a2, C2.beginCaptures, p3), a2.produce(o2, p3[0].end), h3 = p3[0].end;
+                k2 = C2.getContentName(t2.content, p3), S2 = b2.push(e2, k2);
+                if (o2 = o2.setContentNameScopesList(S2), C2.whileHasBackReferences && (o2 = o2.setEndRule(C2.getWhileWithResolvedBackReferences(t2.content, p3))), !d2 && y2.hasSameRuleAs(o2))
+                  return s2.DebugFlags.InDebugMode && console.error("[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), o2 = o2.pop(), a2.produce(o2, u3), void (l2 = true);
+              } else {
+                var P2 = _2;
+                if (s2.DebugFlags.InDebugMode && console.log("  matched " + P2.debugName + " - " + P2.debugMatchRegExp), w(e2, t2, n2, o2, a2, P2.captures, p3), a2.produce(o2, p3[0].end), o2 = o2.pop(), !d2)
+                  return s2.DebugFlags.InDebugMode && console.error("[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping"), o2 = o2.safePop(), a2.produce(o2, u3), void (l2 = true);
+              }
+            }
+            p3[0].end > r2 && (r2 = p3[0].end, n2 = false);
+          }
+          return o2;
+        }
+        t.Grammar = v;
+        var P = function() {
+          function e2() {
+          }
+          return e2.toBinaryStr = function(e3) {
+            for (var t2 = e3.toString(2); t2.length < 32; )
+              t2 = "0" + t2;
+            return t2;
+          }, e2.printMetadata = function(t2) {
+            var n2 = e2.getLanguageId(t2), r2 = e2.getTokenType(t2), i2 = e2.getFontStyle(t2), o2 = e2.getForeground(t2), s3 = e2.getBackground(t2);
+            console.log({ languageId: n2, tokenType: r2, fontStyle: i2, foreground: o2, background: s3 });
+          }, e2.getLanguageId = function(e3) {
+            return (255 & e3) >>> 0;
+          }, e2.getTokenType = function(e3) {
+            return (1792 & e3) >>> 8;
+          }, e2.getFontStyle = function(e3) {
+            return (14336 & e3) >>> 11;
+          }, e2.getForeground = function(e3) {
+            return (8372224 & e3) >>> 14;
+          }, e2.getBackground = function(e3) {
+            return (4286578688 & e3) >>> 23;
+          }, e2.set = function(t2, n2, r2, i2, o2, s3) {
+            var a2 = e2.getLanguageId(t2), c2 = e2.getTokenType(t2), u3 = e2.getFontStyle(t2), l2 = e2.getForeground(t2), h3 = e2.getBackground(t2);
+            return n2 !== 0 && (a2 = n2), r2 !== 0 && (c2 = r2 === 8 ? 0 : r2), i2 !== -1 && (u3 = i2), o2 !== 0 && (l2 = o2), s3 !== 0 && (h3 = s3), (a2 << 0 | c2 << 8 | u3 << 11 | l2 << 14 | h3 << 23) >>> 0;
+          }, e2;
+        }();
+        t.StackElementMetadata = P;
+        var x = function() {
+          function e2(e3, t2, n2) {
+            this.parent = e3, this.scope = t2, this.metadata = n2;
+          }
+          return e2._equals = function(e3, t2) {
+            for (; ; ) {
+              if (e3 === t2)
+                return true;
+              if (!e3 && !t2)
+                return true;
+              if (!e3 || !t2)
+                return false;
+              if (e3.scope !== t2.scope || e3.metadata !== t2.metadata)
+                return false;
+              e3 = e3.parent, t2 = t2.parent;
+            }
+          }, e2.prototype.equals = function(t2) {
+            return e2._equals(this, t2);
+          }, e2._matchesScope = function(e3, t2, n2) {
+            return t2 === e3 || e3.substring(0, n2.length) === n2;
+          }, e2._matches = function(e3, t2) {
+            if (t2 === null)
+              return true;
+            for (var n2 = t2.length, r2 = 0, i2 = t2[r2], o2 = i2 + "."; e3; ) {
+              if (this._matchesScope(e3.scope, i2, o2)) {
+                if (++r2 === n2)
+                  return true;
+                o2 = (i2 = t2[r2]) + ".";
+              }
+              e3 = e3.parent;
+            }
+            return false;
+          }, e2.mergeMetadata = function(e3, t2, n2) {
+            if (n2 === null)
+              return e3;
+            var r2 = -1, i2 = 0, o2 = 0;
+            if (n2.themeData !== null)
+              for (var s3 = 0, a2 = n2.themeData.length; s3 < a2; s3++) {
+                var c2 = n2.themeData[s3];
+                if (this._matches(t2, c2.parentScopes)) {
+                  r2 = c2.fontStyle, i2 = c2.foreground, o2 = c2.background;
+                  break;
+                }
+              }
+            return P.set(e3, n2.languageId, n2.tokenType, r2, i2, o2);
+          }, e2._push = function(t2, n2, r2) {
+            for (var i2 = 0, o2 = r2.length; i2 < o2; i2++) {
+              var s3 = r2[i2], a2 = n2.getMetadataForScope(s3), c2 = e2.mergeMetadata(t2.metadata, t2, a2);
+              t2 = new e2(t2, s3, c2);
+            }
+            return t2;
+          }, e2.prototype.push = function(t2, n2) {
+            return n2 === null ? this : n2.indexOf(" ") >= 0 ? e2._push(this, t2, n2.split(/ /g)) : e2._push(this, t2, [n2]);
+          }, e2._generateScopes = function(e3) {
+            for (var t2 = [], n2 = 0; e3; )
+              t2[n2++] = e3.scope, e3 = e3.parent;
+            return t2.reverse(), t2;
+          }, e2.prototype.generateScopes = function() {
+            return e2._generateScopes(this);
+          }, e2;
+        }();
+        t.ScopeListElement = x;
+        var I = function() {
+          function e2(e3, t2, n2, r2, i2, o2, s3, a2) {
+            this.parent = e3, this.depth = this.parent ? this.parent.depth + 1 : 1, this.ruleId = t2, this._enterPos = n2, this._anchorPos = r2, this.beginRuleCapturedEOL = i2, this.endRule = o2, this.nameScopesList = s3, this.contentNameScopesList = a2;
+          }
+          return e2._structuralEquals = function(e3, t2) {
+            for (; ; ) {
+              if (e3 === t2)
+                return true;
+              if (!e3 && !t2)
+                return true;
+              if (!e3 || !t2)
+                return false;
+              if (e3.depth !== t2.depth || e3.ruleId !== t2.ruleId || e3.endRule !== t2.endRule)
+                return false;
+              e3 = e3.parent, t2 = t2.parent;
+            }
+          }, e2._equals = function(e3, t2) {
+            return e3 === t2 || !!this._structuralEquals(e3, t2) && e3.contentNameScopesList.equals(t2.contentNameScopesList);
+          }, e2.prototype.clone = function() {
+            return this;
+          }, e2.prototype.equals = function(t2) {
+            return t2 !== null && e2._equals(this, t2);
+          }, e2._reset = function(e3) {
+            for (; e3; )
+              e3._enterPos = -1, e3._anchorPos = -1, e3 = e3.parent;
+          }, e2.prototype.reset = function() {
+            e2._reset(this);
+          }, e2.prototype.pop = function() {
+            return this.parent;
+          }, e2.prototype.safePop = function() {
+            return this.parent ? this.parent : this;
+          }, e2.prototype.push = function(t2, n2, r2, i2, o2, s3, a2) {
+            return new e2(this, t2, n2, r2, i2, o2, s3, a2);
+          }, e2.prototype.getEnterPos = function() {
+            return this._enterPos;
+          }, e2.prototype.getAnchorPos = function() {
+            return this._anchorPos;
+          }, e2.prototype.getRule = function(e3) {
+            return e3.getRule(this.ruleId);
+          }, e2.prototype._writeString = function(e3, t2) {
+            return this.parent && (t2 = this.parent._writeString(e3, t2)), e3[t2++] = "(" + this.ruleId + ", TODO-" + this.nameScopesList + ", TODO-" + this.contentNameScopesList + ")", t2;
+          }, e2.prototype.toString = function() {
+            var e3 = [];
+            return this._writeString(e3, 0), "[" + e3.join(",") + "]";
+          }, e2.prototype.setContentNameScopesList = function(e3) {
+            return this.contentNameScopesList === e3 ? this : this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, e3);
+          }, e2.prototype.setEndRule = function(t2) {
+            return this.endRule === t2 ? this : new e2(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, t2, this.nameScopesList, this.contentNameScopesList);
+          }, e2.prototype.hasSameRuleAs = function(e3) {
+            return this.ruleId === e3.ruleId;
+          }, e2.NULL = new e2(null, 0, 0, 0, false, null, null, null), e2;
+        }();
+        t.StackElement = I;
+        var A = function(e2, t2) {
+          this.scopes = e2, this.endPos = t2;
+        };
+        t.LocalStackElement = A;
+        var T = function() {
+          function e2(e3, t2, n2) {
+            this._emitBinaryTokens = e3, this._tokenTypeOverrides = n2, s2.DebugFlags.InDebugMode ? this._lineText = t2 : this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
+          }
+          return e2.prototype.produce = function(e3, t2) {
+            this.produceFromScopes(e3.contentNameScopesList, t2);
+          }, e2.prototype.produceFromScopes = function(e3, t2) {
+            if (!(this._lastTokenEndIndex >= t2)) {
+              if (this._emitBinaryTokens) {
+                for (var n2 = e3.metadata, r2 = 0, i2 = this._tokenTypeOverrides; r2 < i2.length; r2++) {
+                  var o2 = i2[r2];
+                  o2.matcher(e3.generateScopes()) && (n2 = P.set(n2, 0, L(o2.type), -1, 0, 0));
+                }
+                return this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === n2 || (this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(n2)), void (this._lastTokenEndIndex = t2);
+              }
+              var a2 = e3.generateScopes();
+              if (s2.DebugFlags.InDebugMode) {
+                console.log("  token: |" + this._lineText.substring(this._lastTokenEndIndex, t2).replace(/\n$/, "\\n") + "|");
+                for (var c2 = 0; c2 < a2.length; c2++)
+                  console.log("      * " + a2[c2]);
+              }
+              this._tokens.push({ startIndex: this._lastTokenEndIndex, endIndex: t2, scopes: a2 }), this._lastTokenEndIndex = t2;
+            }
+          }, e2.prototype.getResult = function(e3, t2) {
+            return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t2 - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e3, t2), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
+          }, e2.prototype.getBinaryResult = function(e3, t2) {
+            this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t2 - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e3, t2), this._binaryTokens[this._binaryTokens.length - 2] = 0);
+            for (var n2 = new Uint32Array(this._binaryTokens.length), r2 = 0, i2 = this._binaryTokens.length; r2 < i2; r2++)
+              n2[r2] = this._binaryTokens[r2];
+            return n2;
+          }, e2;
+        }();
+        function L(e2) {
+          switch (e2) {
+            case 4:
+              return 4;
+            case 2:
+              return 2;
+            case 1:
+              return 1;
+            case 0:
+            default:
+              return 8;
+          }
+        }
+      }, function(e, t, n) {
+        "use strict";
+        function r(e2) {
+          return Array.isArray(e2) ? function(e3) {
+            for (var t2 = [], n2 = 0, i2 = e3.length; n2 < i2; n2++)
+              t2[n2] = r(e3[n2]);
+            return t2;
+          }(e2) : typeof e2 == "object" ? function(e3) {
+            var t2 = {};
+            for (var n2 in e3)
+              t2[n2] = r(e3[n2]);
+            return t2;
+          }(e2) : e2;
+        }
+        Object.defineProperty(t, "__esModule", { value: true }), t.clone = function(e2) {
+          return r(e2);
+        }, t.mergeObjects = function(e2) {
+          for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
+            t2[n2 - 1] = arguments[n2];
+          return t2.forEach(function(t3) {
+            for (var n3 in t3)
+              e2[n3] = t3[n3];
+          }), e2;
+        }, t.basename = function e2(t2) {
+          var n2 = ~t2.lastIndexOf("/") || ~t2.lastIndexOf("\\");
+          return n2 === 0 ? t2 : ~n2 == t2.length - 1 ? e2(t2.substring(0, t2.length - 1)) : t2.substr(1 + ~n2);
+        };
+        var i = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/, o = function() {
+          function e2() {
+          }
+          return e2.hasCaptures = function(e3) {
+            return e3 !== null && i.test(e3);
+          }, e2.replaceCaptures = function(e3, t2, n2) {
+            return e3.replace(i, function(e4, r2, i2, o2) {
+              var s2 = n2[parseInt(r2 || i2, 10)];
+              if (!s2)
+                return e4;
+              for (var a = t2.substring(s2.start, s2.end); a[0] === "."; )
+                a = a.substring(1);
+              switch (o2) {
+                case "downcase":
+                  return a.toLowerCase();
+                case "upcase":
+                  return a.toUpperCase();
+                default:
+                  return a;
+              }
+            });
+          }, e2;
+        }();
+        t.RegexSource = o;
+      }, function(e, t, n) {
+        "use strict";
+        (function(e2) {
+          Object.defineProperty(t, "__esModule", { value: true }), t.DebugFlags = { InDebugMode: e2 !== void 0 && !!e2.env.VSCODE_TEXTMATE_DEBUG };
+        }).call(this, n(7));
+      }, function(e, t, n) {
+        "use strict";
+        var r = this && this.__awaiter || function(e2, t2, n2, r2) {
+          return new (n2 || (n2 = Promise))(function(i2, o2) {
+            function s3(e3) {
+              try {
+                c2(r2.next(e3));
+              } catch (e4) {
+                o2(e4);
+              }
+            }
+            function a2(e3) {
+              try {
+                c2(r2.throw(e3));
+              } catch (e4) {
+                o2(e4);
+              }
+            }
+            function c2(e3) {
+              var t3;
+              e3.done ? i2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
+                e4(t3);
+              })).then(s3, a2);
+            }
+            c2((r2 = r2.apply(e2, t2 || [])).next());
+          });
+        }, i = this && this.__generator || function(e2, t2) {
+          var n2, r2, i2, o2, s3 = { label: 0, sent: function() {
+            if (1 & i2[0])
+              throw i2[1];
+            return i2[1];
+          }, trys: [], ops: [] };
+          return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
+            return this;
+          }), o2;
+          function a2(o3) {
+            return function(a3) {
+              return function(o4) {
+                if (n2)
+                  throw new TypeError("Generator is already executing.");
+                for (; s3; )
+                  try {
+                    if (n2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
+                      return i2;
+                    switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
+                      case 0:
+                      case 1:
+                        i2 = o4;
+                        break;
+                      case 4:
+                        return s3.label++, { value: o4[1], done: false };
+                      case 5:
+                        s3.label++, r2 = o4[1], o4 = [0];
+                        continue;
+                      case 7:
+                        o4 = s3.ops.pop(), s3.trys.pop();
+                        continue;
+                      default:
+                        if (!(i2 = s3.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
+                          s3 = 0;
+                          continue;
+                        }
+                        if (o4[0] === 3 && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
+                          s3.label = o4[1];
+                          break;
+                        }
+                        if (o4[0] === 6 && s3.label < i2[1]) {
+                          s3.label = i2[1], i2 = o4;
+                          break;
+                        }
+                        if (i2 && s3.label < i2[2]) {
+                          s3.label = i2[2], s3.ops.push(o4);
+                          break;
+                        }
+                        i2[2] && s3.ops.pop(), s3.trys.pop();
+                        continue;
+                    }
+                    o4 = t2.call(e2, s3);
+                  } catch (e3) {
+                    o4 = [6, e3], r2 = 0;
+                  } finally {
+                    n2 = i2 = 0;
+                  }
+                if (5 & o4[0])
+                  throw o4[1];
+                return { value: o4[0] ? o4[1] : void 0, done: true };
+              }([o3, a3]);
+            };
+          }
+        };
+        Object.defineProperty(t, "__esModule", { value: true });
+        var o = n(4), s2 = n(8), a = n(11), c = n(0), u2 = function() {
+          function e2(e3) {
+            this._options = e3, this._syncRegistry = new o.SyncRegistry(a.Theme.createFromRawTheme(e3.theme, e3.colorMap), e3.onigLib), this._ensureGrammarCache = /* @__PURE__ */ new Map();
+          }
+          return e2.prototype.dispose = function() {
+            this._syncRegistry.dispose();
+          }, e2.prototype.setTheme = function(e3, t2) {
+            this._syncRegistry.setTheme(a.Theme.createFromRawTheme(e3, t2));
+          }, e2.prototype.getColorMap = function() {
+            return this._syncRegistry.getColorMap();
+          }, e2.prototype.loadGrammarWithEmbeddedLanguages = function(e3, t2, n2) {
+            return this.loadGrammarWithConfiguration(e3, t2, { embeddedLanguages: n2 });
+          }, e2.prototype.loadGrammarWithConfiguration = function(e3, t2, n2) {
+            return this._loadGrammar(e3, t2, n2.embeddedLanguages, n2.tokenTypes);
+          }, e2.prototype.loadGrammar = function(e3) {
+            return this._loadGrammar(e3, 0, null, null);
+          }, e2.prototype._doLoadSingleGrammar = function(e3) {
+            return r(this, void 0, void 0, function() {
+              var t2, n2;
+              return i(this, function(r2) {
+                switch (r2.label) {
+                  case 0:
+                    return [4, this._options.loadGrammar(e3)];
+                  case 1:
+                    return (t2 = r2.sent()) && (n2 = typeof this._options.getInjections == "function" ? this._options.getInjections(e3) : void 0, this._syncRegistry.addGrammar(t2, n2)), [2];
+                }
+              });
+            });
+          }, e2.prototype._loadSingleGrammar = function(e3) {
+            return r(this, void 0, void 0, function() {
+              return i(this, function(t2) {
+                return this._ensureGrammarCache.has(e3) || this._ensureGrammarCache.set(e3, this._doLoadSingleGrammar(e3)), [2, this._ensureGrammarCache.get(e3)];
+              });
+            });
+          }, e2.prototype._collectDependenciesForDep = function(e3, t2, n2) {
+            var r2 = this._syncRegistry.lookup(n2.scopeName);
+            if (r2) {
+              n2 instanceof c.FullScopeDependency ? c.collectDependencies(t2, this._syncRegistry.lookup(e3), r2) : c.collectSpecificDependencies(t2, this._syncRegistry.lookup(e3), r2, n2.include);
+              var i2 = this._syncRegistry.injections(n2.scopeName);
+              if (i2)
+                for (var o2 = 0, s3 = i2; o2 < s3.length; o2++) {
+                  var a2 = s3[o2];
+                  t2.add(new c.FullScopeDependency(a2));
+                }
+            } else if (n2.scopeName === e3)
+              throw new Error("No grammar provided for <" + e3 + ">");
+          }, e2.prototype._loadGrammar = function(e3, t2, n2, o2) {
+            return r(this, void 0, void 0, function() {
+              var r2, s3, a2, u3, l, h2, p, f, d, g, m, _, y = this;
+              return i(this, function(i2) {
+                switch (i2.label) {
+                  case 0:
+                    r2 = /* @__PURE__ */ new Set(), s3 = /* @__PURE__ */ new Set(), r2.add(e3), a2 = [new c.FullScopeDependency(e3)], i2.label = 1;
+                  case 1:
+                    return a2.length > 0 ? (u3 = a2, a2 = [], [4, Promise.all(u3.map(function(e4) {
+                      return y._loadSingleGrammar(e4.scopeName);
+                    }))]) : [3, 3];
+                  case 2:
+                    for (i2.sent(), l = new c.ScopeDependencyCollector(), h2 = 0, p = u3; h2 < p.length; h2++)
+                      _ = p[h2], this._collectDependenciesForDep(e3, l, _);
+                    for (f = 0, d = l.full; f < d.length; f++)
+                      _ = d[f], r2.has(_.scopeName) || (r2.add(_.scopeName), a2.push(_));
+                    for (g = 0, m = l.partial; g < m.length; g++)
+                      _ = m[g], r2.has(_.scopeName) || s3.has(_.toKey()) || (s3.add(_.toKey()), a2.push(_));
+                    return [3, 1];
+                  case 3:
+                    return [2, this.grammarForScopeName(e3, t2, n2, o2)];
+                }
+              });
+            });
+          }, e2.prototype.addGrammar = function(e3, t2, n2, o2) {
+            return t2 === void 0 && (t2 = []), n2 === void 0 && (n2 = 0), o2 === void 0 && (o2 = null), r(this, void 0, void 0, function() {
+              return i(this, function(r2) {
+                switch (r2.label) {
+                  case 0:
+                    return this._syncRegistry.addGrammar(e3, t2), [4, this.grammarForScopeName(e3.scopeName, n2, o2)];
+                  case 1:
+                    return [2, r2.sent()];
+                }
+              });
+            });
+          }, e2.prototype.grammarForScopeName = function(e3, t2, n2, r2) {
+            return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = null), r2 === void 0 && (r2 = null), this._syncRegistry.grammarForScopeName(e3, t2, n2, r2);
+          }, e2;
+        }();
+        t.Registry = u2, t.INITIAL = c.StackElement.NULL, t.parseRawGrammar = s2.parseRawGrammar;
+      }, function(e, t, n) {
+        "use strict";
+        var r = this && this.__awaiter || function(e2, t2, n2, r2) {
+          return new (n2 || (n2 = Promise))(function(i2, o2) {
+            function s3(e3) {
+              try {
+                c(r2.next(e3));
+              } catch (e4) {
+                o2(e4);
+              }
+            }
+            function a(e3) {
+              try {
+                c(r2.throw(e3));
+              } catch (e4) {
+                o2(e4);
+              }
+            }
+            function c(e3) {
+              var t3;
+              e3.done ? i2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
+                e4(t3);
+              })).then(s3, a);
+            }
+            c((r2 = r2.apply(e2, t2 || [])).next());
+          });
+        }, i = this && this.__generator || function(e2, t2) {
+          var n2, r2, i2, o2, s3 = { label: 0, sent: function() {
+            if (1 & i2[0])
+              throw i2[1];
+            return i2[1];
+          }, trys: [], ops: [] };
+          return o2 = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
+            return this;
+          }), o2;
+          function a(o3) {
+            return function(a2) {
+              return function(o4) {
+                if (n2)
+                  throw new TypeError("Generator is already executing.");
+                for (; s3; )
+                  try {
+                    if (n2 = 1, r2 && (i2 = 2 & o4[0] ? r2.return : o4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, o4[1])).done)
+                      return i2;
+                    switch (r2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
+                      case 0:
+                      case 1:
+                        i2 = o4;
+                        break;
+                      case 4:
+                        return s3.label++, { value: o4[1], done: false };
+                      case 5:
+                        s3.label++, r2 = o4[1], o4 = [0];
+                        continue;
+                      case 7:
+                        o4 = s3.ops.pop(), s3.trys.pop();
+                        continue;
+                      default:
+                        if (!(i2 = s3.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
+                          s3 = 0;
+                          continue;
+                        }
+                        if (o4[0] === 3 && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
+                          s3.label = o4[1];
+                          break;
+                        }
+                        if (o4[0] === 6 && s3.label < i2[1]) {
+                          s3.label = i2[1], i2 = o4;
+                          break;
+                        }
+                        if (i2 && s3.label < i2[2]) {
+                          s3.label = i2[2], s3.ops.push(o4);
+                          break;
+                        }
+                        i2[2] && s3.ops.pop(), s3.trys.pop();
+                        continue;
+                    }
+                    o4 = t2.call(e2, s3);
+                  } catch (e3) {
+                    o4 = [6, e3], r2 = 0;
+                  } finally {
+                    n2 = i2 = 0;
+                  }
+                if (5 & o4[0])
+                  throw o4[1];
+                return { value: o4[0] ? o4[1] : void 0, done: true };
+              }([o3, a2]);
+            };
+          }
+        };
+        Object.defineProperty(t, "__esModule", { value: true });
+        var o = n(0), s2 = function() {
+          function e2(e3, t2) {
+            this._theme = e3, this._grammars = {}, this._rawGrammars = {}, this._injectionGrammars = {}, this._onigLibPromise = t2;
+          }
+          return e2.prototype.dispose = function() {
+            for (var e3 in this._grammars)
+              this._grammars.hasOwnProperty(e3) && this._grammars[e3].dispose();
+          }, e2.prototype.setTheme = function(e3) {
+            var t2 = this;
+            this._theme = e3, Object.keys(this._grammars).forEach(function(e4) {
+              t2._grammars[e4].onDidChangeTheme();
+            });
+          }, e2.prototype.getColorMap = function() {
+            return this._theme.getColorMap();
+          }, e2.prototype.addGrammar = function(e3, t2) {
+            this._rawGrammars[e3.scopeName] = e3, t2 && (this._injectionGrammars[e3.scopeName] = t2);
+          }, e2.prototype.lookup = function(e3) {
+            return this._rawGrammars[e3];
+          }, e2.prototype.injections = function(e3) {
+            return this._injectionGrammars[e3];
+          }, e2.prototype.getDefaults = function() {
+            return this._theme.getDefaults();
+          }, e2.prototype.themeMatch = function(e3) {
+            return this._theme.match(e3);
+          }, e2.prototype.grammarForScopeName = function(e3, t2, n2, s3) {
+            return r(this, void 0, void 0, function() {
+              var r2, a, c, u2, l;
+              return i(this, function(i2) {
+                switch (i2.label) {
+                  case 0:
+                    return this._grammars[e3] ? [3, 2] : (r2 = this._rawGrammars[e3]) ? (a = this._grammars, c = e3, u2 = o.createGrammar, l = [r2, t2, n2, s3, this], [4, this._onigLibPromise]) : [2, null];
+                  case 1:
+                    a[c] = u2.apply(void 0, l.concat([i2.sent()])), i2.label = 2;
+                  case 2:
+                    return [2, this._grammars[e3]];
+                }
+              });
+            });
+          }, e2;
+        }();
+        t.SyncRegistry = s2;
+      }, function(e, t, n) {
+        "use strict";
+        var r, i = this && this.__extends || (r = function(e2, t2) {
+          return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
+            e3.__proto__ = t3;
+          } || function(e3, t3) {
+            for (var n2 in t3)
+              t3.hasOwnProperty(n2) && (e3[n2] = t3[n2]);
+          })(e2, t2);
+        }, function(e2, t2) {
+          function n2() {
+            this.constructor = e2;
+          }
+          r(e2, t2), e2.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
+        });
+        Object.defineProperty(t, "__esModule", { value: true });
+        var o = n(1), s2 = /\\(\d+)/, a = /\\(\d+)/g, c = function() {
+          function e2(e3, t2, n2) {
+            this.debugRegExps = t2, this.rules = n2, this.scanner = e3.createOnigScanner(t2);
+          }
+          return e2.prototype.dispose = function() {
+            typeof this.scanner.dispose == "function" && this.scanner.dispose();
+          }, e2;
+        }();
+        t.CompiledRule = c;
+        var u2 = function() {
+          function e2(e3, t2, n2, r2) {
+            this.$location = e3, this.id = t2, this._name = n2 || null, this._nameIsCapturing = o.RegexSource.hasCaptures(this._name), this._contentName = r2 || null, this._contentNameIsCapturing = o.RegexSource.hasCaptures(this._contentName);
+          }
+          return Object.defineProperty(e2.prototype, "debugName", { get: function() {
+            var e3 = this.$location ? o.basename(this.$location.filename) + ":" + this.$location.line : "unknown";
+            return this.constructor.name + "#" + this.id + " @ " + e3;
+          }, enumerable: true, configurable: true }), e2.prototype.getName = function(e3, t2) {
+            return this._nameIsCapturing && this._name !== null && e3 !== null && t2 !== null ? o.RegexSource.replaceCaptures(this._name, e3, t2) : this._name;
+          }, e2.prototype.getContentName = function(e3, t2) {
+            return this._contentNameIsCapturing && this._contentName !== null ? o.RegexSource.replaceCaptures(this._contentName, e3, t2) : this._contentName;
+          }, e2;
+        }();
+        t.Rule = u2;
+        var l = function(e2) {
+          function t2(t3, n2, r2, i2, o2) {
+            var s3 = e2.call(this, t3, n2, r2, i2) || this;
+            return s3.retokenizeCapturedWithRuleId = o2, s3;
+          }
+          return i(t2, e2), t2.prototype.dispose = function() {
+          }, t2.prototype.collectPatternsRecursive = function(e3, t3, n2) {
+            throw new Error("Not supported!");
+          }, t2.prototype.compile = function(e3, t3, n2, r2) {
+            throw new Error("Not supported!");
+          }, t2;
+        }(u2);
+        t.CaptureRule = l;
+        var h2 = function() {
+          function e2(e3, t2, n2) {
+            if (n2 === void 0 && (n2 = true), n2)
+              if (e3) {
+                for (var r2 = e3.length, i2 = 0, o2 = [], a2 = false, c2 = 0; c2 < r2; c2++) {
+                  if (e3.charAt(c2) === "\\" && c2 + 1 < r2) {
+                    var u3 = e3.charAt(c2 + 1);
+                    u3 === "z" ? (o2.push(e3.substring(i2, c2)), o2.push("$(?!\\n)(?<!\\n)"), i2 = c2 + 2) : u3 !== "A" && u3 !== "G" || (a2 = true), c2++;
+                  }
+                }
+                this.hasAnchor = a2, i2 === 0 ? this.source = e3 : (o2.push(e3.substring(i2, r2)), this.source = o2.join(""));
+              } else
+                this.hasAnchor = false, this.source = e3;
+            else
+              this.hasAnchor = false, this.source = e3;
+            this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = t2, this.hasBackReferences = s2.test(this.source);
+          }
+          return e2.prototype.clone = function() {
+            return new e2(this.source, this.ruleId, true);
+          }, e2.prototype.setSource = function(e3) {
+            this.source !== e3 && (this.source = e3, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
+          }, e2.prototype.resolveBackReferences = function(e3, t2) {
+            var n2 = t2.map(function(t3) {
+              return e3.substring(t3.start, t3.end);
+            });
+            return a.lastIndex = 0, this.source.replace(a, function(e4, t3) {
+              return (n2[parseInt(t3, 10)] || "").replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
+            });
+          }, e2.prototype._buildAnchorCache = function() {
+            var e3, t2, n2, r2, i2 = [], o2 = [], s3 = [], a2 = [];
+            for (e3 = 0, t2 = this.source.length; e3 < t2; e3++)
+              n2 = this.source.charAt(e3), i2[e3] = n2, o2[e3] = n2, s3[e3] = n2, a2[e3] = n2, n2 === "\\" && e3 + 1 < t2 && ((r2 = this.source.charAt(e3 + 1)) === "A" ? (i2[e3 + 1] = "\uFFFF", o2[e3 + 1] = "\uFFFF", s3[e3 + 1] = "A", a2[e3 + 1] = "A") : r2 === "G" ? (i2[e3 + 1] = "\uFFFF", o2[e3 + 1] = "G", s3[e3 + 1] = "\uFFFF", a2[e3 + 1] = "G") : (i2[e3 + 1] = r2, o2[e3 + 1] = r2, s3[e3 + 1] = r2, a2[e3 + 1] = r2), e3++);
+            return { A0_G0: i2.join(""), A0_G1: o2.join(""), A1_G0: s3.join(""), A1_G1: a2.join("") };
+          }, e2.prototype.resolveAnchors = function(e3, t2) {
+            return this.hasAnchor && this._anchorCache ? e3 ? t2 ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : t2 ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0 : this.source;
+          }, e2;
+        }();
+        t.RegExpSource = h2;
+        var p = function() {
+          function e2() {
+            this._items = [], this._hasAnchors = false, this._cached = null, this._anchorCache = { A0_G0: null, A0_G1: null, A1_G0: null, A1_G1: null };
+          }
+          return e2.prototype.dispose = function() {
+            this._disposeCaches();
+          }, e2.prototype._disposeCaches = function() {
+            this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
+          }, e2.prototype.push = function(e3) {
+            this._items.push(e3), this._hasAnchors = this._hasAnchors || e3.hasAnchor;
+          }, e2.prototype.unshift = function(e3) {
+            this._items.unshift(e3), this._hasAnchors = this._hasAnchors || e3.hasAnchor;
+          }, e2.prototype.length = function() {
+            return this._items.length;
+          }, e2.prototype.setSource = function(e3, t2) {
+            this._items[e3].source !== t2 && (this._disposeCaches(), this._items[e3].setSource(t2));
+          }, e2.prototype.compile = function(e3, t2, n2) {
+            if (this._hasAnchors)
+              return t2 ? n2 ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e3, t2, n2)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e3, t2, n2)), this._anchorCache.A1_G0) : n2 ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e3, t2, n2)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e3, t2, n2)), this._anchorCache.A0_G0);
+            if (!this._cached) {
+              var r2 = this._items.map(function(e4) {
+                return e4.source;
+              });
+              this._cached = new c(e3, r2, this._items.map(function(e4) {
+                return e4.ruleId;
+              }));
+            }
+            return this._cached;
+          }, e2.prototype._resolveAnchors = function(e3, t2, n2) {
+            var r2 = this._items.map(function(e4) {
+              return e4.resolveAnchors(t2, n2);
+            });
+            return new c(e3, r2, this._items.map(function(e4) {
+              return e4.ruleId;
+            }));
+          }, e2;
+        }();
+        t.RegExpSourceList = p;
+        var f = function(e2) {
+          function t2(t3, n2, r2, i2, o2) {
+            var s3 = e2.call(this, t3, n2, r2, null) || this;
+            return s3._match = new h2(i2, s3.id), s3.captures = o2, s3._cachedCompiledPatterns = null, s3;
+          }
+          return i(t2, e2), t2.prototype.dispose = function() {
+            this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
+          }, Object.defineProperty(t2.prototype, "debugMatchRegExp", { get: function() {
+            return "" + this._match.source;
+          }, enumerable: true, configurable: true }), t2.prototype.collectPatternsRecursive = function(e3, t3, n2) {
+            t3.push(this._match);
+          }, t2.prototype.compile = function(e3, t3, n2, r2) {
+            return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p(), this.collectPatternsRecursive(e3, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e3, n2, r2);
+          }, t2;
+        }(u2);
+        t.MatchRule = f;
+        var d = function(e2) {
+          function t2(t3, n2, r2, i2, o2) {
+            var s3 = e2.call(this, t3, n2, r2, i2) || this;
+            return s3.patterns = o2.patterns, s3.hasMissingPatterns = o2.hasMissingPatterns, s3._cachedCompiledPatterns = null, s3;
+          }
+          return i(t2, e2), t2.prototype.dispose = function() {
+            this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
+          }, t2.prototype.collectPatternsRecursive = function(e3, t3, n2) {
+            var r2, i2;
+            for (r2 = 0, i2 = this.patterns.length; r2 < i2; r2++)
+              e3.getRule(this.patterns[r2]).collectPatternsRecursive(e3, t3, false);
+          }, t2.prototype.compile = function(e3, t3, n2, r2) {
+            return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p(), this.collectPatternsRecursive(e3, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e3, n2, r2);
+          }, t2;
+        }(u2);
+        t.IncludeOnlyRule = d;
+        var g = function(e2) {
+          function t2(t3, n2, r2, i2, o2, s3, a2, c2, u3, l2) {
+            var p2 = e2.call(this, t3, n2, r2, i2) || this;
+            return p2._begin = new h2(o2, p2.id), p2.beginCaptures = s3, p2._end = new h2(a2 || "\uFFFF", -1), p2.endHasBackReferences = p2._end.hasBackReferences, p2.endCaptures = c2, p2.applyEndPatternLast = u3 || false, p2.patterns = l2.patterns, p2.hasMissingPatterns = l2.hasMissingPatterns, p2._cachedCompiledPatterns = null, p2;
+          }
+          return i(t2, e2), t2.prototype.dispose = function() {
+            this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
+          }, Object.defineProperty(t2.prototype, "debugBeginRegExp", { get: function() {
+            return "" + this._begin.source;
+          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "debugEndRegExp", { get: function() {
+            return "" + this._end.source;
+          }, enumerable: true, configurable: true }), t2.prototype.getEndWithResolvedBackReferences = function(e3, t3) {
+            return this._end.resolveBackReferences(e3, t3);
+          }, t2.prototype.collectPatternsRecursive = function(e3, t3, n2) {
+            if (n2) {
+              var r2, i2 = void 0;
+              for (i2 = 0, r2 = this.patterns.length; i2 < r2; i2++)
+                e3.getRule(this.patterns[i2]).collectPatternsRecursive(e3, t3, false);
+            } else
+              t3.push(this._begin);
+          }, t2.prototype.compile = function(e3, t3, n2, r2) {
+            return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p(), this.collectPatternsRecursive(e3, this._cachedCompiledPatterns, true), this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end)), this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, t3) : this._cachedCompiledPatterns.setSource(0, t3)), this._cachedCompiledPatterns.compile(e3, n2, r2);
+          }, t2;
+        }(u2);
+        t.BeginEndRule = g;
+        var m = function(e2) {
+          function t2(t3, n2, r2, i2, o2, s3, a2, c2, u3) {
+            var l2 = e2.call(this, t3, n2, r2, i2) || this;
+            return l2._begin = new h2(o2, l2.id), l2.beginCaptures = s3, l2.whileCaptures = c2, l2._while = new h2(a2, -2), l2.whileHasBackReferences = l2._while.hasBackReferences, l2.patterns = u3.patterns, l2.hasMissingPatterns = u3.hasMissingPatterns, l2._cachedCompiledPatterns = null, l2._cachedCompiledWhilePatterns = null, l2;
+          }
+          return i(t2, e2), t2.prototype.dispose = function() {
+            this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
+          }, Object.defineProperty(t2.prototype, "debugBeginRegExp", { get: function() {
+            return "" + this._begin.source;
+          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "debugWhileRegExp", { get: function() {
+            return "" + this._while.source;
+          }, enumerable: true, configurable: true }), t2.prototype.getWhileWithResolvedBackReferences = function(e3, t3) {
+            return this._while.resolveBackReferences(e3, t3);
+          }, t2.prototype.collectPatternsRecursive = function(e3, t3, n2) {
+            if (n2) {
+              var r2, i2 = void 0;
+              for (i2 = 0, r2 = this.patterns.length; i2 < r2; i2++)
+                e3.getRule(this.patterns[i2]).collectPatternsRecursive(e3, t3, false);
+            } else
+              t3.push(this._begin);
+          }, t2.prototype.compile = function(e3, t3, n2, r2) {
+            return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p(), this.collectPatternsRecursive(e3, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e3, n2, r2);
+          }, t2.prototype.compileWhile = function(e3, t3, n2, r2) {
+            return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new p(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, t3 || "\uFFFF"), this._cachedCompiledWhilePatterns.compile(e3, n2, r2);
+          }, t2;
+        }(u2);
+        t.BeginWhileRule = m;
+        var _ = function() {
+          function e2() {
+          }
+          return e2.createCaptureRule = function(e3, t2, n2, r2, i2) {
+            return e3.registerRule(function(e4) {
+              return new l(t2, e4, n2, r2, i2);
+            });
+          }, e2.getCompiledRuleId = function(t2, n2, r2) {
+            return t2.id || n2.registerRule(function(i2) {
+              if (t2.id = i2, t2.match)
+                return new f(t2.$vscodeTextmateLocation, t2.id, t2.name, t2.match, e2._compileCaptures(t2.captures, n2, r2));
+              if (t2.begin === void 0) {
+                t2.repository && (r2 = o.mergeObjects({}, r2, t2.repository));
+                var s3 = t2.patterns;
+                return s3 === void 0 && t2.include && (s3 = [{ include: t2.include }]), new d(t2.$vscodeTextmateLocation, t2.id, t2.name, t2.contentName, e2._compilePatterns(s3, n2, r2));
+              }
+              return t2.while ? new m(t2.$vscodeTextmateLocation, t2.id, t2.name, t2.contentName, t2.begin, e2._compileCaptures(t2.beginCaptures || t2.captures, n2, r2), t2.while, e2._compileCaptures(t2.whileCaptures || t2.captures, n2, r2), e2._compilePatterns(t2.patterns, n2, r2)) : new g(t2.$vscodeTextmateLocation, t2.id, t2.name, t2.contentName, t2.begin, e2._compileCaptures(t2.beginCaptures || t2.captures, n2, r2), t2.end, e2._compileCaptures(t2.endCaptures || t2.captures, n2, r2), t2.applyEndPatternLast, e2._compilePatterns(t2.patterns, n2, r2));
+            }), t2.id;
+          }, e2._compileCaptures = function(t2, n2, r2) {
+            var i2 = [];
+            if (t2) {
+              var o2 = 0;
+              for (var s3 in t2) {
+                if (s3 !== "$vscodeTextmateLocation")
+                  (c2 = parseInt(s3, 10)) > o2 && (o2 = c2);
+              }
+              for (var a2 = 0; a2 <= o2; a2++)
+                i2[a2] = null;
+              for (var s3 in t2)
+                if (s3 !== "$vscodeTextmateLocation") {
+                  var c2 = parseInt(s3, 10), u3 = 0;
+                  t2[s3].patterns && (u3 = e2.getCompiledRuleId(t2[s3], n2, r2)), i2[c2] = e2.createCaptureRule(n2, t2[s3].$vscodeTextmateLocation, t2[s3].name, t2[s3].contentName, u3);
+                }
+            }
+            return i2;
+          }, e2._compilePatterns = function(t2, n2, r2) {
+            var i2 = [];
+            if (t2)
+              for (var o2 = 0, s3 = t2.length; o2 < s3; o2++) {
+                var a2 = t2[o2], c2 = -1;
+                if (a2.include)
+                  if (a2.include.charAt(0) === "#") {
+                    var u3 = r2[a2.include.substr(1)];
+                    u3 && (c2 = e2.getCompiledRuleId(u3, n2, r2));
+                  } else if (a2.include === "$base" || a2.include === "$self")
+                    c2 = e2.getCompiledRuleId(r2[a2.include], n2, r2);
+                  else {
+                    var l2 = null, h3 = null, p2 = a2.include.indexOf("#");
+                    p2 >= 0 ? (l2 = a2.include.substring(0, p2), h3 = a2.include.substring(p2 + 1)) : l2 = a2.include;
+                    var f2 = n2.getExternalGrammar(l2, r2);
+                    if (f2)
+                      if (h3) {
+                        var _2 = f2.repository[h3];
+                        _2 && (c2 = e2.getCompiledRuleId(_2, n2, f2.repository));
+                      } else
+                        c2 = e2.getCompiledRuleId(f2.repository.$self, n2, f2.repository);
+                  }
+                else
+                  c2 = e2.getCompiledRuleId(a2, n2, r2);
+                if (c2 !== -1) {
+                  var y = n2.getRule(c2), v = false;
+                  if ((y instanceof d || y instanceof g || y instanceof m) && y.hasMissingPatterns && y.patterns.length === 0 && (v = true), v)
+                    continue;
+                  i2.push(c2);
+                }
+              }
+            return { patterns: i2, hasMissingPatterns: (t2 ? t2.length : 0) !== i2.length };
+          }, e2;
+        }();
+        t.RuleFactory = _;
+      }, function(e, t, n) {
+        "use strict";
+        function r(e2) {
+          return !!e2 && !!e2.match(/[\w\.:]+/);
+        }
+        Object.defineProperty(t, "__esModule", { value: true }), t.createMatchers = function(e2, t2) {
+          for (var n2, i, o, s2 = [], a = (o = (i = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g).exec(n2 = e2), { next: function() {
+            if (!o)
+              return null;
+            var e3 = o[0];
+            return o = i.exec(n2), e3;
+          } }), c = a.next(); c !== null; ) {
+            var u2 = 0;
+            if (c.length === 2 && c.charAt(1) === ":") {
+              switch (c.charAt(0)) {
+                case "R":
+                  u2 = 1;
+                  break;
+                case "L":
+                  u2 = -1;
+                  break;
+                default:
+                  console.log("Unknown priority " + c + " in scope selector");
+              }
+              c = a.next();
+            }
+            var l = p();
+            if (s2.push({ matcher: l, priority: u2 }), c !== ",")
+              break;
+            c = a.next();
+          }
+          return s2;
+          function h2() {
+            if (c === "-") {
+              c = a.next();
+              var e3 = h2();
+              return function(t3) {
+                return !!e3 && !e3(t3);
+              };
+            }
+            if (c === "(") {
+              c = a.next();
+              var n3 = function() {
+                var e4 = [], t3 = p();
+                for (; t3 && (e4.push(t3), c === "|" || c === ","); ) {
+                  do {
+                    c = a.next();
+                  } while (c === "|" || c === ",");
+                  t3 = p();
+                }
+                return function(t4) {
+                  return e4.some(function(e5) {
+                    return e5(t4);
+                  });
+                };
+              }();
+              return c === ")" && (c = a.next()), n3;
+            }
+            if (r(c)) {
+              var i2 = [];
+              do {
+                i2.push(c), c = a.next();
+              } while (r(c));
+              return function(e4) {
+                return t2(i2, e4);
+              };
+            }
+            return null;
+          }
+          function p() {
+            for (var e3 = [], t3 = h2(); t3; )
+              e3.push(t3), t3 = h2();
+            return function(t4) {
+              return e3.every(function(e4) {
+                return e4(t4);
+              });
+            };
+          }
+        };
+      }, function(e, t) {
+        var n, r, i = e.exports = {};
+        function o() {
+          throw new Error("setTimeout has not been defined");
+        }
+        function s2() {
+          throw new Error("clearTimeout has not been defined");
+        }
+        function a(e2) {
+          if (n === setTimeout)
+            return setTimeout(e2, 0);
+          if ((n === o || !n) && setTimeout)
+            return n = setTimeout, setTimeout(e2, 0);
+          try {
+            return n(e2, 0);
+          } catch (t2) {
+            try {
+              return n.call(null, e2, 0);
+            } catch (t3) {
+              return n.call(this, e2, 0);
+            }
+          }
+        }
+        !function() {
+          try {
+            n = typeof setTimeout == "function" ? setTimeout : o;
+          } catch (e2) {
+            n = o;
+          }
+          try {
+            r = typeof clearTimeout == "function" ? clearTimeout : s2;
+          } catch (e2) {
+            r = s2;
+          }
+        }();
+        var c, u2 = [], l = false, h2 = -1;
+        function p() {
+          l && c && (l = false, c.length ? u2 = c.concat(u2) : h2 = -1, u2.length && f());
+        }
+        function f() {
+          if (!l) {
+            var e2 = a(p);
+            l = true;
+            for (var t2 = u2.length; t2; ) {
+              for (c = u2, u2 = []; ++h2 < t2; )
+                c && c[h2].run();
+              h2 = -1, t2 = u2.length;
+            }
+            c = null, l = false, function(e3) {
+              if (r === clearTimeout)
+                return clearTimeout(e3);
+              if ((r === s2 || !r) && clearTimeout)
+                return r = clearTimeout, clearTimeout(e3);
+              try {
+                r(e3);
+              } catch (t3) {
+                try {
+                  return r.call(null, e3);
+                } catch (t4) {
+                  return r.call(this, e3);
+                }
+              }
+            }(e2);
+          }
+        }
+        function d(e2, t2) {
+          this.fun = e2, this.array = t2;
+        }
+        function g() {
+        }
+        i.nextTick = function(e2) {
+          var t2 = new Array(arguments.length - 1);
+          if (arguments.length > 1)
+            for (var n2 = 1; n2 < arguments.length; n2++)
+              t2[n2 - 1] = arguments[n2];
+          u2.push(new d(e2, t2)), u2.length !== 1 || l || a(f);
+        }, d.prototype.run = function() {
+          this.fun.apply(null, this.array);
+        }, i.title = "browser", i.browser = true, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function(e2) {
+          return [];
+        }, i.binding = function(e2) {
+          throw new Error("process.binding is not supported");
+        }, i.cwd = function() {
+          return "/";
+        }, i.chdir = function(e2) {
+          throw new Error("process.chdir is not supported");
+        }, i.umask = function() {
+          return 0;
+        };
+      }, function(e, t, n) {
+        "use strict";
+        Object.defineProperty(t, "__esModule", { value: true });
+        var r = n(9), i = n(2), o = n(10);
+        t.parseRawGrammar = function(e2, t2) {
+          return t2 === void 0 && (t2 = null), t2 !== null && /\.json$/.test(t2) ? function(e3, t3) {
+            if (i.DebugFlags.InDebugMode)
+              return o.parse(e3, t3, true);
+            return JSON.parse(e3);
+          }(e2, t2) : function(e3, t3) {
+            if (i.DebugFlags.InDebugMode)
+              return r.parseWithLocation(e3, t3, "$vscodeTextmateLocation");
+            return r.parse(e3);
+          }(e2, t2);
+        };
+      }, function(e, t, n) {
+        "use strict";
+        function r(e2, t2, n2) {
+          var r2 = e2.length, i = 0, o = 1, s2 = 0;
+          function a(t3) {
+            if (n2 === null)
+              i += t3;
+            else
+              for (; t3 > 0; ) {
+                e2.charCodeAt(i) === 10 ? (i++, o++, s2 = 0) : (i++, s2++), t3--;
+              }
+          }
+          function c(e3) {
+            n2 === null ? i = e3 : a(e3 - i);
+          }
+          function u2() {
+            for (; i < r2; ) {
+              var t3 = e2.charCodeAt(i);
+              if (t3 !== 32 && t3 !== 9 && t3 !== 13 && t3 !== 10)
+                break;
+              a(1);
+            }
+          }
+          function l(t3) {
+            return e2.substr(i, t3.length) === t3 && (a(t3.length), true);
+          }
+          function h2(t3) {
+            var n3 = e2.indexOf(t3, i);
+            c(n3 !== -1 ? n3 + t3.length : r2);
+          }
+          function p(t3) {
+            var n3 = e2.indexOf(t3, i);
+            if (n3 !== -1) {
+              var o2 = e2.substring(i, n3);
+              return c(n3 + t3.length), o2;
+            }
+            o2 = e2.substr(i);
+            return c(r2), o2;
+          }
+          r2 > 0 && e2.charCodeAt(0) === 65279 && (i = 1);
+          var f = 0, d = null, g = [], m = [], _ = null;
+          function y(e3, t3) {
+            g.push(f), m.push(d), f = e3, d = t3;
+          }
+          function v() {
+            if (g.length === 0)
+              return b("illegal state stack");
+            f = g.pop(), d = m.pop();
+          }
+          function b(t3) {
+            throw new Error("Near offset " + i + ": " + t3 + " ~~~" + e2.substr(i, 50) + "~~~");
+          }
+          var C, w, k, R = function() {
+            if (_ === null)
+              return b("missing <key>");
+            var e3 = {};
+            n2 !== null && (e3[n2] = { filename: t2, line: o, char: s2 }), d[_] = e3, _ = null, y(1, e3);
+          }, S = function() {
+            if (_ === null)
+              return b("missing <key>");
+            var e3 = [];
+            d[_] = e3, _ = null, y(2, e3);
+          }, P = function() {
+            var e3 = {};
+            n2 !== null && (e3[n2] = { filename: t2, line: o, char: s2 }), d.push(e3), y(1, e3);
+          }, x = function() {
+            var e3 = [];
+            d.push(e3), y(2, e3);
+          };
+          function I() {
+            if (f !== 1)
+              return b("unexpected </dict>");
+            v();
+          }
+          function A() {
+            return f === 1 || f !== 2 ? b("unexpected </array>") : void v();
+          }
+          function T(e3) {
+            if (f === 1) {
+              if (_ === null)
+                return b("missing <key>");
+              d[_] = e3, _ = null;
+            } else
+              f === 2 ? d.push(e3) : d = e3;
+          }
+          function L(e3) {
+            if (isNaN(e3))
+              return b("cannot parse float");
+            if (f === 1) {
+              if (_ === null)
+                return b("missing <key>");
+              d[_] = e3, _ = null;
+            } else
+              f === 2 ? d.push(e3) : d = e3;
+          }
+          function M(e3) {
+            if (isNaN(e3))
+              return b("cannot parse integer");
+            if (f === 1) {
+              if (_ === null)
+                return b("missing <key>");
+              d[_] = e3, _ = null;
+            } else
+              f === 2 ? d.push(e3) : d = e3;
+          }
+          function G(e3) {
+            if (f === 1) {
+              if (_ === null)
+                return b("missing <key>");
+              d[_] = e3, _ = null;
+            } else
+              f === 2 ? d.push(e3) : d = e3;
+          }
+          function D(e3) {
+            if (f === 1) {
+              if (_ === null)
+                return b("missing <key>");
+              d[_] = e3, _ = null;
+            } else
+              f === 2 ? d.push(e3) : d = e3;
+          }
+          function N(e3) {
+            if (f === 1) {
+              if (_ === null)
+                return b("missing <key>");
+              d[_] = e3, _ = null;
+            } else
+              f === 2 ? d.push(e3) : d = e3;
+          }
+          function E(e3) {
+            if (e3.isClosed)
+              return "";
+            var t3 = p("</");
+            return h2(">"), t3.replace(/&#([0-9]+);/g, function(e4, t4) {
+              return String.fromCodePoint(parseInt(t4, 10));
+            }).replace(/&#x([0-9a-f]+);/g, function(e4, t4) {
+              return String.fromCodePoint(parseInt(t4, 16));
+            }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function(e4) {
+              switch (e4) {
+                case "&amp;":
+                  return "&";
+                case "&lt;":
+                  return "<";
+                case "&gt;":
+                  return ">";
+                case "&quot;":
+                  return '"';
+                case "&apos;":
+                  return "'";
+              }
+              return e4;
+            });
+          }
+          for (; i < r2 && (u2(), !(i >= r2)); ) {
+            var O = e2.charCodeAt(i);
+            if (a(1), O !== 60)
+              return b("expected <");
+            if (i >= r2)
+              return b("unexpected end of input");
+            var j = e2.charCodeAt(i);
+            if (j !== 63)
+              if (j !== 33) {
+                if (j === 47) {
+                  if (a(1), u2(), l("plist")) {
+                    h2(">");
+                    continue;
+                  }
+                  if (l("dict")) {
+                    h2(">"), I();
+                    continue;
+                  }
+                  if (l("array")) {
+                    h2(">"), A();
+                    continue;
+                  }
+                  return b("unexpected closed tag");
+                }
+                var F = (w = void 0, k = void 0, w = p(">"), k = false, w.charCodeAt(w.length - 1) === 47 && (k = true, w = w.substring(0, w.length - 1)), { name: w.trim(), isClosed: k });
+                switch (F.name) {
+                  case "dict":
+                    f === 1 ? R() : f === 2 ? P() : (d = {}, n2 !== null && (d[n2] = { filename: t2, line: o, char: s2 }), y(1, d)), F.isClosed && I();
+                    continue;
+                  case "array":
+                    f === 1 ? S() : f === 2 ? x() : y(2, d = []), F.isClosed && A();
+                    continue;
+                  case "key":
+                    C = E(F), f !== 1 ? b("unexpected <key>") : _ !== null ? b("too many <key>") : _ = C;
+                    continue;
+                  case "string":
+                    T(E(F));
+                    continue;
+                  case "real":
+                    L(parseFloat(E(F)));
+                    continue;
+                  case "integer":
+                    M(parseInt(E(F), 10));
+                    continue;
+                  case "date":
+                    G(new Date(E(F)));
+                    continue;
+                  case "data":
+                    D(E(F));
+                    continue;
+                  case "true":
+                    E(F), N(true);
+                    continue;
+                  case "false":
+                    E(F), N(false);
+                    continue;
+                }
+                if (!/^plist/.test(F.name))
+                  return b("unexpected opened tag " + F.name);
+              } else {
+                if (a(1), l("--")) {
+                  h2("-->");
+                  continue;
+                }
+                h2(">");
+              }
+            else
+              a(1), h2("?>");
+          }
+          return d;
+        }
+        Object.defineProperty(t, "__esModule", { value: true }), t.parseWithLocation = function(e2, t2, n2) {
+          return r(e2, t2, n2);
+        }, t.parse = function(e2) {
+          return r(e2, null, null);
+        };
+      }, function(e, t, n) {
+        "use strict";
+        function r(e2, t2) {
+          throw new Error("Near offset " + e2.pos + ": " + t2 + " ~~~" + e2.source.substr(e2.pos, 50) + "~~~");
+        }
+        Object.defineProperty(t, "__esModule", { value: true }), t.parse = function(e2, t2, n2) {
+          var a = new i(e2), c = new o(), u2 = 0, l = null, h2 = [], p = [];
+          function f() {
+            h2.push(u2), p.push(l);
+          }
+          function d() {
+            u2 = h2.pop(), l = p.pop();
+          }
+          function g(e3) {
+            r(a, e3);
+          }
+          for (; s2(a, c); ) {
+            if (u2 === 0) {
+              if (l !== null && g("too many constructs in root"), c.type === 3) {
+                l = {}, n2 && (l.$vscodeTextmateLocation = c.toLocation(t2)), f(), u2 = 1;
+                continue;
+              }
+              if (c.type === 2) {
+                l = [], f(), u2 = 4;
+                continue;
+              }
+              g("unexpected token in root");
+            }
+            if (u2 === 2) {
+              if (c.type === 5) {
+                d();
+                continue;
+              }
+              if (c.type === 7) {
+                u2 = 3;
+                continue;
+              }
+              g("expected , or }");
+            }
+            if (u2 === 1 || u2 === 3) {
+              if (u2 === 1 && c.type === 5) {
+                d();
+                continue;
+              }
+              if (c.type === 1) {
+                var m = c.value;
+                if (s2(a, c) && c.type === 6 || g("expected colon"), s2(a, c) || g("expected value"), u2 = 2, c.type === 1) {
+                  l[m] = c.value;
+                  continue;
+                }
+                if (c.type === 8) {
+                  l[m] = null;
+                  continue;
+                }
+                if (c.type === 9) {
+                  l[m] = true;
+                  continue;
+                }
+                if (c.type === 10) {
+                  l[m] = false;
+                  continue;
+                }
+                if (c.type === 11) {
+                  l[m] = parseFloat(c.value);
+                  continue;
+                }
+                if (c.type === 2) {
+                  var _ = [];
+                  l[m] = _, f(), u2 = 4, l = _;
+                  continue;
+                }
+                if (c.type === 3) {
+                  var y = {};
+                  n2 && (y.$vscodeTextmateLocation = c.toLocation(t2)), l[m] = y, f(), u2 = 1, l = y;
+                  continue;
+                }
+              }
+              g("unexpected token in dict");
+            }
+            if (u2 === 5) {
+              if (c.type === 4) {
+                d();
+                continue;
+              }
+              if (c.type === 7) {
+                u2 = 6;
+                continue;
+              }
+              g("expected , or ]");
+            }
+            if (u2 === 4 || u2 === 6) {
+              if (u2 === 4 && c.type === 4) {
+                d();
+                continue;
+              }
+              if (u2 = 5, c.type === 1) {
+                l.push(c.value);
+                continue;
+              }
+              if (c.type === 8) {
+                l.push(null);
+                continue;
+              }
+              if (c.type === 9) {
+                l.push(true);
+                continue;
+              }
+              if (c.type === 10) {
+                l.push(false);
+                continue;
+              }
+              if (c.type === 11) {
+                l.push(parseFloat(c.value));
+                continue;
+              }
+              if (c.type === 2) {
+                _ = [];
+                l.push(_), f(), u2 = 4, l = _;
+                continue;
+              }
+              if (c.type === 3) {
+                y = {};
+                n2 && (y.$vscodeTextmateLocation = c.toLocation(t2)), l.push(y), f(), u2 = 1, l = y;
+                continue;
+              }
+              g("unexpected token in array");
+            }
+            g("unknown state");
+          }
+          return p.length !== 0 && g("unclosed constructs"), l;
+        };
+        var i = function(e2) {
+          this.source = e2, this.pos = 0, this.len = e2.length, this.line = 1, this.char = 0;
+        }, o = function() {
+          function e2() {
+            this.value = null, this.type = 0, this.offset = -1, this.len = -1, this.line = -1, this.char = -1;
+          }
+          return e2.prototype.toLocation = function(e3) {
+            return { filename: e3, line: this.line, char: this.char };
+          }, e2;
+        }();
+        function s2(e2, t2) {
+          t2.value = null, t2.type = 0, t2.offset = -1, t2.len = -1, t2.line = -1, t2.char = -1;
+          for (var n2, i2 = e2.source, o2 = e2.pos, s3 = e2.len, a = e2.line, c = e2.char; ; ) {
+            if (o2 >= s3)
+              return false;
+            if ((n2 = i2.charCodeAt(o2)) !== 32 && n2 !== 9 && n2 !== 13) {
+              if (n2 !== 10)
+                break;
+              o2++, a++, c = 0;
+            } else
+              o2++, c++;
+          }
+          if (t2.offset = o2, t2.line = a, t2.char = c, n2 === 34) {
+            for (t2.type = 1, o2++, c++; ; ) {
+              if (o2 >= s3)
+                return false;
+              if (n2 = i2.charCodeAt(o2), o2++, c++, n2 !== 92) {
+                if (n2 === 34)
+                  break;
+              } else
+                o2++, c++;
+            }
+            t2.value = i2.substring(t2.offset + 1, o2 - 1).replace(/\\u([0-9A-Fa-f]{4})/g, function(e3, t3) {
+              return String.fromCodePoint(parseInt(t3, 16));
+            }).replace(/\\(.)/g, function(t3, n3) {
+              switch (n3) {
+                case '"':
+                  return '"';
+                case "\\":
+                  return "\\";
+                case "/":
+                  return "/";
+                case "b":
+                  return "\b";
+                case "f":
+                  return "\f";
+                case "n":
+                  return "\n";
+                case "r":
+                  return "\r";
+                case "t":
+                  return "	";
+                default:
+                  r(e2, "invalid escape sequence");
+              }
+              throw new Error("unreachable");
+            });
+          } else if (n2 === 91)
+            t2.type = 2, o2++, c++;
+          else if (n2 === 123)
+            t2.type = 3, o2++, c++;
+          else if (n2 === 93)
+            t2.type = 4, o2++, c++;
+          else if (n2 === 125)
+            t2.type = 5, o2++, c++;
+          else if (n2 === 58)
+            t2.type = 6, o2++, c++;
+          else if (n2 === 44)
+            t2.type = 7, o2++, c++;
+          else if (n2 === 110) {
+            if (t2.type = 8, o2++, c++, (n2 = i2.charCodeAt(o2)) !== 117)
+              return false;
+            if (o2++, c++, (n2 = i2.charCodeAt(o2)) !== 108)
+              return false;
+            if (o2++, c++, (n2 = i2.charCodeAt(o2)) !== 108)
+              return false;
+            o2++, c++;
+          } else if (n2 === 116) {
+            if (t2.type = 9, o2++, c++, (n2 = i2.charCodeAt(o2)) !== 114)
+              return false;
+            if (o2++, c++, (n2 = i2.charCodeAt(o2)) !== 117)
+              return false;
+            if (o2++, c++, (n2 = i2.charCodeAt(o2)) !== 101)
+              return false;
+            o2++, c++;
+          } else if (n2 === 102) {
+            if (t2.type = 10, o2++, c++, (n2 = i2.charCodeAt(o2)) !== 97)
+              return false;
+            if (o2++, c++, (n2 = i2.charCodeAt(o2)) !== 108)
+              return false;
+            if (o2++, c++, (n2 = i2.charCodeAt(o2)) !== 115)
+              return false;
+            if (o2++, c++, (n2 = i2.charCodeAt(o2)) !== 101)
+              return false;
+            o2++, c++;
+          } else
+            for (t2.type = 11; ; ) {
+              if (o2 >= s3)
+                return false;
+              if (!((n2 = i2.charCodeAt(o2)) === 46 || n2 >= 48 && n2 <= 57 || n2 === 101 || n2 === 69 || n2 === 45 || n2 === 43))
+                break;
+              o2++, c++;
+            }
+          return t2.len = o2 - t2.offset, t2.value === null && (t2.value = i2.substr(t2.offset, t2.len)), e2.pos = o2, e2.line = a, e2.char = c, true;
+        }
+      }, function(e, t, n) {
+        "use strict";
+        Object.defineProperty(t, "__esModule", { value: true });
+        var r = function(e2, t2, n2, r2, i2, o2) {
+          this.scope = e2, this.parentScopes = t2, this.index = n2, this.fontStyle = r2, this.foreground = i2, this.background = o2;
+        };
+        function i(e2) {
+          return !!/^#[0-9a-f]{6}$/i.test(e2) || (!!/^#[0-9a-f]{8}$/i.test(e2) || (!!/^#[0-9a-f]{3}$/i.test(e2) || !!/^#[0-9a-f]{4}$/i.test(e2)));
+        }
+        function o(e2) {
+          if (!e2)
+            return [];
+          if (!e2.settings || !Array.isArray(e2.settings))
+            return [];
+          for (var t2 = e2.settings, n2 = [], o2 = 0, s3 = 0, a2 = t2.length; s3 < a2; s3++) {
+            var c2 = t2[s3];
+            if (c2.settings) {
+              var u3 = void 0;
+              if (typeof c2.scope == "string")
+                u3 = c2.scope.replace(/^[,]+/, "").replace(/[,]+$/, "").split(",");
+              else
+                u3 = Array.isArray(c2.scope) ? c2.scope : [""];
+              var l2 = -1;
+              if (typeof c2.settings.fontStyle == "string") {
+                l2 = 0;
+                for (var h3 = 0, p2 = (g = c2.settings.fontStyle.split(" ")).length; h3 < p2; h3++) {
+                  switch (g[h3]) {
+                    case "italic":
+                      l2 |= 1;
+                      break;
+                    case "bold":
+                      l2 |= 2;
+                      break;
+                    case "underline":
+                      l2 |= 4;
+                  }
+                }
+              }
+              var f = null;
+              typeof c2.settings.foreground == "string" && i(c2.settings.foreground) && (f = c2.settings.foreground);
+              var d = null;
+              typeof c2.settings.background == "string" && i(c2.settings.background) && (d = c2.settings.background);
+              for (h3 = 0, p2 = u3.length; h3 < p2; h3++) {
+                var g, m = (g = u3[h3].trim().split(" "))[g.length - 1], _ = null;
+                g.length > 1 && (_ = g.slice(0, g.length - 1)).reverse(), n2[o2++] = new r(m, _, s3, l2, f, d);
+              }
+            }
+          }
+          return n2;
+        }
+        function s2(e2, t2) {
+          e2.sort(function(e3, t3) {
+            var n3 = u2(e3.scope, t3.scope);
+            return n3 !== 0 || (n3 = l(e3.parentScopes, t3.parentScopes)) !== 0 ? n3 : e3.index - t3.index;
+          });
+          for (var n2 = 0, r2 = "#000000", i2 = "#ffffff"; e2.length >= 1 && e2[0].scope === ""; ) {
+            var o2 = e2.shift();
+            o2.fontStyle !== -1 && (n2 = o2.fontStyle), o2.foreground !== null && (r2 = o2.foreground), o2.background !== null && (i2 = o2.background);
+          }
+          for (var s3 = new a(t2), f = new h2(0, null, n2, s3.getId(r2), s3.getId(i2)), d = new p(new h2(0, null, -1, 0, 0), []), g = 0, m = e2.length; g < m; g++) {
+            var _ = e2[g];
+            d.insert(0, _.scope, _.parentScopes, _.fontStyle, s3.getId(_.foreground), s3.getId(_.background));
+          }
+          return new c(s3, f, d);
+        }
+        t.ParsedThemeRule = r, t.parseTheme = o;
+        var a = function() {
+          function e2(e3) {
+            if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e3)) {
+              this._isFrozen = true;
+              for (var t2 = 0, n2 = e3.length; t2 < n2; t2++)
+                this._color2id[e3[t2]] = t2, this._id2color[t2] = e3[t2];
+            } else
+              this._isFrozen = false;
+          }
+          return e2.prototype.getId = function(e3) {
+            if (e3 === null)
+              return 0;
+            e3 = e3.toUpperCase();
+            var t2 = this._color2id[e3];
+            if (t2)
+              return t2;
+            if (this._isFrozen)
+              throw new Error("Missing color in color map - " + e3);
+            return t2 = ++this._lastColorId, this._color2id[e3] = t2, this._id2color[t2] = e3, t2;
+          }, e2.prototype.getColorMap = function() {
+            return this._id2color.slice(0);
+          }, e2;
+        }();
+        t.ColorMap = a;
+        var c = function() {
+          function e2(e3, t2, n2) {
+            this._colorMap = e3, this._root = n2, this._defaults = t2, this._cache = {};
+          }
+          return e2.createFromRawTheme = function(e3, t2) {
+            return this.createFromParsedTheme(o(e3), t2);
+          }, e2.createFromParsedTheme = function(e3, t2) {
+            return s2(e3, t2);
+          }, e2.prototype.getColorMap = function() {
+            return this._colorMap.getColorMap();
+          }, e2.prototype.getDefaults = function() {
+            return this._defaults;
+          }, e2.prototype.match = function(e3) {
+            return this._cache.hasOwnProperty(e3) || (this._cache[e3] = this._root.match(e3)), this._cache[e3];
+          }, e2;
+        }();
+        function u2(e2, t2) {
+          return e2 < t2 ? -1 : e2 > t2 ? 1 : 0;
+        }
+        function l(e2, t2) {
+          if (e2 === null && t2 === null)
+            return 0;
+          if (!e2)
+            return -1;
+          if (!t2)
+            return 1;
+          var n2 = e2.length, r2 = t2.length;
+          if (n2 === r2) {
+            for (var i2 = 0; i2 < n2; i2++) {
+              var o2 = u2(e2[i2], t2[i2]);
+              if (o2 !== 0)
+                return o2;
+            }
+            return 0;
+          }
+          return n2 - r2;
+        }
+        t.Theme = c, t.strcmp = u2, t.strArrCmp = l;
+        var h2 = function() {
+          function e2(e3, t2, n2, r2, i2) {
+            this.scopeDepth = e3, this.parentScopes = t2, this.fontStyle = n2, this.foreground = r2, this.background = i2;
+          }
+          return e2.prototype.clone = function() {
+            return new e2(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
+          }, e2.cloneArr = function(e3) {
+            for (var t2 = [], n2 = 0, r2 = e3.length; n2 < r2; n2++)
+              t2[n2] = e3[n2].clone();
+            return t2;
+          }, e2.prototype.acceptOverwrite = function(e3, t2, n2, r2) {
+            this.scopeDepth > e3 ? console.log("how did this happen?") : this.scopeDepth = e3, t2 !== -1 && (this.fontStyle = t2), n2 !== 0 && (this.foreground = n2), r2 !== 0 && (this.background = r2);
+          }, e2;
+        }();
+        t.ThemeTrieElementRule = h2;
+        var p = function() {
+          function e2(e3, t2, n2) {
+            t2 === void 0 && (t2 = []), n2 === void 0 && (n2 = {}), this._mainRule = e3, this._rulesWithParentScopes = t2, this._children = n2;
+          }
+          return e2._sortBySpecificity = function(e3) {
+            return e3.length === 1 || e3.sort(this._cmpBySpecificity), e3;
+          }, e2._cmpBySpecificity = function(e3, t2) {
+            if (e3.scopeDepth === t2.scopeDepth) {
+              var n2 = e3.parentScopes, r2 = t2.parentScopes, i2 = n2 === null ? 0 : n2.length, o2 = r2 === null ? 0 : r2.length;
+              if (i2 === o2)
+                for (var s3 = 0; s3 < i2; s3++) {
+                  var a2 = n2[s3].length, c2 = r2[s3].length;
+                  if (a2 !== c2)
+                    return c2 - a2;
+                }
+              return o2 - i2;
+            }
+            return t2.scopeDepth - e3.scopeDepth;
+          }, e2.prototype.match = function(t2) {
+            if (t2 === "")
+              return e2._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
+            var n2, r2, i2 = t2.indexOf(".");
+            return i2 === -1 ? (n2 = t2, r2 = "") : (n2 = t2.substring(0, i2), r2 = t2.substring(i2 + 1)), this._children.hasOwnProperty(n2) ? this._children[n2].match(r2) : e2._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
+          }, e2.prototype.insert = function(t2, n2, r2, i2, o2, s3) {
+            if (n2 !== "") {
+              var a2, c2, u3, l2 = n2.indexOf(".");
+              l2 === -1 ? (a2 = n2, c2 = "") : (a2 = n2.substring(0, l2), c2 = n2.substring(l2 + 1)), this._children.hasOwnProperty(a2) ? u3 = this._children[a2] : (u3 = new e2(this._mainRule.clone(), h2.cloneArr(this._rulesWithParentScopes)), this._children[a2] = u3), u3.insert(t2 + 1, c2, r2, i2, o2, s3);
+            } else
+              this._doInsertHere(t2, r2, i2, o2, s3);
+          }, e2.prototype._doInsertHere = function(e3, t2, n2, r2, i2) {
+            if (t2 !== null) {
+              for (var o2 = 0, s3 = this._rulesWithParentScopes.length; o2 < s3; o2++) {
+                var a2 = this._rulesWithParentScopes[o2];
+                if (l(a2.parentScopes, t2) === 0)
+                  return void a2.acceptOverwrite(e3, n2, r2, i2);
+              }
+              n2 === -1 && (n2 = this._mainRule.fontStyle), r2 === 0 && (r2 = this._mainRule.foreground), i2 === 0 && (i2 = this._mainRule.background), this._rulesWithParentScopes.push(new h2(e3, t2, n2, r2, i2));
+            } else
+              this._mainRule.acceptOverwrite(e3, n2, r2, i2);
+          }, e2;
+        }();
+        t.ThemeTrieElement = p;
+      }]);
+    });
+  }
+});
+
+// ../../node_modules/.pnpm/shiki@0.10.1/node_modules/shiki/dist/index.js
+var require_dist = __commonJS({
+  "../../node_modules/.pnpm/shiki@0.10.1/node_modules/shiki/dist/index.js"(exports) {
+    "use strict";
+    Object.defineProperty(exports, "__esModule", { value: true });
+    var vscodeOniguruma = require_main();
+    var vscodeTextmate = require_main2();
+    var themes = [
+      "css-variables",
+      "dark-plus",
+      "dracula-soft",
+      "dracula",
+      "github-dark-dimmed",
+      "github-dark",
+      "github-light",
+      "light-plus",
+      "material-darker",
+      "material-default",
+      "material-lighter",
+      "material-ocean",
+      "material-palenight",
+      "min-dark",
+      "min-light",
+      "monokai",
+      "nord",
+      "one-dark-pro",
+      "poimandres",
+      "rose-pine-dawn",
+      "rose-pine-moon",
+      "rose-pine",
+      "slack-dark",
+      "slack-ochin",
+      "solarized-dark",
+      "solarized-light",
+      "vitesse-dark",
+      "vitesse-light"
+    ];
+    var languages = [
+      {
+        id: "abap",
+        scopeName: "source.abap",
+        path: "abap.tmLanguage.json",
+        samplePath: "abap.sample"
+      },
+      {
+        id: "actionscript-3",
+        scopeName: "source.actionscript.3",
+        path: "actionscript-3.tmLanguage.json",
+        samplePath: "actionscript-3.sample"
+      },
+      {
+        id: "ada",
+        scopeName: "source.ada",
+        path: "ada.tmLanguage.json",
+        samplePath: "ada.sample"
+      },
+      {
+        id: "apache",
+        scopeName: "source.apacheconf",
+        path: "apache.tmLanguage.json"
+      },
+      {
+        id: "apex",
+        scopeName: "source.apex",
+        path: "apex.tmLanguage.json",
+        samplePath: "apex.sample"
+      },
+      {
+        id: "apl",
+        scopeName: "source.apl",
+        path: "apl.tmLanguage.json",
+        embeddedLangs: ["html", "xml", "css", "javascript", "json"]
+      },
+      {
+        id: "applescript",
+        scopeName: "source.applescript",
+        path: "applescript.tmLanguage.json",
+        samplePath: "applescript.sample"
+      },
+      {
+        id: "asm",
+        scopeName: "source.asm.x86_64",
+        path: "asm.tmLanguage.json",
+        samplePath: "asm.sample"
+      },
+      {
+        id: "astro",
+        scopeName: "text.html.astro",
+        path: "astro.tmLanguage.json",
+        samplePath: "astro.sample",
+        embeddedLangs: ["css", "javascript", "less", "sass", "scss", "stylus", "typescript", "tsx"]
+      },
+      {
+        id: "awk",
+        scopeName: "source.awk",
+        path: "awk.tmLanguage.json",
+        samplePath: "awk.sample"
+      },
+      {
+        id: "ballerina",
+        scopeName: "source.ballerina",
+        path: "ballerina.tmLanguage.json",
+        samplePath: "ballerina.sample"
+      },
+      {
+        id: "bat",
+        scopeName: "source.batchfile",
+        path: "bat.tmLanguage.json",
+        samplePath: "bat.sample",
+        aliases: ["batch"]
+      },
+      {
+        id: "berry",
+        scopeName: "source.berry",
+        path: "berry.tmLanguage.json",
+        samplePath: "berry.sample",
+        aliases: ["be"]
+      },
+      {
+        id: "bibtex",
+        scopeName: "text.bibtex",
+        path: "bibtex.tmLanguage.json"
+      },
+      {
+        id: "bicep",
+        scopeName: "source.bicep",
+        path: "bicep.tmLanguage.json",
+        samplePath: "bicep.sample"
+      },
+      {
+        id: "c",
+        scopeName: "source.c",
+        path: "c.tmLanguage.json",
+        samplePath: "c.sample"
+      },
+      {
+        id: "clojure",
+        scopeName: "source.clojure",
+        path: "clojure.tmLanguage.json",
+        samplePath: "clojure.sample",
+        aliases: ["clj"]
+      },
+      {
+        id: "cobol",
+        scopeName: "source.cobol",
+        path: "cobol.tmLanguage.json",
+        samplePath: "cobol.sample",
+        embeddedLangs: ["sql", "html", "java"]
+      },
+      {
+        id: "codeql",
+        scopeName: "source.ql",
+        path: "codeql.tmLanguage.json",
+        samplePath: "codeql.sample",
+        aliases: ["ql"]
+      },
+      {
+        id: "coffee",
+        scopeName: "source.coffee",
+        path: "coffee.tmLanguage.json",
+        samplePath: "coffee.sample",
+        embeddedLangs: ["javascript"]
+      },
+      {
+        id: "cpp",
+        scopeName: "source.cpp",
+        path: "cpp.tmLanguage.json",
+        samplePath: "cpp.sample",
+        embeddedLangs: ["sql"]
+      },
+      {
+        id: "crystal",
+        scopeName: "source.crystal",
+        path: "crystal.tmLanguage.json",
+        samplePath: "crystal.sample",
+        embeddedLangs: ["html", "sql", "css", "c", "javascript", "shellscript"]
+      },
+      {
+        id: "csharp",
+        scopeName: "source.cs",
+        path: "csharp.tmLanguage.json",
+        samplePath: "csharp.sample",
+        aliases: ["c#"]
+      },
+      {
+        id: "css",
+        scopeName: "source.css",
+        path: "css.tmLanguage.json",
+        samplePath: "css.sample"
+      },
+      {
+        id: "cue",
+        scopeName: "source.cue",
+        path: "cue.tmLanguage.json",
+        samplePath: "cue.sample"
+      },
+      {
+        id: "d",
+        scopeName: "source.d",
+        path: "d.tmLanguage.json",
+        samplePath: "d.sample"
+      },
+      {
+        id: "dart",
+        scopeName: "source.dart",
+        path: "dart.tmLanguage.json",
+        samplePath: "dart.sample"
+      },
+      {
+        id: "diff",
+        scopeName: "source.diff",
+        path: "diff.tmLanguage.json",
+        samplePath: "diff.sample"
+      },
+      {
+        id: "docker",
+        scopeName: "source.dockerfile",
+        path: "docker.tmLanguage.json",
+        samplePath: "docker.sample"
+      },
+      {
+        id: "dream-maker",
+        scopeName: "source.dm",
+        path: "dream-maker.tmLanguage.json"
+      },
+      {
+        id: "elixir",
+        scopeName: "source.elixir",
+        path: "elixir.tmLanguage.json",
+        samplePath: "elixir.sample",
+        embeddedLangs: ["html"]
+      },
+      {
+        id: "elm",
+        scopeName: "source.elm",
+        path: "elm.tmLanguage.json",
+        samplePath: "elm.sample"
+      },
+      {
+        id: "erb",
+        scopeName: "text.html.erb",
+        path: "erb.tmLanguage.json",
+        samplePath: "erb.sample",
+        embeddedLangs: ["html", "ruby"]
+      },
+      {
+        id: "erlang",
+        scopeName: "source.erlang",
+        path: "erlang.tmLanguage.json",
+        samplePath: "erlang.sample"
+      },
+      {
+        id: "fish",
+        scopeName: "source.fish",
+        path: "fish.tmLanguage.json",
+        samplePath: "fish.sample"
+      },
+      {
+        id: "fsharp",
+        scopeName: "source.fsharp",
+        path: "fsharp.tmLanguage.json",
+        samplePath: "fsharp.sample",
+        aliases: ["f#"],
+        embeddedLangs: ["markdown"]
+      },
+      {
+        id: "gherkin",
+        scopeName: "text.gherkin.feature",
+        path: "gherkin.tmLanguage.json"
+      },
+      {
+        id: "git-commit",
+        scopeName: "text.git-commit",
+        path: "git-commit.tmLanguage.json",
+        embeddedLangs: ["diff"]
+      },
+      {
+        id: "git-rebase",
+        scopeName: "text.git-rebase",
+        path: "git-rebase.tmLanguage.json",
+        embeddedLangs: ["shellscript"]
+      },
+      {
+        id: "gnuplot",
+        scopeName: "source.gnuplot",
+        path: "gnuplot.tmLanguage.json"
+      },
+      {
+        id: "go",
+        scopeName: "source.go",
+        path: "go.tmLanguage.json",
+        samplePath: "go.sample"
+      },
+      {
+        id: "graphql",
+        scopeName: "source.graphql",
+        path: "graphql.tmLanguage.json",
+        embeddedLangs: ["javascript", "typescript", "jsx", "tsx"]
+      },
+      {
+        id: "groovy",
+        scopeName: "source.groovy",
+        path: "groovy.tmLanguage.json"
+      },
+      {
+        id: "hack",
+        scopeName: "source.hack",
+        path: "hack.tmLanguage.json",
+        embeddedLangs: ["html", "sql"]
+      },
+      {
+        id: "haml",
+        scopeName: "text.haml",
+        path: "haml.tmLanguage.json",
+        embeddedLangs: ["ruby", "javascript", "sass", "coffee", "markdown", "css"]
+      },
+      {
+        id: "handlebars",
+        scopeName: "text.html.handlebars",
+        path: "handlebars.tmLanguage.json",
+        aliases: ["hbs"],
+        embeddedLangs: ["html", "css", "javascript", "yaml"]
+      },
+      {
+        id: "haskell",
+        scopeName: "source.haskell",
+        path: "haskell.tmLanguage.json"
+      },
+      {
+        id: "hcl",
+        scopeName: "source.hcl",
+        path: "hcl.tmLanguage.json"
+      },
+      {
+        id: "hlsl",
+        scopeName: "source.hlsl",
+        path: "hlsl.tmLanguage.json"
+      },
+      {
+        id: "html",
+        scopeName: "text.html.basic",
+        path: "html.tmLanguage.json",
+        samplePath: "html.sample",
+        embeddedLangs: ["javascript", "css"]
+      },
+      {
+        id: "ini",
+        scopeName: "source.ini",
+        path: "ini.tmLanguage.json"
+      },
+      {
+        id: "java",
+        scopeName: "source.java",
+        path: "java.tmLanguage.json",
+        samplePath: "java.sample"
+      },
+      {
+        id: "javascript",
+        scopeName: "source.js",
+        path: "javascript.tmLanguage.json",
+        samplePath: "javascript.sample",
+        aliases: ["js"]
+      },
+      {
+        id: "jinja-html",
+        scopeName: "text.html.jinja",
+        path: "jinja-html.tmLanguage.json",
+        embeddedLangs: ["html"]
+      },
+      {
+        id: "json",
+        scopeName: "source.json",
+        path: "json.tmLanguage.json"
+      },
+      {
+        id: "jsonc",
+        scopeName: "source.json.comments",
+        path: "jsonc.tmLanguage.json"
+      },
+      {
+        id: "jsonnet",
+        scopeName: "source.jsonnet",
+        path: "jsonnet.tmLanguage.json"
+      },
+      {
+        id: "jssm",
+        scopeName: "source.jssm",
+        path: "jssm.tmLanguage.json",
+        samplePath: "jssm.sample",
+        aliases: ["fsl"]
+      },
+      {
+        id: "jsx",
+        scopeName: "source.js.jsx",
+        path: "jsx.tmLanguage.json"
+      },
+      {
+        id: "julia",
+        scopeName: "source.julia",
+        path: "julia.tmLanguage.json",
+        embeddedLangs: ["cpp", "python", "javascript", "r", "sql"]
+      },
+      {
+        id: "jupyter",
+        scopeName: "source.jupyter",
+        path: "jupyter.tmLanguage.json",
+        embeddedLangs: ["json"]
+      },
+      {
+        id: "kotlin",
+        scopeName: "source.kotlin",
+        path: "kotlin.tmLanguage.json"
+      },
+      {
+        id: "latex",
+        scopeName: "text.tex.latex",
+        path: "latex.tmLanguage.json",
+        embeddedLangs: ["tex", "css", "html", "java", "javascript", "typescript", "lua", "python", "julia", "ruby", "xml", "yaml", "cpp", "haskell", "scala", "gnuplot"]
+      },
+      {
+        id: "less",
+        scopeName: "source.css.less",
+        path: "less.tmLanguage.json",
+        embeddedLangs: ["css"]
+      },
+      {
+        id: "lisp",
+        scopeName: "source.lisp",
+        path: "lisp.tmLanguage.json"
+      },
+      {
+        id: "logo",
+        scopeName: "source.logo",
+        path: "logo.tmLanguage.json"
+      },
+      {
+        id: "lua",
+        scopeName: "source.lua",
+        path: "lua.tmLanguage.json",
+        embeddedLangs: ["c"]
+      },
+      {
+        id: "make",
+        scopeName: "source.makefile",
+        path: "make.tmLanguage.json",
+        aliases: ["makefile"]
+      },
+      {
+        id: "markdown",
+        scopeName: "text.html.markdown",
+        path: "markdown.tmLanguage.json",
+        aliases: ["md"],
+        embeddedLangs: ["css", "html", "ini", "java", "lua", "make", "perl", "r", "ruby", "php", "sql", "vb", "xml", "xsl", "yaml", "bat", "clojure", "coffee", "c", "cpp", "diff", "docker", "git-commit", "git-rebase", "go", "groovy", "pug", "javascript", "json", "jsonc", "less", "objective-c", "swift", "scss", "raku", "powershell", "python", "rust", "scala", "shellscript", "typescript", "tsx", "csharp", "fsharp", "dart", "handlebars", "erlang", "elixir", "latex", "bibtex"]
+      },
+      {
+        id: "marko",
+        scopeName: "text.marko",
+        path: "marko.tmLanguage.json",
+        samplePath: "marko.sample",
+        embeddedLangs: ["css", "less", "scss", "javascript"]
+      },
+      {
+        id: "matlab",
+        scopeName: "source.matlab",
+        path: "matlab.tmLanguage.json"
+      },
+      {
+        id: "mdx",
+        scopeName: "text.html.markdown.jsx",
+        path: "mdx.tmLanguage.json",
+        embeddedLangs: ["jsx", "markdown"]
+      },
+      {
+        id: "nginx",
+        scopeName: "source.nginx",
+        path: "nginx.tmLanguage.json",
+        embeddedLangs: ["lua"]
+      },
+      {
+        id: "nim",
+        scopeName: "source.nim",
+        path: "nim.tmLanguage.json",
+        embeddedLangs: ["c", "html", "xml", "javascript", "css", "markdown"]
+      },
+      {
+        id: "nix",
+        scopeName: "source.nix",
+        path: "nix.tmLanguage.json"
+      },
+      {
+        id: "objective-c",
+        scopeName: "source.objc",
+        path: "objective-c.tmLanguage.json",
+        aliases: ["objc"]
+      },
+      {
+        id: "objective-cpp",
+        scopeName: "source.objcpp",
+        path: "objective-cpp.tmLanguage.json"
+      },
+      {
+        id: "ocaml",
+        scopeName: "source.ocaml",
+        path: "ocaml.tmLanguage.json"
+      },
+      {
+        id: "pascal",
+        scopeName: "source.pascal",
+        path: "pascal.tmLanguage.json"
+      },
+      {
+        id: "perl",
+        scopeName: "source.perl",
+        path: "perl.tmLanguage.json",
+        embeddedLangs: ["html", "xml", "css", "javascript", "sql"]
+      },
+      {
+        id: "php",
+        scopeName: "source.php",
+        path: "php.tmLanguage.json",
+        embeddedLangs: ["html", "xml", "sql", "javascript", "json", "css"]
+      },
+      {
+        id: "plsql",
+        scopeName: "source.plsql.oracle",
+        path: "plsql.tmLanguage.json"
+      },
+      {
+        id: "postcss",
+        scopeName: "source.css.postcss",
+        path: "postcss.tmLanguage.json"
+      },
+      {
+        id: "powershell",
+        scopeName: "source.powershell",
+        path: "powershell.tmLanguage.json",
+        aliases: ["ps", "ps1"]
+      },
+      {
+        id: "prisma",
+        scopeName: "source.prisma",
+        path: "prisma.tmLanguage.json",
+        samplePath: "prisma.sample"
+      },
+      {
+        id: "prolog",
+        scopeName: "source.prolog",
+        path: "prolog.tmLanguage.json"
+      },
+      {
+        id: "pug",
+        scopeName: "text.pug",
+        path: "pug.tmLanguage.json",
+        aliases: ["jade"],
+        embeddedLangs: ["javascript", "css", "sass", "stylus", "coffee", "html"]
+      },
+      {
+        id: "puppet",
+        scopeName: "source.puppet",
+        path: "puppet.tmLanguage.json"
+      },
+      {
+        id: "purescript",
+        scopeName: "source.purescript",
+        path: "purescript.tmLanguage.json"
+      },
+      {
+        id: "python",
+        scopeName: "source.python",
+        path: "python.tmLanguage.json",
+        samplePath: "python.sample",
+        aliases: ["py"]
+      },
+      {
+        id: "r",
+        scopeName: "source.r",
+        path: "r.tmLanguage.json"
+      },
+      {
+        id: "raku",
+        scopeName: "source.perl.6",
+        path: "raku.tmLanguage.json",
+        aliases: ["perl6"]
+      },
+      {
+        id: "razor",
+        scopeName: "text.aspnetcorerazor",
+        path: "razor.tmLanguage.json",
+        embeddedLangs: ["html", "csharp"]
+      },
+      {
+        id: "rel",
+        scopeName: "source.rel",
+        path: "rel.tmLanguage.json",
+        samplePath: "rel.sample"
+      },
+      {
+        id: "riscv",
+        scopeName: "source.riscv",
+        path: "riscv.tmLanguage.json"
+      },
+      {
+        id: "ruby",
+        scopeName: "source.ruby",
+        path: "ruby.tmLanguage.json",
+        samplePath: "ruby.sample",
+        aliases: ["rb"],
+        embeddedLangs: ["html", "xml", "sql", "css", "c", "javascript", "shellscript", "lua"]
+      },
+      {
+        id: "rust",
+        scopeName: "source.rust",
+        path: "rust.tmLanguage.json",
+        aliases: ["rs"]
+      },
+      {
+        id: "sas",
+        scopeName: "source.sas",
+        path: "sas.tmLanguage.json",
+        embeddedLangs: ["sql"]
+      },
+      {
+        id: "sass",
+        scopeName: "source.sass",
+        path: "sass.tmLanguage.json"
+      },
+      {
+        id: "scala",
+        scopeName: "source.scala",
+        path: "scala.tmLanguage.json"
+      },
+      {
+        id: "scheme",
+        scopeName: "source.scheme",
+        path: "scheme.tmLanguage.json"
+      },
+      {
+        id: "scss",
+        scopeName: "source.css.scss",
+        path: "scss.tmLanguage.json",
+        embeddedLangs: ["css"]
+      },
+      {
+        id: "shaderlab",
+        scopeName: "source.shaderlab",
+        path: "shaderlab.tmLanguage.json",
+        aliases: ["shader"],
+        embeddedLangs: ["hlsl"]
+      },
+      {
+        id: "shellscript",
+        scopeName: "source.shell",
+        path: "shellscript.tmLanguage.json",
+        aliases: ["shell", "bash", "sh", "zsh"],
+        embeddedLangs: ["ruby", "python", "applescript", "html", "markdown"]
+      },
+      {
+        id: "smalltalk",
+        scopeName: "source.smalltalk",
+        path: "smalltalk.tmLanguage.json"
+      },
+      {
+        id: "solidity",
+        scopeName: "source.solidity",
+        path: "solidity.tmLanguage.json"
+      },
+      {
+        id: "sparql",
+        scopeName: "source.sparql",
+        path: "sparql.tmLanguage.json",
+        samplePath: "sparql.sample",
+        embeddedLangs: ["turtle"]
+      },
+      {
+        id: "sql",
+        scopeName: "source.sql",
+        path: "sql.tmLanguage.json"
+      },
+      {
+        id: "ssh-config",
+        scopeName: "source.ssh-config",
+        path: "ssh-config.tmLanguage.json"
+      },
+      {
+        id: "stata",
+        scopeName: "source.stata",
+        path: "stata.tmLanguage.json",
+        samplePath: "stata.sample",
+        embeddedLangs: ["sql"]
+      },
+      {
+        id: "stylus",
+        scopeName: "source.stylus",
+        path: "stylus.tmLanguage.json",
+        aliases: ["styl"]
+      },
+      {
+        id: "svelte",
+        scopeName: "source.svelte",
+        path: "svelte.tmLanguage.json",
+        embeddedLangs: ["javascript", "typescript", "coffee", "stylus", "sass", "css", "scss", "less", "postcss", "pug", "markdown"]
+      },
+      {
+        id: "swift",
+        scopeName: "source.swift",
+        path: "swift.tmLanguage.json"
+      },
+      {
+        id: "system-verilog",
+        scopeName: "source.systemverilog",
+        path: "system-verilog.tmLanguage.json"
+      },
+      {
+        id: "tasl",
+        scopeName: "source.tasl",
+        path: "tasl.tmLanguage.json",
+        samplePath: "tasl.sample"
+      },
+      {
+        id: "tcl",
+        scopeName: "source.tcl",
+        path: "tcl.tmLanguage.json"
+      },
+      {
+        id: "tex",
+        scopeName: "text.tex",
+        path: "tex.tmLanguage.json",
+        embeddedLangs: ["r"]
+      },
+      {
+        id: "toml",
+        scopeName: "source.toml",
+        path: "toml.tmLanguage.json"
+      },
+      {
+        id: "tsx",
+        scopeName: "source.tsx",
+        path: "tsx.tmLanguage.json",
+        samplePath: "tsx.sample"
+      },
+      {
+        id: "turtle",
+        scopeName: "source.turtle",
+        path: "turtle.tmLanguage.json",
+        samplePath: "turtle.sample"
+      },
+      {
+        id: "twig",
+        scopeName: "text.html.twig",
+        path: "twig.tmLanguage.json",
+        embeddedLangs: ["css", "javascript", "php", "python", "ruby"]
+      },
+      {
+        id: "typescript",
+        scopeName: "source.ts",
+        path: "typescript.tmLanguage.json",
+        aliases: ["ts"]
+      },
+      {
+        id: "vb",
+        scopeName: "source.asp.vb.net",
+        path: "vb.tmLanguage.json",
+        aliases: ["cmd"]
+      },
+      {
+        id: "verilog",
+        scopeName: "source.verilog",
+        path: "verilog.tmLanguage.json"
+      },
+      {
+        id: "vhdl",
+        scopeName: "source.vhdl",
+        path: "vhdl.tmLanguage.json"
+      },
+      {
+        id: "viml",
+        scopeName: "source.viml",
+        path: "viml.tmLanguage.json",
+        aliases: ["vim", "vimscript"]
+      },
+      {
+        id: "vue-html",
+        scopeName: "text.html.vue-html",
+        path: "vue-html.tmLanguage.json",
+        embeddedLangs: ["vue", "javascript"]
+      },
+      {
+        id: "vue",
+        scopeName: "source.vue",
+        path: "vue.tmLanguage.json",
+        embeddedLangs: ["json", "markdown", "pug", "haml", "vue-html", "sass", "scss", "less", "stylus", "postcss", "css", "typescript", "coffee", "javascript"]
+      },
+      {
+        id: "wasm",
+        scopeName: "source.wat",
+        path: "wasm.tmLanguage.json"
+      },
+      {
+        id: "wenyan",
+        scopeName: "source.wenyan",
+        path: "wenyan.tmLanguage.json",
+        aliases: ["\u6587\u8A00"]
+      },
+      {
+        id: "xml",
+        scopeName: "text.xml",
+        path: "xml.tmLanguage.json",
+        embeddedLangs: ["java"]
+      },
+      {
+        id: "xsl",
+        scopeName: "text.xml.xsl",
+        path: "xsl.tmLanguage.json",
+        embeddedLangs: ["xml"]
+      },
+      {
+        id: "yaml",
+        scopeName: "source.yaml",
+        path: "yaml.tmLanguage.json"
+      },
+      {
+        id: "zenscript",
+        scopeName: "source.zenscript",
+        path: "zenscript.tmLanguage.json",
+        samplePath: "zenscript.sample"
+      }
+    ];
+    exports.FontStyle = void 0;
+    (function(FontStyle) {
+      FontStyle[FontStyle["NotSet"] = -1] = "NotSet";
+      FontStyle[FontStyle["None"] = 0] = "None";
+      FontStyle[FontStyle["Italic"] = 1] = "Italic";
+      FontStyle[FontStyle["Bold"] = 2] = "Bold";
+      FontStyle[FontStyle["Underline"] = 4] = "Underline";
+    })(exports.FontStyle || (exports.FontStyle = {}));
+    var StackElementMetadata = class {
+      static toBinaryStr(metadata) {
+        let r = metadata.toString(2);
+        while (r.length < 32) {
+          r = "0" + r;
+        }
+        return r;
+      }
+      static printMetadata(metadata) {
+        let languageId = StackElementMetadata.getLanguageId(metadata);
+        let tokenType = StackElementMetadata.getTokenType(metadata);
+        let fontStyle = StackElementMetadata.getFontStyle(metadata);
+        let foreground = StackElementMetadata.getForeground(metadata);
+        let background = StackElementMetadata.getBackground(metadata);
+        console.log({
+          languageId,
+          tokenType,
+          fontStyle,
+          foreground,
+          background
+        });
+      }
+      static getLanguageId(metadata) {
+        return (metadata & 255) >>> 0;
+      }
+      static getTokenType(metadata) {
+        return (metadata & 1792) >>> 8;
+      }
+      static getFontStyle(metadata) {
+        return (metadata & 14336) >>> 11;
+      }
+      static getForeground(metadata) {
+        return (metadata & 8372224) >>> 14;
+      }
+      static getBackground(metadata) {
+        return (metadata & 4286578688) >>> 23;
+      }
+      static set(metadata, languageId, tokenType, fontStyle, foreground, background) {
+        let _languageId = StackElementMetadata.getLanguageId(metadata);
+        let _tokenType = StackElementMetadata.getTokenType(metadata);
+        let _fontStyle = StackElementMetadata.getFontStyle(metadata);
+        let _foreground = StackElementMetadata.getForeground(metadata);
+        let _background = StackElementMetadata.getBackground(metadata);
+        if (languageId !== 0) {
+          _languageId = languageId;
+        }
+        if (tokenType !== 0) {
+          _tokenType = tokenType === 8 ? 0 : tokenType;
+        }
+        if (fontStyle !== exports.FontStyle.NotSet) {
+          _fontStyle = fontStyle;
+        }
+        if (foreground !== 0) {
+          _foreground = foreground;
+        }
+        if (background !== 0) {
+          _background = background;
+        }
+        return (_languageId << 0 | _tokenType << 8 | _fontStyle << 11 | _foreground << 14 | _background << 23) >>> 0;
+      }
+    };
+    function trimEndSlash(str) {
+      if (str.endsWith("/") || str.endsWith("\\"))
+        return str.slice(0, -1);
+      return str;
+    }
+    function trimStartDot(str) {
+      if (str.startsWith("./"))
+        return str.slice(2);
+      return str;
+    }
+    function dirname(str) {
+      const parts = str.split(/[\/\\]/g);
+      return parts[parts.length - 2];
+    }
+    function join(...parts) {
+      return parts.map(trimEndSlash).map(trimStartDot).join("/");
+    }
+    function groupBy(elements, keyGetter) {
+      const map2 = /* @__PURE__ */ new Map();
+      for (const element3 of elements) {
+        const key = keyGetter(element3);
+        if (map2.has(key)) {
+          const group = map2.get(key);
+          group.push(element3);
+        } else {
+          map2.set(key, [element3]);
+        }
+      }
+      return map2;
+    }
+    function createScanner(text7, ignoreTrivia) {
+      if (ignoreTrivia === void 0) {
+        ignoreTrivia = false;
+      }
+      var len = text7.length;
+      var pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
+      function scanHexDigits(count, exact) {
+        var digits = 0;
+        var value2 = 0;
+        while (digits < count || !exact) {
+          var ch = text7.charCodeAt(pos);
+          if (ch >= 48 && ch <= 57) {
+            value2 = value2 * 16 + ch - 48;
+          } else if (ch >= 65 && ch <= 70) {
+            value2 = value2 * 16 + ch - 65 + 10;
+          } else if (ch >= 97 && ch <= 102) {
+            value2 = value2 * 16 + ch - 97 + 10;
+          } else {
+            break;
+          }
+          pos++;
+          digits++;
+        }
+        if (digits < count) {
+          value2 = -1;
+        }
+        return value2;
+      }
+      function setPosition(newPosition) {
+        pos = newPosition;
+        value = "";
+        tokenOffset = 0;
+        token = 16;
+        scanError = 0;
+      }
+      function scanNumber() {
+        var start3 = pos;
+        if (text7.charCodeAt(pos) === 48) {
+          pos++;
+        } else {
+          pos++;
+          while (pos < text7.length && isDigit(text7.charCodeAt(pos))) {
+            pos++;
+          }
+        }
+        if (pos < text7.length && text7.charCodeAt(pos) === 46) {
+          pos++;
+          if (pos < text7.length && isDigit(text7.charCodeAt(pos))) {
+            pos++;
+            while (pos < text7.length && isDigit(text7.charCodeAt(pos))) {
+              pos++;
+            }
+          } else {
+            scanError = 3;
+            return text7.substring(start3, pos);
+          }
+        }
+        var end = pos;
+        if (pos < text7.length && (text7.charCodeAt(pos) === 69 || text7.charCodeAt(pos) === 101)) {
+          pos++;
+          if (pos < text7.length && text7.charCodeAt(pos) === 43 || text7.charCodeAt(pos) === 45) {
+            pos++;
+          }
+          if (pos < text7.length && isDigit(text7.charCodeAt(pos))) {
+            pos++;
+            while (pos < text7.length && isDigit(text7.charCodeAt(pos))) {
+              pos++;
+            }
+            end = pos;
+          } else {
+            scanError = 3;
+          }
+        }
+        return text7.substring(start3, end);
+      }
+      function scanString() {
+        var result = "", start3 = pos;
+        while (true) {
+          if (pos >= len) {
+            result += text7.substring(start3, pos);
+            scanError = 2;
+            break;
+          }
+          var ch = text7.charCodeAt(pos);
+          if (ch === 34) {
+            result += text7.substring(start3, pos);
+            pos++;
+            break;
+          }
+          if (ch === 92) {
+            result += text7.substring(start3, pos);
+            pos++;
+            if (pos >= len) {
+              scanError = 2;
+              break;
+            }
+            var ch2 = text7.charCodeAt(pos++);
+            switch (ch2) {
+              case 34:
+                result += '"';
+                break;
+              case 92:
+                result += "\\";
+                break;
+              case 47:
+                result += "/";
+                break;
+              case 98:
+                result += "\b";
+                break;
+              case 102:
+                result += "\f";
+                break;
+              case 110:
+                result += "\n";
+                break;
+              case 114:
+                result += "\r";
+                break;
+              case 116:
+                result += "	";
+                break;
+              case 117:
+                var ch3 = scanHexDigits(4, true);
+                if (ch3 >= 0) {
+                  result += String.fromCharCode(ch3);
+                } else {
+                  scanError = 4;
+                }
+                break;
+              default:
+                scanError = 5;
+            }
+            start3 = pos;
+            continue;
+          }
+          if (ch >= 0 && ch <= 31) {
+            if (isLineBreak(ch)) {
+              result += text7.substring(start3, pos);
+              scanError = 2;
+              break;
+            } else {
+              scanError = 6;
+            }
+          }
+          pos++;
+        }
+        return result;
+      }
+      function scanNext() {
+        value = "";
+        scanError = 0;
+        tokenOffset = pos;
+        lineStartOffset = lineNumber;
+        prevTokenLineStartOffset = tokenLineStartOffset;
+        if (pos >= len) {
+          tokenOffset = len;
+          return token = 17;
+        }
+        var code3 = text7.charCodeAt(pos);
+        if (isWhiteSpace(code3)) {
+          do {
+            pos++;
+            value += String.fromCharCode(code3);
+            code3 = text7.charCodeAt(pos);
+          } while (isWhiteSpace(code3));
+          return token = 15;
+        }
+        if (isLineBreak(code3)) {
+          pos++;
+          value += String.fromCharCode(code3);
+          if (code3 === 13 && text7.charCodeAt(pos) === 10) {
+            pos++;
+            value += "\n";
+          }
+          lineNumber++;
+          tokenLineStartOffset = pos;
+          return token = 14;
+        }
+        switch (code3) {
+          case 123:
+            pos++;
+            return token = 1;
+          case 125:
+            pos++;
+            return token = 2;
+          case 91:
+            pos++;
+            return token = 3;
+          case 93:
+            pos++;
+            return token = 4;
+          case 58:
+            pos++;
+            return token = 6;
+          case 44:
+            pos++;
+            return token = 5;
+          case 34:
+            pos++;
+            value = scanString();
+            return token = 10;
+          case 47:
+            var start3 = pos - 1;
+            if (text7.charCodeAt(pos + 1) === 47) {
+              pos += 2;
+              while (pos < len) {
+                if (isLineBreak(text7.charCodeAt(pos))) {
+                  break;
+                }
+                pos++;
+              }
+              value = text7.substring(start3, pos);
+              return token = 12;
+            }
+            if (text7.charCodeAt(pos + 1) === 42) {
+              pos += 2;
+              var safeLength = len - 1;
+              var commentClosed = false;
+              while (pos < safeLength) {
+                var ch = text7.charCodeAt(pos);
+                if (ch === 42 && text7.charCodeAt(pos + 1) === 47) {
+                  pos += 2;
+                  commentClosed = true;
+                  break;
+                }
+                pos++;
+                if (isLineBreak(ch)) {
+                  if (ch === 13 && text7.charCodeAt(pos) === 10) {
+                    pos++;
+                  }
+                  lineNumber++;
+                  tokenLineStartOffset = pos;
+                }
+              }
+              if (!commentClosed) {
+                pos++;
+                scanError = 1;
+              }
+              value = text7.substring(start3, pos);
+              return token = 13;
+            }
+            value += String.fromCharCode(code3);
+            pos++;
+            return token = 16;
+          case 45:
+            value += String.fromCharCode(code3);
+            pos++;
+            if (pos === len || !isDigit(text7.charCodeAt(pos))) {
+              return token = 16;
+            }
+          case 48:
+          case 49:
+          case 50:
+          case 51:
+          case 52:
+          case 53:
+          case 54:
+          case 55:
+          case 56:
+          case 57:
+            value += scanNumber();
+            return token = 11;
+          default:
+            while (pos < len && isUnknownContentCharacter(code3)) {
+              pos++;
+              code3 = text7.charCodeAt(pos);
+            }
+            if (tokenOffset !== pos) {
+              value = text7.substring(tokenOffset, pos);
+              switch (value) {
+                case "true":
+                  return token = 8;
+                case "false":
+                  return token = 9;
+                case "null":
+                  return token = 7;
+              }
+              return token = 16;
+            }
+            value += String.fromCharCode(code3);
+            pos++;
+            return token = 16;
+        }
+      }
+      function isUnknownContentCharacter(code3) {
+        if (isWhiteSpace(code3) || isLineBreak(code3)) {
+          return false;
+        }
+        switch (code3) {
+          case 125:
+          case 93:
+          case 123:
+          case 91:
+          case 34:
+          case 58:
+          case 44:
+          case 47:
+            return false;
+        }
+        return true;
+      }
+      function scanNextNonTrivia() {
+        var result;
+        do {
+          result = scanNext();
+        } while (result >= 12 && result <= 15);
+        return result;
+      }
+      return {
+        setPosition,
+        getPosition: function() {
+          return pos;
+        },
+        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
+        getToken: function() {
+          return token;
+        },
+        getTokenValue: function() {
+          return value;
+        },
+        getTokenOffset: function() {
+          return tokenOffset;
+        },
+        getTokenLength: function() {
+          return pos - tokenOffset;
+        },
+        getTokenStartLine: function() {
+          return lineStartOffset;
+        },
+        getTokenStartCharacter: function() {
+          return tokenOffset - prevTokenLineStartOffset;
+        },
+        getTokenError: function() {
+          return scanError;
+        }
+      };
+    }
+    function isWhiteSpace(ch) {
+      return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
+    }
+    function isLineBreak(ch) {
+      return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
+    }
+    function isDigit(ch) {
+      return ch >= 48 && ch <= 57;
+    }
+    var ParseOptions;
+    (function(ParseOptions2) {
+      ParseOptions2.DEFAULT = {
+        allowTrailingComma: false
+      };
+    })(ParseOptions || (ParseOptions = {}));
+    function parse$12(text7, errors2, options) {
+      if (errors2 === void 0) {
+        errors2 = [];
+      }
+      if (options === void 0) {
+        options = ParseOptions.DEFAULT;
+      }
+      var currentProperty = null;
+      var currentParent = [];
+      var previousParents = [];
+      function onValue(value) {
+        if (Array.isArray(currentParent)) {
+          currentParent.push(value);
+        } else if (currentProperty !== null) {
+          currentParent[currentProperty] = value;
+        }
+      }
+      var visitor = {
+        onObjectBegin: function() {
+          var object = {};
+          onValue(object);
+          previousParents.push(currentParent);
+          currentParent = object;
+          currentProperty = null;
+        },
+        onObjectProperty: function(name3) {
+          currentProperty = name3;
+        },
+        onObjectEnd: function() {
+          currentParent = previousParents.pop();
+        },
+        onArrayBegin: function() {
+          var array = [];
+          onValue(array);
+          previousParents.push(currentParent);
+          currentParent = array;
+          currentProperty = null;
+        },
+        onArrayEnd: function() {
+          currentParent = previousParents.pop();
+        },
+        onLiteralValue: onValue,
+        onError: function(error, offset2, length) {
+          errors2.push({ error, offset: offset2, length });
+        }
+      };
+      visit8(text7, visitor, options);
+      return currentParent[0];
+    }
+    function visit8(text7, visitor, options) {
+      if (options === void 0) {
+        options = ParseOptions.DEFAULT;
+      }
+      var _scanner = createScanner(text7, false);
+      function toNoArgVisit(visitFunction) {
+        return visitFunction ? function() {
+          return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
+        } : function() {
+          return true;
+        };
+      }
+      function toOneArgVisit(visitFunction) {
+        return visitFunction ? function(arg) {
+          return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
+        } : function() {
+          return true;
+        };
+      }
+      var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
+      var disallowComments = options && options.disallowComments;
+      var allowTrailingComma = options && options.allowTrailingComma;
+      function scanNext() {
+        while (true) {
+          var token = _scanner.scan();
+          switch (_scanner.getTokenError()) {
+            case 4:
+              handleError(14);
+              break;
+            case 5:
+              handleError(15);
+              break;
+            case 3:
+              handleError(13);
+              break;
+            case 1:
+              if (!disallowComments) {
+                handleError(11);
+              }
+              break;
+            case 2:
+              handleError(12);
+              break;
+            case 6:
+              handleError(16);
+              break;
+          }
+          switch (token) {
+            case 12:
+            case 13:
+              if (disallowComments) {
+                handleError(10);
+              } else {
+                onComment();
+              }
+              break;
+            case 16:
+              handleError(1);
+              break;
+            case 15:
+            case 14:
+              break;
+            default:
+              return token;
+          }
+        }
+      }
+      function handleError(error, skipUntilAfter, skipUntil) {
+        if (skipUntilAfter === void 0) {
+          skipUntilAfter = [];
+        }
+        if (skipUntil === void 0) {
+          skipUntil = [];
+        }
+        onError(error);
+        if (skipUntilAfter.length + skipUntil.length > 0) {
+          var token = _scanner.getToken();
+          while (token !== 17) {
+            if (skipUntilAfter.indexOf(token) !== -1) {
+              scanNext();
+              break;
+            } else if (skipUntil.indexOf(token) !== -1) {
+              break;
+            }
+            token = scanNext();
+          }
+        }
+      }
+      function parseString(isValue) {
+        var value = _scanner.getTokenValue();
+        if (isValue) {
+          onLiteralValue(value);
+        } else {
+          onObjectProperty(value);
+        }
+        scanNext();
+        return true;
+      }
+      function parseLiteral() {
+        switch (_scanner.getToken()) {
+          case 11:
+            var tokenValue = _scanner.getTokenValue();
+            var value = Number(tokenValue);
+            if (isNaN(value)) {
+              handleError(2);
+              value = 0;
+            }
+            onLiteralValue(value);
+            break;
+          case 7:
+            onLiteralValue(null);
+            break;
+          case 8:
+            onLiteralValue(true);
+            break;
+          case 9:
+            onLiteralValue(false);
+            break;
+          default:
+            return false;
+        }
+        scanNext();
+        return true;
+      }
+      function parseProperty() {
+        if (_scanner.getToken() !== 10) {
+          handleError(3, [], [2, 5]);
+          return false;
+        }
+        parseString(false);
+        if (_scanner.getToken() === 6) {
+          onSeparator(":");
+          scanNext();
+          if (!parseValue()) {
+            handleError(4, [], [2, 5]);
+          }
+        } else {
+          handleError(5, [], [2, 5]);
+        }
+        return true;
+      }
+      function parseObject() {
+        onObjectBegin();
+        scanNext();
+        var needsComma = false;
+        while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
+          if (_scanner.getToken() === 5) {
+            if (!needsComma) {
+              handleError(4, [], []);
+            }
+            onSeparator(",");
+            scanNext();
+            if (_scanner.getToken() === 2 && allowTrailingComma) {
+              break;
+            }
+          } else if (needsComma) {
+            handleError(6, [], []);
+          }
+          if (!parseProperty()) {
+            handleError(4, [], [2, 5]);
+          }
+          needsComma = true;
+        }
+        onObjectEnd();
+        if (_scanner.getToken() !== 2) {
+          handleError(7, [2], []);
+        } else {
+          scanNext();
+        }
+        return true;
+      }
+      function parseArray() {
+        onArrayBegin();
+        scanNext();
+        var needsComma = false;
+        while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
+          if (_scanner.getToken() === 5) {
+            if (!needsComma) {
+              handleError(4, [], []);
+            }
+            onSeparator(",");
+            scanNext();
+            if (_scanner.getToken() === 4 && allowTrailingComma) {
+              break;
+            }
+          } else if (needsComma) {
+            handleError(6, [], []);
+          }
+          if (!parseValue()) {
+            handleError(4, [], [4, 5]);
+          }
+          needsComma = true;
+        }
+        onArrayEnd();
+        if (_scanner.getToken() !== 4) {
+          handleError(8, [4], []);
+        } else {
+          scanNext();
+        }
+        return true;
+      }
+      function parseValue() {
+        switch (_scanner.getToken()) {
+          case 3:
+            return parseArray();
+          case 1:
+            return parseObject();
+          case 10:
+            return parseString(true);
+          default:
+            return parseLiteral();
+        }
+      }
+      scanNext();
+      if (_scanner.getToken() === 17) {
+        if (options.allowEmptyContent) {
+          return true;
+        }
+        handleError(4, [], []);
+        return false;
+      }
+      if (!parseValue()) {
+        handleError(4, [], []);
+        return false;
+      }
+      if (_scanner.getToken() !== 17) {
+        handleError(9, [], []);
+      }
+      return true;
+    }
+    var parse5 = parse$12;
+    var isWebWorker = typeof self !== "undefined" && typeof self.WorkerGlobalScope !== "undefined";
+    var isBrowser = isWebWorker || typeof window !== "undefined" && typeof window.document !== "undefined" && typeof fetch !== "undefined";
+    var CDN_ROOT = "";
+    var WASM = "";
+    function setCDN(root4) {
+      CDN_ROOT = root4;
+    }
+    function setWasm(path3) {
+      WASM = path3;
+    }
+    var _onigurumaPromise = null;
+    function getOniguruma() {
+      return __async(this, null, function* () {
+        if (!_onigurumaPromise) {
+          let loader;
+          if (isBrowser) {
+            if (typeof WASM === "string") {
+              loader = vscodeOniguruma.loadWASM({
+                data: yield fetch(_resolvePath("dist/onig.wasm")).then((r) => r.arrayBuffer())
+              });
+            } else {
+              loader = vscodeOniguruma.loadWASM(WASM);
+            }
+          } else {
+            const path3 = __require("path");
+            const wasmPath = path3.join(__require.resolve("vscode-oniguruma"), "../onig.wasm");
+            const fs = __require("fs");
+            const wasmBin = fs.readFileSync(wasmPath).buffer;
+            loader = vscodeOniguruma.loadWASM(wasmBin);
+          }
+          _onigurumaPromise = loader.then(() => {
+            return {
+              createOnigScanner(patterns) {
+                return vscodeOniguruma.createOnigScanner(patterns);
+              },
+              createOnigString(s2) {
+                return vscodeOniguruma.createOnigString(s2);
+              }
+            };
+          });
+        }
+        return _onigurumaPromise;
+      });
+    }
+    function _resolvePath(filepath) {
+      if (isBrowser) {
+        if (!CDN_ROOT) {
+          console.warn("[Shiki] no CDN provider found, use `setCDN()` to specify the CDN for loading the resources before calling `getHighlighter()`");
+        }
+        return `${CDN_ROOT}${filepath}`;
+      } else {
+        const path3 = __require("path");
+        if (path3.isAbsolute(filepath)) {
+          return filepath;
+        } else {
+          return path3.resolve(__dirname, "..", filepath);
+        }
+      }
+    }
+    function _fetchAssets(filepath) {
+      return __async(this, null, function* () {
+        const path3 = _resolvePath(filepath);
+        if (isBrowser) {
+          return yield fetch(path3).then((r) => r.text());
+        } else {
+          const fs = __require("fs");
+          return yield fs.promises.readFile(path3, "utf-8");
+        }
+      });
+    }
+    function _fetchJSONAssets(filepath) {
+      return __async(this, null, function* () {
+        const errors2 = [];
+        const rawTheme = parse5(yield _fetchAssets(filepath), errors2, {
+          allowTrailingComma: true
+        });
+        if (errors2.length) {
+          throw errors2[0];
+        }
+        return rawTheme;
+      });
+    }
+    function fetchTheme(themePath) {
+      return __async(this, null, function* () {
+        let theme = yield _fetchJSONAssets(themePath);
+        const shikiTheme = toShikiTheme(theme);
+        if (shikiTheme.include) {
+          const includedTheme = yield fetchTheme(join(dirname(themePath), shikiTheme.include));
+          if (includedTheme.settings) {
+            shikiTheme.settings = includedTheme.settings.concat(shikiTheme.settings);
+          }
+          if (includedTheme.bg && !shikiTheme.bg) {
+            shikiTheme.bg = includedTheme.bg;
+          }
+          if (includedTheme.colors) {
+            shikiTheme.colors = Object.assign(Object.assign({}, includedTheme.colors), shikiTheme.colors);
+          }
+          delete shikiTheme.include;
+        }
+        return shikiTheme;
+      });
+    }
+    function fetchGrammar(filepath) {
+      return __async(this, null, function* () {
+        return yield _fetchJSONAssets(filepath);
+      });
+    }
+    function repairTheme(theme) {
+      if (!theme.settings)
+        theme.settings = [];
+      if (theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope) {
+        return;
+      }
+      theme.settings.unshift({
+        settings: {
+          foreground: theme.fg,
+          background: theme.bg
+        }
+      });
+    }
+    function toShikiTheme(rawTheme) {
+      const type2 = rawTheme.type || "dark";
+      const shikiTheme = Object.assign(Object.assign({ name: rawTheme.name, type: type2 }, rawTheme), getThemeDefaultColors(rawTheme));
+      if (rawTheme.include) {
+        shikiTheme.include = rawTheme.include;
+      }
+      if (rawTheme.tokenColors) {
+        shikiTheme.settings = rawTheme.tokenColors;
+        delete shikiTheme.tokenColors;
+      }
+      repairTheme(shikiTheme);
+      return shikiTheme;
+    }
+    var VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
+    var VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
+    function getThemeDefaultColors(theme) {
+      var _a, _b, _c, _d, _e, _f;
+      let fg, bg;
+      let settings = theme.settings ? theme.settings : theme.tokenColors;
+      const globalSetting = settings ? settings.find((s2) => {
+        return !s2.name && !s2.scope;
+      }) : void 0;
+      if ((_a = globalSetting === null || globalSetting === void 0 ? void 0 : globalSetting.settings) === null || _a === void 0 ? void 0 : _a.foreground) {
+        fg = globalSetting.settings.foreground;
+      }
+      if ((_b = globalSetting === null || globalSetting === void 0 ? void 0 : globalSetting.settings) === null || _b === void 0 ? void 0 : _b.background) {
+        bg = globalSetting.settings.background;
+      }
+      if (!fg && ((_d = (_c = theme) === null || _c === void 0 ? void 0 : _c.colors) === null || _d === void 0 ? void 0 : _d["editor.foreground"])) {
+        fg = theme.colors["editor.foreground"];
+      }
+      if (!bg && ((_f = (_e = theme) === null || _e === void 0 ? void 0 : _e.colors) === null || _f === void 0 ? void 0 : _f["editor.background"])) {
+        bg = theme.colors["editor.background"];
+      }
+      if (!fg) {
+        fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
+      }
+      if (!bg) {
+        bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
+      }
+      return {
+        fg,
+        bg
+      };
+    }
+    var Resolver = class {
+      constructor(onigLibPromise, onigLibName) {
+        this.languagesPath = "languages/";
+        this.languageMap = {};
+        this.scopeToLangMap = {};
+        this._onigLibPromise = onigLibPromise;
+        this._onigLibName = onigLibName;
+      }
+      get onigLib() {
+        return this._onigLibPromise;
+      }
+      getOnigLibName() {
+        return this._onigLibName;
+      }
+      getLangRegistration(langIdOrAlias) {
+        return this.languageMap[langIdOrAlias];
+      }
+      loadGrammar(scopeName) {
+        return __async(this, null, function* () {
+          const lang = this.scopeToLangMap[scopeName];
+          if (!lang) {
+            return null;
+          }
+          if (lang.grammar) {
+            return lang.grammar;
+          }
+          const g = yield fetchGrammar(languages.includes(lang) ? `${this.languagesPath}${lang.path}` : lang.path);
+          lang.grammar = g;
+          return g;
+        });
+      }
+      addLanguage(l) {
+        this.languageMap[l.id] = l;
+        if (l.aliases) {
+          l.aliases.forEach((a) => {
+            this.languageMap[a] = l;
+          });
+        }
+        this.scopeToLangMap[l.scopeName] = l;
+      }
+    };
+    function tokenizeWithTheme(theme, colorMap, fileContents, grammar, options) {
+      let lines = fileContents.split(/\r\n|\r|\n/);
+      let ruleStack = vscodeTextmate.INITIAL;
+      let actual = [];
+      let final = [];
+      for (let i = 0, len = lines.length; i < len; i++) {
+        let line = lines[i];
+        if (line === "") {
+          actual = [];
+          final.push([]);
+          continue;
+        }
+        let resultWithScopes;
+        let tokensWithScopes;
+        let tokensWithScopesIndex;
+        if (options.includeExplanation) {
+          resultWithScopes = grammar.tokenizeLine(line, ruleStack);
+          tokensWithScopes = resultWithScopes.tokens;
+          tokensWithScopesIndex = 0;
+        }
+        let result = grammar.tokenizeLine2(line, ruleStack);
+        let tokensLength = result.tokens.length / 2;
+        for (let j = 0; j < tokensLength; j++) {
+          let startIndex = result.tokens[2 * j];
+          let nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
+          if (startIndex === nextStartIndex) {
+            continue;
+          }
+          let metadata = result.tokens[2 * j + 1];
+          let foreground = StackElementMetadata.getForeground(metadata);
+          let foregroundColor = colorMap[foreground];
+          let fontStyle = StackElementMetadata.getFontStyle(metadata);
+          let explanation = [];
+          if (options.includeExplanation) {
+            let offset2 = 0;
+            while (startIndex + offset2 < nextStartIndex) {
+              let tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
+              let tokenWithScopesText = line.substring(tokenWithScopes.startIndex, tokenWithScopes.endIndex);
+              offset2 += tokenWithScopesText.length;
+              explanation.push({
+                content: tokenWithScopesText,
+                scopes: explainThemeScopes(theme, tokenWithScopes.scopes)
+              });
+              tokensWithScopesIndex++;
+            }
+          }
+          actual.push({
+            content: line.substring(startIndex, nextStartIndex),
+            color: foregroundColor,
+            fontStyle,
+            explanation
+          });
+        }
+        final.push(actual);
+        actual = [];
+        ruleStack = result.ruleStack;
+      }
+      return final;
+    }
+    function explainThemeScopes(theme, scopes) {
+      let result = [];
+      for (let i = 0, len = scopes.length; i < len; i++) {
+        let parentScopes = scopes.slice(0, i);
+        let scope = scopes[i];
+        result[i] = {
+          scopeName: scope,
+          themeMatches: explainThemeScope(theme, scope, parentScopes)
+        };
+      }
+      return result;
+    }
+    function matchesOne(selector, scope) {
+      let selectorPrefix = selector + ".";
+      if (selector === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix) {
+        return true;
+      }
+      return false;
+    }
+    function matches(selector, selectorParentScopes, scope, parentScopes) {
+      if (!matchesOne(selector, scope)) {
+        return false;
+      }
+      let selectorParentIndex = selectorParentScopes.length - 1;
+      let parentIndex = parentScopes.length - 1;
+      while (selectorParentIndex >= 0 && parentIndex >= 0) {
+        if (matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex])) {
+          selectorParentIndex--;
+        }
+        parentIndex--;
+      }
+      if (selectorParentIndex === -1) {
+        return true;
+      }
+      return false;
+    }
+    function explainThemeScope(theme, scope, parentScopes) {
+      let result = [], resultLen = 0;
+      for (let i = 0, len = theme.settings.length; i < len; i++) {
+        let setting = theme.settings[i];
+        let selectors;
+        if (typeof setting.scope === "string") {
+          selectors = setting.scope.split(/,/).map((scope2) => scope2.trim());
+        } else if (Array.isArray(setting.scope)) {
+          selectors = setting.scope;
+        } else {
+          continue;
+        }
+        for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {
+          let rawSelector = selectors[j];
+          let rawSelectorPieces = rawSelector.split(/ /);
+          let selector = rawSelectorPieces[rawSelectorPieces.length - 1];
+          let selectorParentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);
+          if (matches(selector, selectorParentScopes, scope, parentScopes)) {
+            result[resultLen++] = setting;
+            j = lenJ;
+          }
+        }
+      }
+      return result;
+    }
+    function renderToHtml(lines, options = {}) {
+      var _a;
+      const bg = options.bg || "#fff";
+      const optionsByLineNumber = groupBy((_a = options.lineOptions) !== null && _a !== void 0 ? _a : [], (option) => option.line);
+      let html5 = "";
+      html5 += `<pre class="shiki" style="background-color: ${bg}">`;
+      if (options.langId) {
+        html5 += `<div class="language-id">${options.langId}</div>`;
+      }
+      html5 += `<code>`;
+      lines.forEach((l, lineIndex) => {
+        var _a2;
+        const lineNumber = lineIndex + 1;
+        const lineOptions = (_a2 = optionsByLineNumber.get(lineNumber)) !== null && _a2 !== void 0 ? _a2 : [];
+        const lineClasses = getLineClasses(lineOptions).join(" ");
+        html5 += `<span class="${lineClasses}">`;
+        l.forEach((token) => {
+          const cssDeclarations = [`color: ${token.color || options.fg}`];
+          if (token.fontStyle & exports.FontStyle.Italic) {
+            cssDeclarations.push("font-style: italic");
+          }
+          if (token.fontStyle & exports.FontStyle.Bold) {
+            cssDeclarations.push("font-weight: bold");
+          }
+          if (token.fontStyle & exports.FontStyle.Underline) {
+            cssDeclarations.push("text-decoration: underline");
+          }
+          html5 += `<span style="${cssDeclarations.join("; ")}">${escapeHtml(token.content)}</span>`;
+        });
+        html5 += `</span>
+`;
+      });
+      html5 = html5.replace(/\n*$/, "");
+      html5 += `</code></pre>`;
+      return html5;
+    }
+    var htmlEscapes = {
+      "&": "&amp;",
+      "<": "&lt;",
+      ">": "&gt;",
+      '"': "&quot;",
+      "'": "&#39;"
+    };
+    function escapeHtml(html5) {
+      return html5.replace(/[&<>"']/g, (chr) => htmlEscapes[chr]);
+    }
+    function getLineClasses(lineOptions) {
+      var _a;
+      const lineClasses = /* @__PURE__ */ new Set(["line"]);
+      for (const lineOption of lineOptions) {
+        for (const lineClass of (_a = lineOption.classes) !== null && _a !== void 0 ? _a : []) {
+          lineClasses.add(lineClass);
+        }
+      }
+      return Array.from(lineClasses);
+    }
+    var Registry = class extends vscodeTextmate.Registry {
+      constructor(_resolver) {
+        super(_resolver);
+        this._resolver = _resolver;
+        this.themesPath = "themes/";
+        this._resolvedThemes = {};
+        this._resolvedGrammars = {};
+      }
+      getTheme(theme) {
+        if (typeof theme === "string") {
+          return this._resolvedThemes[theme];
+        } else {
+          return theme;
+        }
+      }
+      loadTheme(theme) {
+        return __async(this, null, function* () {
+          if (typeof theme === "string") {
+            if (!this._resolvedThemes[theme]) {
+              this._resolvedThemes[theme] = yield fetchTheme(`${this.themesPath}${theme}.json`);
+            }
+            return this._resolvedThemes[theme];
+          } else {
+            theme = toShikiTheme(theme);
+            if (theme.name) {
+              this._resolvedThemes[theme.name] = theme;
+            }
+            return theme;
+          }
+        });
+      }
+      loadThemes(themes2) {
+        return __async(this, null, function* () {
+          return yield Promise.all(themes2.map((theme) => this.loadTheme(theme)));
+        });
+      }
+      getLoadedThemes() {
+        return Object.keys(this._resolvedThemes);
+      }
+      getGrammar(name3) {
+        return this._resolvedGrammars[name3];
+      }
+      loadLanguage(lang) {
+        return __async(this, null, function* () {
+          const g = yield this.loadGrammar(lang.scopeName);
+          this._resolvedGrammars[lang.id] = g;
+          if (lang.aliases) {
+            lang.aliases.forEach((la) => {
+              this._resolvedGrammars[la] = g;
+            });
+          }
+        });
+      }
+      loadLanguages(langs) {
+        return __async(this, null, function* () {
+          for (const lang of langs) {
+            this._resolver.addLanguage(lang);
+          }
+          for (const lang of langs) {
+            yield this.loadLanguage(lang);
+          }
+        });
+      }
+      getLoadedLanguages() {
+        return Object.keys(this._resolvedGrammars);
+      }
+    };
+    function resolveLang(lang) {
+      return typeof lang === "string" ? languages.find((l) => {
+        var _a;
+        return l.id === lang || ((_a = l.aliases) === null || _a === void 0 ? void 0 : _a.includes(lang));
+      }) : lang;
+    }
+    function resolveOptions(options) {
+      var _a;
+      let _languages = languages;
+      let _themes = options.themes || [];
+      if ((_a = options.langs) === null || _a === void 0 ? void 0 : _a.length) {
+        _languages = options.langs.map(resolveLang);
+      }
+      if (options.theme) {
+        _themes.unshift(options.theme);
+      }
+      if (!_themes.length) {
+        _themes = ["nord"];
+      }
+      return { _languages, _themes };
+    }
+    function getHighlighter(options) {
+      return __async(this, null, function* () {
+        var _a, _b;
+        const { _languages, _themes } = resolveOptions(options);
+        const _resolver = new Resolver(getOniguruma(), "vscode-oniguruma");
+        const _registry = new Registry(_resolver);
+        if ((_a = options.paths) === null || _a === void 0 ? void 0 : _a.themes) {
+          _registry.themesPath = options.paths.themes;
+        }
+        if ((_b = options.paths) === null || _b === void 0 ? void 0 : _b.languages) {
+          _resolver.languagesPath = options.paths.languages;
+        }
+        const themes2 = yield _registry.loadThemes(_themes);
+        const _defaultTheme = themes2[0];
+        let _currentTheme;
+        yield _registry.loadLanguages(_languages);
+        const COLOR_REPLACEMENTS = {
+          "#000001": "var(--shiki-color-text)",
+          "#000002": "var(--shiki-color-background)",
+          "#000004": "var(--shiki-token-constant)",
+          "#000005": "var(--shiki-token-string)",
+          "#000006": "var(--shiki-token-comment)",
+          "#000007": "var(--shiki-token-keyword)",
+          "#000008": "var(--shiki-token-parameter)",
+          "#000009": "var(--shiki-token-function)",
+          "#000010": "var(--shiki-token-string-expression)",
+          "#000011": "var(--shiki-token-punctuation)",
+          "#000012": "var(--shiki-token-link)"
+        };
+        function fixCssVariablesTheme(theme, colorMap) {
+          theme.bg = COLOR_REPLACEMENTS[theme.bg] || theme.bg;
+          theme.fg = COLOR_REPLACEMENTS[theme.fg] || theme.fg;
+          colorMap.forEach((val, i) => {
+            colorMap[i] = COLOR_REPLACEMENTS[val] || val;
+          });
+        }
+        function getTheme(theme) {
+          const _theme = theme ? _registry.getTheme(theme) : _defaultTheme;
+          if (!_theme) {
+            throw Error(`No theme registration for ${theme}`);
+          }
+          if (!_currentTheme || _currentTheme.name !== _theme.name) {
+            _registry.setTheme(_theme);
+            _currentTheme = _theme;
+          }
+          const _colorMap = _registry.getColorMap();
+          if (_theme.name === "css-variables") {
+            fixCssVariablesTheme(_theme, _colorMap);
+          }
+          return { _theme, _colorMap };
+        }
+        function getGrammar(lang) {
+          const _grammar = _registry.getGrammar(lang);
+          if (!_grammar) {
+            throw Error(`No language registration for ${lang}`);
+          }
+          return { _grammar };
+        }
+        function codeToThemedTokens(code3, lang = "text", theme, options2 = { includeExplanation: true }) {
+          if (isPlaintext(lang)) {
+            const lines = code3.split(/\r\n|\r|\n/);
+            return [...lines.map((line) => [{ content: line }])];
+          }
+          const { _grammar } = getGrammar(lang);
+          const { _theme, _colorMap } = getTheme(theme);
+          return tokenizeWithTheme(_theme, _colorMap, code3, _grammar, options2);
+        }
+        function codeToHtml(code3, arg1 = "text", arg2) {
+          let options2;
+          if (typeof arg1 === "object") {
+            options2 = arg1;
+          } else {
+            options2 = {
+              lang: arg1,
+              theme: arg2
+            };
+          }
+          const tokens = codeToThemedTokens(code3, options2.lang, options2.theme, {
+            includeExplanation: false
+          });
+          const { _theme } = getTheme(options2.theme);
+          return renderToHtml(tokens, {
+            fg: _theme.fg,
+            bg: _theme.bg,
+            lineOptions: options2 === null || options2 === void 0 ? void 0 : options2.lineOptions
+          });
+        }
+        function loadTheme(theme) {
+          return __async(this, null, function* () {
+            yield _registry.loadTheme(theme);
+          });
+        }
+        function loadLanguage(lang) {
+          return __async(this, null, function* () {
+            const _lang = resolveLang(lang);
+            _resolver.addLanguage(_lang);
+            yield _registry.loadLanguage(_lang);
+          });
+        }
+        function getLoadedThemes() {
+          return _registry.getLoadedThemes();
+        }
+        function getLoadedLanguages() {
+          return _registry.getLoadedLanguages();
+        }
+        function getBackgroundColor(theme) {
+          const { _theme } = getTheme(theme);
+          return _theme.bg;
+        }
+        function getForegroundColor(theme) {
+          const { _theme } = getTheme(theme);
+          return _theme.fg;
+        }
+        return {
+          codeToThemedTokens,
+          codeToHtml,
+          getTheme: (theme) => {
+            return getTheme(theme)._theme;
+          },
+          loadTheme,
+          loadLanguage,
+          getBackgroundColor,
+          getForegroundColor,
+          getLoadedThemes,
+          getLoadedLanguages
+        };
+      });
+    }
+    function isPlaintext(lang) {
+      return !lang || ["plaintext", "txt", "text"].includes(lang);
+    }
+    function setOnigasmWASM(path3) {
+      setWasm(path3);
+    }
+    exports.BUNDLED_LANGUAGES = languages;
+    exports.BUNDLED_THEMES = themes;
+    exports.getHighlighter = getHighlighter;
+    exports.loadTheme = fetchTheme;
+    exports.renderToHtml = renderToHtml;
+    exports.setCDN = setCDN;
+    exports.setOnigasmWASM = setOnigasmWASM;
+    exports.setWasm = setWasm;
+    exports.toShikiTheme = toShikiTheme;
+  }
+});
+
+// ../../node_modules/.pnpm/github-slugger@1.4.0/node_modules/github-slugger/regex.js
+var require_regex = __commonJS({
+  "../../node_modules/.pnpm/github-slugger@1.4.0/node_modules/github-slugger/regex.js"(exports, module) {
+    module.exports = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08BE-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D04\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31BB-\u31EF\u3200-\u33FF\u4DB6-\u4DFF\u9FF0-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7C7-\uA7F6\uA828-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB68-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD47-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD-\uDDCF\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC60-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD00-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D-\uD83F\uD87B-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE4-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;
+  }
+});
+
+// ../../node_modules/.pnpm/github-slugger@1.4.0/node_modules/github-slugger/index.js
+var require_github_slugger = __commonJS({
+  "../../node_modules/.pnpm/github-slugger@1.4.0/node_modules/github-slugger/index.js"(exports, module) {
+    var regex2 = require_regex();
+    module.exports = BananaSlug;
+    var own16 = Object.hasOwnProperty;
+    function BananaSlug() {
+      const self2 = this;
+      if (!(self2 instanceof BananaSlug))
+        return new BananaSlug();
+      self2.reset();
+    }
+    BananaSlug.prototype.slug = function(value, maintainCase) {
+      const self2 = this;
+      let slug = slugger(value, maintainCase === true);
+      const originalSlug = slug;
+      while (own16.call(self2.occurrences, slug)) {
+        self2.occurrences[originalSlug]++;
+        slug = originalSlug + "-" + self2.occurrences[originalSlug];
+      }
+      self2.occurrences[slug] = 0;
+      return slug;
+    };
+    BananaSlug.prototype.reset = function() {
+      this.occurrences = /* @__PURE__ */ Object.create(null);
+    };
+    function slugger(string3, maintainCase) {
+      if (typeof string3 !== "string")
+        return "";
+      if (!maintainCase)
+        string3 = string3.toLowerCase();
+      return string3.replace(regex2, "").replace(/ /g, "-");
+    }
+    BananaSlug.slug = slugger;
+  }
+});
+
+// ../../node_modules/.pnpm/bail@2.0.2/node_modules/bail/index.js
+function bail(error) {
+  if (error) {
+    throw error;
+  }
+}
+
+// ../../node_modules/.pnpm/unified@10.1.1/node_modules/unified/lib/index.js
+var import_is_buffer2 = __toESM(require_is_buffer(), 1);
+var import_extend = __toESM(require_extend(), 1);
+
+// ../../node_modules/.pnpm/is-plain-obj@4.0.0/node_modules/is-plain-obj/index.js
+function isPlainObject(value) {
+  if (Object.prototype.toString.call(value) !== "[object Object]") {
+    return false;
+  }
+  const prototype = Object.getPrototypeOf(value);
+  return prototype === null || prototype === Object.prototype;
+}
+
+// ../../node_modules/.pnpm/trough@2.0.2/node_modules/trough/index.js
+function trough() {
+  const fns = [];
+  const pipeline = { run, use };
+  return pipeline;
+  function run(...values) {
+    let middlewareIndex = -1;
+    const callback = values.pop();
+    if (typeof callback !== "function") {
+      throw new TypeError("Expected function as last argument, not " + callback);
+    }
+    next(null, ...values);
+    function next(error, ...output) {
+      const fn = fns[++middlewareIndex];
+      let index3 = -1;
+      if (error) {
+        callback(error);
+        return;
+      }
+      while (++index3 < values.length) {
+        if (output[index3] === null || output[index3] === void 0) {
+          output[index3] = values[index3];
+        }
+      }
+      values = output;
+      if (fn) {
+        wrap(fn, next)(...output);
+      } else {
+        callback(null, ...output);
+      }
+    }
+  }
+  function use(middelware) {
+    if (typeof middelware !== "function") {
+      throw new TypeError("Expected `middelware` to be a function, not " + middelware);
+    }
+    fns.push(middelware);
+    return pipeline;
+  }
+}
+function wrap(middleware, callback) {
+  let called;
+  return wrapped;
+  function wrapped(...parameters) {
+    const fnExpectsCallback = middleware.length > parameters.length;
+    let result;
+    if (fnExpectsCallback) {
+      parameters.push(done);
+    }
+    try {
+      result = middleware(...parameters);
+    } catch (error) {
+      const exception = error;
+      if (fnExpectsCallback && called) {
+        throw exception;
+      }
+      return done(exception);
+    }
+    if (!fnExpectsCallback) {
+      if (result instanceof Promise) {
+        result.then(then, done);
+      } else if (result instanceof Error) {
+        done(result);
+      } else {
+        then(result);
+      }
+    }
+  }
+  function done(error, ...output) {
+    if (!called) {
+      called = true;
+      callback(error, ...output);
+    }
+  }
+  function then(value) {
+    done(null, value);
+  }
+}
+
+// ../../node_modules/.pnpm/vfile@5.2.1/node_modules/vfile/lib/index.js
+var import_is_buffer = __toESM(require_is_buffer(), 1);
+
+// ../../node_modules/.pnpm/unist-util-stringify-position@3.0.0/node_modules/unist-util-stringify-position/index.js
+var own = {}.hasOwnProperty;
+function stringifyPosition(value) {
+  if (!value || typeof value !== "object") {
+    return "";
+  }
+  if (own.call(value, "position") || own.call(value, "type")) {
+    return position(value.position);
+  }
+  if (own.call(value, "start") || own.call(value, "end")) {
+    return position(value);
+  }
+  if (own.call(value, "line") || own.call(value, "column")) {
+    return point(value);
+  }
+  return "";
+}
+function point(point4) {
+  return index(point4 && point4.line) + ":" + index(point4 && point4.column);
+}
+function position(pos) {
+  return point(pos && pos.start) + "-" + point(pos && pos.end);
+}
+function index(value) {
+  return value && typeof value === "number" ? value : 1;
+}
+
+// ../../node_modules/.pnpm/vfile-message@3.1.0/node_modules/vfile-message/index.js
+var VFileMessage = class extends Error {
+  constructor(reason, place, origin) {
+    var parts = [null, null];
+    var position4 = {
+      start: { line: null, column: null },
+      end: { line: null, column: null }
+    };
+    var index3;
+    super();
+    if (typeof place === "string") {
+      origin = place;
+      place = null;
+    }
+    if (typeof origin === "string") {
+      index3 = origin.indexOf(":");
+      if (index3 === -1) {
+        parts[1] = origin;
+      } else {
+        parts[0] = origin.slice(0, index3);
+        parts[1] = origin.slice(index3 + 1);
+      }
+    }
+    if (place) {
+      if ("type" in place || "position" in place) {
+        if (place.position) {
+          position4 = place.position;
+        }
+      } else if ("start" in place || "end" in place) {
+        position4 = place;
+      } else if ("line" in place || "column" in place) {
+        position4.start = place;
+      }
+    }
+    this.name = stringifyPosition(place) || "1:1";
+    this.message = typeof reason === "object" ? reason.message : reason;
+    this.stack = typeof reason === "object" ? reason.stack : "";
+    this.reason = this.message;
+    this.fatal;
+    this.line = position4.start.line;
+    this.column = position4.start.column;
+    this.source = parts[0];
+    this.ruleId = parts[1];
+    this.position = position4;
+    this.actual;
+    this.expected;
+    this.file;
+    this.url;
+    this.note;
+  }
+};
+VFileMessage.prototype.file = "";
+VFileMessage.prototype.name = "";
+VFileMessage.prototype.reason = "";
+VFileMessage.prototype.message = "";
+VFileMessage.prototype.stack = "";
+VFileMessage.prototype.fatal = null;
+VFileMessage.prototype.column = null;
+VFileMessage.prototype.line = null;
+VFileMessage.prototype.source = null;
+VFileMessage.prototype.ruleId = null;
+VFileMessage.prototype.position = null;
+
+// ../../node_modules/.pnpm/vfile@5.2.1/node_modules/vfile/lib/minpath.js
+import { default as default2 } from "path";
+
+// ../../node_modules/.pnpm/vfile@5.2.1/node_modules/vfile/lib/minproc.js
+import { default as default3 } from "process";
+
+// ../../node_modules/.pnpm/vfile@5.2.1/node_modules/vfile/lib/minurl.js
+import { fileURLToPath } from "url";
+
+// ../../node_modules/.pnpm/vfile@5.2.1/node_modules/vfile/lib/minurl.shared.js
+function isUrl(fileURLOrPath) {
+  return fileURLOrPath !== null && typeof fileURLOrPath === "object" && fileURLOrPath.href && fileURLOrPath.origin;
+}
+
+// ../../node_modules/.pnpm/vfile@5.2.1/node_modules/vfile/lib/index.js
+var order = ["history", "path", "basename", "stem", "extname", "dirname"];
+var VFile = class {
+  constructor(value) {
+    let options;
+    if (!value) {
+      options = {};
+    } else if (typeof value === "string" || (0, import_is_buffer.default)(value)) {
+      options = { value };
+    } else if (isUrl(value)) {
+      options = { path: value };
+    } else {
+      options = value;
+    }
+    this.data = {};
+    this.messages = [];
+    this.history = [];
+    this.cwd = default3.cwd();
+    this.value;
+    this.stored;
+    this.result;
+    this.map;
+    let index3 = -1;
+    while (++index3 < order.length) {
+      const prop2 = order[index3];
+      if (prop2 in options && options[prop2] !== void 0) {
+        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
+      }
+    }
+    let prop;
+    for (prop in options) {
+      if (!order.includes(prop))
+        this[prop] = options[prop];
+    }
+  }
+  get path() {
+    return this.history[this.history.length - 1];
+  }
+  set path(path3) {
+    if (isUrl(path3)) {
+      path3 = fileURLToPath(path3);
+    }
+    assertNonEmpty(path3, "path");
+    if (this.path !== path3) {
+      this.history.push(path3);
+    }
+  }
+  get dirname() {
+    return typeof this.path === "string" ? default2.dirname(this.path) : void 0;
+  }
+  set dirname(dirname) {
+    assertPath(this.basename, "dirname");
+    this.path = default2.join(dirname || "", this.basename);
+  }
+  get basename() {
+    return typeof this.path === "string" ? default2.basename(this.path) : void 0;
+  }
+  set basename(basename) {
+    assertNonEmpty(basename, "basename");
+    assertPart(basename, "basename");
+    this.path = default2.join(this.dirname || "", basename);
+  }
+  get extname() {
+    return typeof this.path === "string" ? default2.extname(this.path) : void 0;
+  }
+  set extname(extname) {
+    assertPart(extname, "extname");
+    assertPath(this.dirname, "extname");
+    if (extname) {
+      if (extname.charCodeAt(0) !== 46) {
+        throw new Error("`extname` must start with `.`");
+      }
+      if (extname.includes(".", 1)) {
+        throw new Error("`extname` cannot contain multiple dots");
+      }
+    }
+    this.path = default2.join(this.dirname, this.stem + (extname || ""));
+  }
+  get stem() {
+    return typeof this.path === "string" ? default2.basename(this.path, this.extname) : void 0;
+  }
+  set stem(stem) {
+    assertNonEmpty(stem, "stem");
+    assertPart(stem, "stem");
+    this.path = default2.join(this.dirname || "", stem + (this.extname || ""));
+  }
+  toString(encoding) {
+    return (this.value || "").toString(encoding);
+  }
+  message(reason, place, origin) {
+    const message = new VFileMessage(reason, place, origin);
+    if (this.path) {
+      message.name = this.path + ":" + message.name;
+      message.file = this.path;
+    }
+    message.fatal = false;
+    this.messages.push(message);
+    return message;
+  }
+  info(reason, place, origin) {
+    const message = this.message(reason, place, origin);
+    message.fatal = null;
+    return message;
+  }
+  fail(reason, place, origin) {
+    const message = this.message(reason, place, origin);
+    message.fatal = true;
+    throw message;
+  }
+};
+function assertPart(part, name3) {
+  if (part && part.includes(default2.sep)) {
+    throw new Error("`" + name3 + "` cannot be a path: did not expect `" + default2.sep + "`");
+  }
+}
+function assertNonEmpty(part, name3) {
+  if (!part) {
+    throw new Error("`" + name3 + "` cannot be empty");
+  }
+}
+function assertPath(path3, name3) {
+  if (!path3) {
+    throw new Error("Setting `" + name3 + "` requires `path` to be set too");
+  }
+}
+
+// ../../node_modules/.pnpm/unified@10.1.1/node_modules/unified/lib/index.js
+var unified = base().freeze();
+var own2 = {}.hasOwnProperty;
+function base() {
+  const transformers = trough();
+  const attachers = [];
+  let namespace = {};
+  let frozen;
+  let freezeIndex = -1;
+  processor.data = data2;
+  processor.Parser = void 0;
+  processor.Compiler = void 0;
+  processor.freeze = freeze;
+  processor.attachers = attachers;
+  processor.use = use;
+  processor.parse = parse5;
+  processor.stringify = stringify4;
+  processor.run = run;
+  processor.runSync = runSync;
+  processor.process = process2;
+  processor.processSync = processSync;
+  return processor;
+  function processor() {
+    const destination = base();
+    let index3 = -1;
+    while (++index3 < attachers.length) {
+      destination.use(...attachers[index3]);
+    }
+    destination.data((0, import_extend.default)(true, {}, namespace));
+    return destination;
+  }
+  function data2(key, value) {
+    if (typeof key === "string") {
+      if (arguments.length === 2) {
+        assertUnfrozen("data", frozen);
+        namespace[key] = value;
+        return processor;
+      }
+      return own2.call(namespace, key) && namespace[key] || null;
+    }
+    if (key) {
+      assertUnfrozen("data", frozen);
+      namespace = key;
+      return processor;
+    }
+    return namespace;
+  }
+  function freeze() {
+    if (frozen) {
+      return processor;
+    }
+    while (++freezeIndex < attachers.length) {
+      const [attacher, ...options] = attachers[freezeIndex];
+      if (options[0] === false) {
+        continue;
+      }
+      if (options[0] === true) {
+        options[1] = void 0;
+      }
+      const transformer = attacher.call(processor, ...options);
+      if (typeof transformer === "function") {
+        transformers.use(transformer);
+      }
+    }
+    frozen = true;
+    freezeIndex = Number.POSITIVE_INFINITY;
+    return processor;
+  }
+  function use(value, ...options) {
+    let settings;
+    assertUnfrozen("use", frozen);
+    if (value === null || value === void 0) {
+    } else if (typeof value === "function") {
+      addPlugin(value, ...options);
+    } else if (typeof value === "object") {
+      if (Array.isArray(value)) {
+        addList(value);
+      } else {
+        addPreset(value);
+      }
+    } else {
+      throw new TypeError("Expected usable value, not `" + value + "`");
+    }
+    if (settings) {
+      namespace.settings = Object.assign(namespace.settings || {}, settings);
+    }
+    return processor;
+    function add(value2) {
+      if (typeof value2 === "function") {
+        addPlugin(value2);
+      } else if (typeof value2 === "object") {
+        if (Array.isArray(value2)) {
+          const [plugin, ...options2] = value2;
+          addPlugin(plugin, ...options2);
+        } else {
+          addPreset(value2);
+        }
+      } else {
+        throw new TypeError("Expected usable value, not `" + value2 + "`");
+      }
+    }
+    function addPreset(result) {
+      addList(result.plugins);
+      if (result.settings) {
+        settings = Object.assign(settings || {}, result.settings);
+      }
+    }
+    function addList(plugins) {
+      let index3 = -1;
+      if (plugins === null || plugins === void 0) {
+      } else if (Array.isArray(plugins)) {
+        while (++index3 < plugins.length) {
+          const thing = plugins[index3];
+          add(thing);
+        }
+      } else {
+        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
+      }
+    }
+    function addPlugin(plugin, value2) {
+      let index3 = -1;
+      let entry;
+      while (++index3 < attachers.length) {
+        if (attachers[index3][0] === plugin) {
+          entry = attachers[index3];
+          break;
+        }
+      }
+      if (entry) {
+        if (isPlainObject(entry[1]) && isPlainObject(value2)) {
+          value2 = (0, import_extend.default)(true, entry[1], value2);
+        }
+        entry[1] = value2;
+      } else {
+        attachers.push([...arguments]);
+      }
+    }
+  }
+  function parse5(doc) {
+    processor.freeze();
+    const file = vfile(doc);
+    const Parser4 = processor.Parser;
+    assertParser("parse", Parser4);
+    if (newable(Parser4, "parse")) {
+      return new Parser4(String(file), file).parse();
+    }
+    return Parser4(String(file), file);
+  }
+  function stringify4(node, doc) {
+    processor.freeze();
+    const file = vfile(doc);
+    const Compiler = processor.Compiler;
+    assertCompiler("stringify", Compiler);
+    assertNode(node);
+    if (newable(Compiler, "compile")) {
+      return new Compiler(node, file).compile();
+    }
+    return Compiler(node, file);
+  }
+  function run(node, doc, callback) {
+    assertNode(node);
+    processor.freeze();
+    if (!callback && typeof doc === "function") {
+      callback = doc;
+      doc = void 0;
+    }
+    if (!callback) {
+      return new Promise(executor);
+    }
+    executor(null, callback);
+    function executor(resolve, reject) {
+      transformers.run(node, vfile(doc), done);
+      function done(error, tree, file) {
+        tree = tree || node;
+        if (error) {
+          reject(error);
+        } else if (resolve) {
+          resolve(tree);
+        } else {
+          callback(null, tree, file);
+        }
+      }
+    }
+  }
+  function runSync(node, file) {
+    let result;
+    let complete;
+    processor.run(node, file, done);
+    assertDone("runSync", "run", complete);
+    return result;
+    function done(error, tree) {
+      bail(error);
+      result = tree;
+      complete = true;
+    }
+  }
+  function process2(doc, callback) {
+    processor.freeze();
+    assertParser("process", processor.Parser);
+    assertCompiler("process", processor.Compiler);
+    if (!callback) {
+      return new Promise(executor);
+    }
+    executor(null, callback);
+    function executor(resolve, reject) {
+      const file = vfile(doc);
+      processor.run(processor.parse(file), file, (error, tree, file2) => {
+        if (error || !tree || !file2) {
+          done(error);
+        } else {
+          const result = processor.stringify(tree, file2);
+          if (result === void 0 || result === null) {
+          } else if (looksLikeAVFileValue(result)) {
+            file2.value = result;
+          } else {
+            file2.result = result;
+          }
+          done(error, file2);
+        }
+      });
+      function done(error, file2) {
+        if (error || !file2) {
+          reject(error);
+        } else if (resolve) {
+          resolve(file2);
+        } else {
+          callback(null, file2);
+        }
+      }
+    }
+  }
+  function processSync(doc) {
+    let complete;
+    processor.freeze();
+    assertParser("processSync", processor.Parser);
+    assertCompiler("processSync", processor.Compiler);
+    const file = vfile(doc);
+    processor.process(file, done);
+    assertDone("processSync", "process", complete);
+    return file;
+    function done(error) {
+      complete = true;
+      bail(error);
+    }
+  }
+}
+function newable(value, name3) {
+  return typeof value === "function" && value.prototype && (keys(value.prototype) || name3 in value.prototype);
+}
+function keys(value) {
+  let key;
+  for (key in value) {
+    if (own2.call(value, key)) {
+      return true;
+    }
+  }
+  return false;
+}
+function assertParser(name3, value) {
+  if (typeof value !== "function") {
+    throw new TypeError("Cannot `" + name3 + "` without `Parser`");
+  }
+}
+function assertCompiler(name3, value) {
+  if (typeof value !== "function") {
+    throw new TypeError("Cannot `" + name3 + "` without `Compiler`");
+  }
+}
+function assertUnfrozen(name3, frozen) {
+  if (frozen) {
+    throw new Error("Cannot call `" + name3 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
+  }
+}
+function assertNode(node) {
+  if (!isPlainObject(node) || typeof node.type !== "string") {
+    throw new TypeError("Expected node, got `" + node + "`");
+  }
+}
+function assertDone(name3, asyncName, complete) {
+  if (!complete) {
+    throw new Error("`" + name3 + "` finished async. Use `" + asyncName + "` instead");
+  }
+}
+function vfile(value) {
+  return looksLikeAVFile(value) ? value : new VFile(value);
+}
+function looksLikeAVFile(value) {
+  return Boolean(value && typeof value === "object" && "message" in value && "messages" in value);
+}
+function looksLikeAVFileValue(value) {
+  return typeof value === "string" || (0, import_is_buffer2.default)(value);
+}
+
+// ../../node_modules/.pnpm/acorn@8.7.0/node_modules/acorn/dist/acorn.mjs
+var reservedWords = {
+  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
+  5: "class enum extends super const export import",
+  6: "enum",
+  strict: "implements interface let package private protected public static yield",
+  strictBind: "eval arguments"
+};
+var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
+var keywords$1 = {
+  5: ecma5AndLessKeywords,
+  "5module": ecma5AndLessKeywords + " export import",
+  6: ecma5AndLessKeywords + " const class extends export import super"
+};
+var keywordRelationalOperator = /^in(stanceof)?$/;
+var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
+var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
+var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
+var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
+nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
+var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
+var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
+function isInAstralSet(code3, set) {
+  var pos = 65536;
+  for (var i = 0; i < set.length; i += 2) {
+    pos += set[i];
+    if (pos > code3) {
+      return false;
+    }
+    pos += set[i + 1];
+    if (pos >= code3) {
+      return true;
+    }
+  }
+}
+function isIdentifierStart(code3, astral) {
+  if (code3 < 65) {
+    return code3 === 36;
+  }
+  if (code3 < 91) {
+    return true;
+  }
+  if (code3 < 97) {
+    return code3 === 95;
+  }
+  if (code3 < 123) {
+    return true;
+  }
+  if (code3 <= 65535) {
+    return code3 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code3));
+  }
+  if (astral === false) {
+    return false;
+  }
+  return isInAstralSet(code3, astralIdentifierStartCodes);
+}
+function isIdentifierChar(code3, astral) {
+  if (code3 < 48) {
+    return code3 === 36;
+  }
+  if (code3 < 58) {
+    return true;
+  }
+  if (code3 < 65) {
+    return false;
+  }
+  if (code3 < 91) {
+    return true;
+  }
+  if (code3 < 97) {
+    return code3 === 95;
+  }
+  if (code3 < 123) {
+    return true;
+  }
+  if (code3 <= 65535) {
+    return code3 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code3));
+  }
+  if (astral === false) {
+    return false;
+  }
+  return isInAstralSet(code3, astralIdentifierStartCodes) || isInAstralSet(code3, astralIdentifierCodes);
+}
+var TokenType = function TokenType2(label, conf) {
+  if (conf === void 0)
+    conf = {};
+  this.label = label;
+  this.keyword = conf.keyword;
+  this.beforeExpr = !!conf.beforeExpr;
+  this.startsExpr = !!conf.startsExpr;
+  this.isLoop = !!conf.isLoop;
+  this.isAssign = !!conf.isAssign;
+  this.prefix = !!conf.prefix;
+  this.postfix = !!conf.postfix;
+  this.binop = conf.binop || null;
+  this.updateContext = null;
+};
+function binop(name3, prec) {
+  return new TokenType(name3, { beforeExpr: true, binop: prec });
+}
+var beforeExpr = { beforeExpr: true };
+var startsExpr = { startsExpr: true };
+var keywords = {};
+function kw(name3, options) {
+  if (options === void 0)
+    options = {};
+  options.keyword = name3;
+  return keywords[name3] = new TokenType(name3, options);
+}
+var types$1 = {
+  num: new TokenType("num", startsExpr),
+  regexp: new TokenType("regexp", startsExpr),
+  string: new TokenType("string", startsExpr),
+  name: new TokenType("name", startsExpr),
+  privateId: new TokenType("privateId", startsExpr),
+  eof: new TokenType("eof"),
+  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
+  bracketR: new TokenType("]"),
+  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
+  braceR: new TokenType("}"),
+  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
+  parenR: new TokenType(")"),
+  comma: new TokenType(",", beforeExpr),
+  semi: new TokenType(";", beforeExpr),
+  colon: new TokenType(":", beforeExpr),
+  dot: new TokenType("."),
+  question: new TokenType("?", beforeExpr),
+  questionDot: new TokenType("?."),
+  arrow: new TokenType("=>", beforeExpr),
+  template: new TokenType("template"),
+  invalidTemplate: new TokenType("invalidTemplate"),
+  ellipsis: new TokenType("...", beforeExpr),
+  backQuote: new TokenType("`", startsExpr),
+  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
+  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
+  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
+  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
+  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
+  logicalOR: binop("||", 1),
+  logicalAND: binop("&&", 2),
+  bitwiseOR: binop("|", 3),
+  bitwiseXOR: binop("^", 4),
+  bitwiseAND: binop("&", 5),
+  equality: binop("==/!=/===/!==", 6),
+  relational: binop("</>/<=/>=", 7),
+  bitShift: binop("<</>>/>>>", 8),
+  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
+  modulo: binop("%", 10),
+  star: binop("*", 10),
+  slash: binop("/", 10),
+  starstar: new TokenType("**", { beforeExpr: true }),
+  coalesce: binop("??", 1),
+  _break: kw("break"),
+  _case: kw("case", beforeExpr),
+  _catch: kw("catch"),
+  _continue: kw("continue"),
+  _debugger: kw("debugger"),
+  _default: kw("default", beforeExpr),
+  _do: kw("do", { isLoop: true, beforeExpr: true }),
+  _else: kw("else", beforeExpr),
+  _finally: kw("finally"),
+  _for: kw("for", { isLoop: true }),
+  _function: kw("function", startsExpr),
+  _if: kw("if"),
+  _return: kw("return", beforeExpr),
+  _switch: kw("switch"),
+  _throw: kw("throw", beforeExpr),
+  _try: kw("try"),
+  _var: kw("var"),
+  _const: kw("const"),
+  _while: kw("while", { isLoop: true }),
+  _with: kw("with"),
+  _new: kw("new", { beforeExpr: true, startsExpr: true }),
+  _this: kw("this", startsExpr),
+  _super: kw("super", startsExpr),
+  _class: kw("class", startsExpr),
+  _extends: kw("extends", beforeExpr),
+  _export: kw("export"),
+  _import: kw("import", startsExpr),
+  _null: kw("null", startsExpr),
+  _true: kw("true", startsExpr),
+  _false: kw("false", startsExpr),
+  _in: kw("in", { beforeExpr: true, binop: 7 }),
+  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
+  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
+  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
+  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
+};
+var lineBreak = /\r\n?|\n|\u2028|\u2029/;
+var lineBreakG = new RegExp(lineBreak.source, "g");
+function isNewLine(code3) {
+  return code3 === 10 || code3 === 13 || code3 === 8232 || code3 === 8233;
+}
+function nextLineBreak(code3, from, end) {
+  if (end === void 0)
+    end = code3.length;
+  for (var i = from; i < end; i++) {
+    var next = code3.charCodeAt(i);
+    if (isNewLine(next)) {
+      return i < end - 1 && next === 13 && code3.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
+    }
+  }
+  return -1;
+}
+var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
+var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
+var ref = Object.prototype;
+var hasOwnProperty = ref.hasOwnProperty;
+var toString = ref.toString;
+var hasOwn = Object.hasOwn || function(obj, propName) {
+  return hasOwnProperty.call(obj, propName);
+};
+var isArray = Array.isArray || function(obj) {
+  return toString.call(obj) === "[object Array]";
+};
+function wordsRegexp(words) {
+  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
+}
+var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
+var Position = function Position2(line, col) {
+  this.line = line;
+  this.column = col;
+};
+Position.prototype.offset = function offset(n) {
+  return new Position(this.line, this.column + n);
+};
+var SourceLocation = function SourceLocation2(p, start3, end) {
+  this.start = start3;
+  this.end = end;
+  if (p.sourceFile !== null) {
+    this.source = p.sourceFile;
+  }
+};
+function getLineInfo(input, offset2) {
+  for (var line = 1, cur = 0; ; ) {
+    var nextBreak = nextLineBreak(input, cur, offset2);
+    if (nextBreak < 0) {
+      return new Position(line, offset2 - cur);
+    }
+    ++line;
+    cur = nextBreak;
+  }
+}
+var defaultOptions = {
+  ecmaVersion: null,
+  sourceType: "script",
+  onInsertedSemicolon: null,
+  onTrailingComma: null,
+  allowReserved: null,
+  allowReturnOutsideFunction: false,
+  allowImportExportEverywhere: false,
+  allowAwaitOutsideFunction: null,
+  allowSuperOutsideMethod: null,
+  allowHashBang: false,
+  locations: false,
+  onToken: null,
+  onComment: null,
+  ranges: false,
+  program: null,
+  sourceFile: null,
+  directSourceFile: null,
+  preserveParens: false
+};
+var warnedAboutEcmaVersion = false;
+function getOptions(opts) {
+  var options = {};
+  for (var opt in defaultOptions) {
+    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
+  }
+  if (options.ecmaVersion === "latest") {
+    options.ecmaVersion = 1e8;
+  } else if (options.ecmaVersion == null) {
+    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
+      warnedAboutEcmaVersion = true;
+      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
+    }
+    options.ecmaVersion = 11;
+  } else if (options.ecmaVersion >= 2015) {
+    options.ecmaVersion -= 2009;
+  }
+  if (options.allowReserved == null) {
+    options.allowReserved = options.ecmaVersion < 5;
+  }
+  if (isArray(options.onToken)) {
+    var tokens = options.onToken;
+    options.onToken = function(token) {
+      return tokens.push(token);
+    };
+  }
+  if (isArray(options.onComment)) {
+    options.onComment = pushComment(options, options.onComment);
+  }
+  return options;
+}
+function pushComment(options, array) {
+  return function(block, text7, start3, end, startLoc, endLoc) {
+    var comment3 = {
+      type: block ? "Block" : "Line",
+      value: text7,
+      start: start3,
+      end
+    };
+    if (options.locations) {
+      comment3.loc = new SourceLocation(this, startLoc, endLoc);
+    }
+    if (options.ranges) {
+      comment3.range = [start3, end];
+    }
+    array.push(comment3);
+  };
+}
+var SCOPE_TOP = 1;
+var SCOPE_FUNCTION = 2;
+var SCOPE_ASYNC = 4;
+var SCOPE_GENERATOR = 8;
+var SCOPE_ARROW = 16;
+var SCOPE_SIMPLE_CATCH = 32;
+var SCOPE_SUPER = 64;
+var SCOPE_DIRECT_SUPER = 128;
+var SCOPE_CLASS_STATIC_BLOCK = 256;
+var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
+function functionFlags(async, generator) {
+  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
+}
+var BIND_NONE = 0;
+var BIND_VAR = 1;
+var BIND_LEXICAL = 2;
+var BIND_FUNCTION = 3;
+var BIND_SIMPLE_CATCH = 4;
+var BIND_OUTSIDE = 5;
+var Parser = function Parser2(options, input, startPos) {
+  this.options = options = getOptions(options);
+  this.sourceFile = options.sourceFile;
+  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
+  var reserved = "";
+  if (options.allowReserved !== true) {
+    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
+    if (options.sourceType === "module") {
+      reserved += " await";
+    }
+  }
+  this.reservedWords = wordsRegexp(reserved);
+  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
+  this.reservedWordsStrict = wordsRegexp(reservedStrict);
+  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
+  this.input = String(input);
+  this.containsEsc = false;
+  if (startPos) {
+    this.pos = startPos;
+    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
+    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
+  } else {
+    this.pos = this.lineStart = 0;
+    this.curLine = 1;
+  }
+  this.type = types$1.eof;
+  this.value = null;
+  this.start = this.end = this.pos;
+  this.startLoc = this.endLoc = this.curPosition();
+  this.lastTokEndLoc = this.lastTokStartLoc = null;
+  this.lastTokStart = this.lastTokEnd = this.pos;
+  this.context = this.initialContext();
+  this.exprAllowed = true;
+  this.inModule = options.sourceType === "module";
+  this.strict = this.inModule || this.strictDirective(this.pos);
+  this.potentialArrowAt = -1;
+  this.potentialArrowInForAwait = false;
+  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
+  this.labels = [];
+  this.undefinedExports = /* @__PURE__ */ Object.create(null);
+  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
+    this.skipLineComment(2);
+  }
+  this.scopeStack = [];
+  this.enterScope(SCOPE_TOP);
+  this.regexpState = null;
+  this.privateNameStack = [];
+};
+var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
+Parser.prototype.parse = function parse() {
+  var node = this.options.program || this.startNode();
+  this.nextToken();
+  return this.parseTopLevel(node);
+};
+prototypeAccessors.inFunction.get = function() {
+  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
+};
+prototypeAccessors.inGenerator.get = function() {
+  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
+};
+prototypeAccessors.inAsync.get = function() {
+  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
+};
+prototypeAccessors.canAwait.get = function() {
+  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
+    var scope = this.scopeStack[i];
+    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
+      return false;
+    }
+    if (scope.flags & SCOPE_FUNCTION) {
+      return (scope.flags & SCOPE_ASYNC) > 0;
+    }
+  }
+  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
+};
+prototypeAccessors.allowSuper.get = function() {
+  var ref2 = this.currentThisScope();
+  var flags = ref2.flags;
+  var inClassFieldInit = ref2.inClassFieldInit;
+  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
+};
+prototypeAccessors.allowDirectSuper.get = function() {
+  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
+};
+prototypeAccessors.treatFunctionsAsVar.get = function() {
+  return this.treatFunctionsAsVarInScope(this.currentScope());
+};
+prototypeAccessors.allowNewDotTarget.get = function() {
+  var ref2 = this.currentThisScope();
+  var flags = ref2.flags;
+  var inClassFieldInit = ref2.inClassFieldInit;
+  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
+};
+prototypeAccessors.inClassStaticBlock.get = function() {
+  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
+};
+Parser.extend = function extend2() {
+  var plugins = [], len = arguments.length;
+  while (len--)
+    plugins[len] = arguments[len];
+  var cls = this;
+  for (var i = 0; i < plugins.length; i++) {
+    cls = plugins[i](cls);
+  }
+  return cls;
+};
+Parser.parse = function parse2(input, options) {
+  return new this(options, input).parse();
+};
+Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
+  var parser2 = new this(options, input, pos);
+  parser2.nextToken();
+  return parser2.parseExpression();
+};
+Parser.tokenizer = function tokenizer(input, options) {
+  return new this(options, input);
+};
+Object.defineProperties(Parser.prototype, prototypeAccessors);
+var pp$9 = Parser.prototype;
+var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
+pp$9.strictDirective = function(start3) {
+  for (; ; ) {
+    skipWhiteSpace.lastIndex = start3;
+    start3 += skipWhiteSpace.exec(this.input)[0].length;
+    var match = literal.exec(this.input.slice(start3));
+    if (!match) {
+      return false;
+    }
+    if ((match[1] || match[2]) === "use strict") {
+      skipWhiteSpace.lastIndex = start3 + match[0].length;
+      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
+      var next = this.input.charAt(end);
+      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
+    }
+    start3 += match[0].length;
+    skipWhiteSpace.lastIndex = start3;
+    start3 += skipWhiteSpace.exec(this.input)[0].length;
+    if (this.input[start3] === ";") {
+      start3++;
+    }
+  }
+};
+pp$9.eat = function(type2) {
+  if (this.type === type2) {
+    this.next();
+    return true;
+  } else {
+    return false;
+  }
+};
+pp$9.isContextual = function(name3) {
+  return this.type === types$1.name && this.value === name3 && !this.containsEsc;
+};
+pp$9.eatContextual = function(name3) {
+  if (!this.isContextual(name3)) {
+    return false;
+  }
+  this.next();
+  return true;
+};
+pp$9.expectContextual = function(name3) {
+  if (!this.eatContextual(name3)) {
+    this.unexpected();
+  }
+};
+pp$9.canInsertSemicolon = function() {
+  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
+};
+pp$9.insertSemicolon = function() {
+  if (this.canInsertSemicolon()) {
+    if (this.options.onInsertedSemicolon) {
+      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
+    }
+    return true;
+  }
+};
+pp$9.semicolon = function() {
+  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
+    this.unexpected();
+  }
+};
+pp$9.afterTrailingComma = function(tokType, notNext) {
+  if (this.type === tokType) {
+    if (this.options.onTrailingComma) {
+      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
+    }
+    if (!notNext) {
+      this.next();
+    }
+    return true;
+  }
+};
+pp$9.expect = function(type2) {
+  this.eat(type2) || this.unexpected();
+};
+pp$9.unexpected = function(pos) {
+  this.raise(pos != null ? pos : this.start, "Unexpected token");
+};
+function DestructuringErrors() {
+  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
+}
+pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
+  if (!refDestructuringErrors) {
+    return;
+  }
+  if (refDestructuringErrors.trailingComma > -1) {
+    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
+  }
+  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
+  if (parens > -1) {
+    this.raiseRecoverable(parens, "Parenthesized pattern");
+  }
+};
+pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
+  if (!refDestructuringErrors) {
+    return false;
+  }
+  var shorthandAssign = refDestructuringErrors.shorthandAssign;
+  var doubleProto = refDestructuringErrors.doubleProto;
+  if (!andThrow) {
+    return shorthandAssign >= 0 || doubleProto >= 0;
+  }
+  if (shorthandAssign >= 0) {
+    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
+  }
+  if (doubleProto >= 0) {
+    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
+  }
+};
+pp$9.checkYieldAwaitInDefaultParams = function() {
+  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
+    this.raise(this.yieldPos, "Yield expression cannot be a default value");
+  }
+  if (this.awaitPos) {
+    this.raise(this.awaitPos, "Await expression cannot be a default value");
+  }
+};
+pp$9.isSimpleAssignTarget = function(expr) {
+  if (expr.type === "ParenthesizedExpression") {
+    return this.isSimpleAssignTarget(expr.expression);
+  }
+  return expr.type === "Identifier" || expr.type === "MemberExpression";
+};
+var pp$8 = Parser.prototype;
+pp$8.parseTopLevel = function(node) {
+  var exports = /* @__PURE__ */ Object.create(null);
+  if (!node.body) {
+    node.body = [];
+  }
+  while (this.type !== types$1.eof) {
+    var stmt = this.parseStatement(null, true, exports);
+    node.body.push(stmt);
+  }
+  if (this.inModule) {
+    for (var i = 0, list3 = Object.keys(this.undefinedExports); i < list3.length; i += 1) {
+      var name3 = list3[i];
+      this.raiseRecoverable(this.undefinedExports[name3].start, "Export '" + name3 + "' is not defined");
+    }
+  }
+  this.adaptDirectivePrologue(node.body);
+  this.next();
+  node.sourceType = this.options.sourceType;
+  return this.finishNode(node, "Program");
+};
+var loopLabel = { kind: "loop" };
+var switchLabel = { kind: "switch" };
+pp$8.isLet = function(context) {
+  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
+    return false;
+  }
+  skipWhiteSpace.lastIndex = this.pos;
+  var skip = skipWhiteSpace.exec(this.input);
+  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
+  if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
+    return true;
+  }
+  if (context) {
+    return false;
+  }
+  if (nextCh === 123) {
+    return true;
+  }
+  if (isIdentifierStart(nextCh, true)) {
+    var pos = next + 1;
+    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
+      ++pos;
+    }
+    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
+      return true;
+    }
+    var ident = this.input.slice(next, pos);
+    if (!keywordRelationalOperator.test(ident)) {
+      return true;
+    }
+  }
+  return false;
+};
+pp$8.isAsyncFunction = function() {
+  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
+    return false;
+  }
+  skipWhiteSpace.lastIndex = this.pos;
+  var skip = skipWhiteSpace.exec(this.input);
+  var next = this.pos + skip[0].length, after;
+  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
+};
+pp$8.parseStatement = function(context, topLevel, exports) {
+  var starttype = this.type, node = this.startNode(), kind;
+  if (this.isLet(context)) {
+    starttype = types$1._var;
+    kind = "let";
+  }
+  switch (starttype) {
+    case types$1._break:
+    case types$1._continue:
+      return this.parseBreakContinueStatement(node, starttype.keyword);
+    case types$1._debugger:
+      return this.parseDebuggerStatement(node);
+    case types$1._do:
+      return this.parseDoStatement(node);
+    case types$1._for:
+      return this.parseForStatement(node);
+    case types$1._function:
+      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
+        this.unexpected();
+      }
+      return this.parseFunctionStatement(node, false, !context);
+    case types$1._class:
+      if (context) {
+        this.unexpected();
+      }
+      return this.parseClass(node, true);
+    case types$1._if:
+      return this.parseIfStatement(node);
+    case types$1._return:
+      return this.parseReturnStatement(node);
+    case types$1._switch:
+      return this.parseSwitchStatement(node);
+    case types$1._throw:
+      return this.parseThrowStatement(node);
+    case types$1._try:
+      return this.parseTryStatement(node);
+    case types$1._const:
+    case types$1._var:
+      kind = kind || this.value;
+      if (context && kind !== "var") {
+        this.unexpected();
+      }
+      return this.parseVarStatement(node, kind);
+    case types$1._while:
+      return this.parseWhileStatement(node);
+    case types$1._with:
+      return this.parseWithStatement(node);
+    case types$1.braceL:
+      return this.parseBlock(true, node);
+    case types$1.semi:
+      return this.parseEmptyStatement(node);
+    case types$1._export:
+    case types$1._import:
+      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
+        skipWhiteSpace.lastIndex = this.pos;
+        var skip = skipWhiteSpace.exec(this.input);
+        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
+        if (nextCh === 40 || nextCh === 46) {
+          return this.parseExpressionStatement(node, this.parseExpression());
+        }
+      }
+      if (!this.options.allowImportExportEverywhere) {
+        if (!topLevel) {
+          this.raise(this.start, "'import' and 'export' may only appear at the top level");
+        }
+        if (!this.inModule) {
+          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
+        }
+      }
+      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
+    default:
+      if (this.isAsyncFunction()) {
+        if (context) {
+          this.unexpected();
+        }
+        this.next();
+        return this.parseFunctionStatement(node, true, !context);
+      }
+      var maybeName = this.value, expr = this.parseExpression();
+      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
+        return this.parseLabeledStatement(node, maybeName, expr, context);
+      } else {
+        return this.parseExpressionStatement(node, expr);
+      }
+  }
+};
+pp$8.parseBreakContinueStatement = function(node, keyword) {
+  var isBreak = keyword === "break";
+  this.next();
+  if (this.eat(types$1.semi) || this.insertSemicolon()) {
+    node.label = null;
+  } else if (this.type !== types$1.name) {
+    this.unexpected();
+  } else {
+    node.label = this.parseIdent();
+    this.semicolon();
+  }
+  var i = 0;
+  for (; i < this.labels.length; ++i) {
+    var lab = this.labels[i];
+    if (node.label == null || lab.name === node.label.name) {
+      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
+        break;
+      }
+      if (node.label && isBreak) {
+        break;
+      }
+    }
+  }
+  if (i === this.labels.length) {
+    this.raise(node.start, "Unsyntactic " + keyword);
+  }
+  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
+};
+pp$8.parseDebuggerStatement = function(node) {
+  this.next();
+  this.semicolon();
+  return this.finishNode(node, "DebuggerStatement");
+};
+pp$8.parseDoStatement = function(node) {
+  this.next();
+  this.labels.push(loopLabel);
+  node.body = this.parseStatement("do");
+  this.labels.pop();
+  this.expect(types$1._while);
+  node.test = this.parseParenExpression();
+  if (this.options.ecmaVersion >= 6) {
+    this.eat(types$1.semi);
+  } else {
+    this.semicolon();
+  }
+  return this.finishNode(node, "DoWhileStatement");
+};
+pp$8.parseForStatement = function(node) {
+  this.next();
+  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
+  this.labels.push(loopLabel);
+  this.enterScope(0);
+  this.expect(types$1.parenL);
+  if (this.type === types$1.semi) {
+    if (awaitAt > -1) {
+      this.unexpected(awaitAt);
+    }
+    return this.parseFor(node, null);
+  }
+  var isLet = this.isLet();
+  if (this.type === types$1._var || this.type === types$1._const || isLet) {
+    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
+    this.next();
+    this.parseVar(init$1, true, kind);
+    this.finishNode(init$1, "VariableDeclaration");
+    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
+      if (this.options.ecmaVersion >= 9) {
+        if (this.type === types$1._in) {
+          if (awaitAt > -1) {
+            this.unexpected(awaitAt);
+          }
+        } else {
+          node.await = awaitAt > -1;
+        }
+      }
+      return this.parseForIn(node, init$1);
+    }
+    if (awaitAt > -1) {
+      this.unexpected(awaitAt);
+    }
+    return this.parseFor(node, init$1);
+  }
+  var startsWithLet = this.isContextual("let"), isForOf = false;
+  var refDestructuringErrors = new DestructuringErrors();
+  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
+  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
+    if (this.options.ecmaVersion >= 9) {
+      if (this.type === types$1._in) {
+        if (awaitAt > -1) {
+          this.unexpected(awaitAt);
+        }
+      } else {
+        node.await = awaitAt > -1;
+      }
+    }
+    if (startsWithLet && isForOf) {
+      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
+    }
+    this.toAssignable(init, false, refDestructuringErrors);
+    this.checkLValPattern(init);
+    return this.parseForIn(node, init);
+  } else {
+    this.checkExpressionErrors(refDestructuringErrors, true);
+  }
+  if (awaitAt > -1) {
+    this.unexpected(awaitAt);
+  }
+  return this.parseFor(node, init);
+};
+pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
+  this.next();
+  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
+};
+pp$8.parseIfStatement = function(node) {
+  this.next();
+  node.test = this.parseParenExpression();
+  node.consequent = this.parseStatement("if");
+  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
+  return this.finishNode(node, "IfStatement");
+};
+pp$8.parseReturnStatement = function(node) {
+  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
+    this.raise(this.start, "'return' outside of function");
+  }
+  this.next();
+  if (this.eat(types$1.semi) || this.insertSemicolon()) {
+    node.argument = null;
+  } else {
+    node.argument = this.parseExpression();
+    this.semicolon();
+  }
+  return this.finishNode(node, "ReturnStatement");
+};
+pp$8.parseSwitchStatement = function(node) {
+  this.next();
+  node.discriminant = this.parseParenExpression();
+  node.cases = [];
+  this.expect(types$1.braceL);
+  this.labels.push(switchLabel);
+  this.enterScope(0);
+  var cur;
+  for (var sawDefault = false; this.type !== types$1.braceR; ) {
+    if (this.type === types$1._case || this.type === types$1._default) {
+      var isCase = this.type === types$1._case;
+      if (cur) {
+        this.finishNode(cur, "SwitchCase");
+      }
+      node.cases.push(cur = this.startNode());
+      cur.consequent = [];
+      this.next();
+      if (isCase) {
+        cur.test = this.parseExpression();
+      } else {
+        if (sawDefault) {
+          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
+        }
+        sawDefault = true;
+        cur.test = null;
+      }
+      this.expect(types$1.colon);
+    } else {
+      if (!cur) {
+        this.unexpected();
+      }
+      cur.consequent.push(this.parseStatement(null));
+    }
+  }
+  this.exitScope();
+  if (cur) {
+    this.finishNode(cur, "SwitchCase");
+  }
+  this.next();
+  this.labels.pop();
+  return this.finishNode(node, "SwitchStatement");
+};
+pp$8.parseThrowStatement = function(node) {
+  this.next();
+  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
+    this.raise(this.lastTokEnd, "Illegal newline after throw");
+  }
+  node.argument = this.parseExpression();
+  this.semicolon();
+  return this.finishNode(node, "ThrowStatement");
+};
+var empty$1 = [];
+pp$8.parseTryStatement = function(node) {
+  this.next();
+  node.block = this.parseBlock();
+  node.handler = null;
+  if (this.type === types$1._catch) {
+    var clause = this.startNode();
+    this.next();
+    if (this.eat(types$1.parenL)) {
+      clause.param = this.parseBindingAtom();
+      var simple = clause.param.type === "Identifier";
+      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
+      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
+      this.expect(types$1.parenR);
+    } else {
+      if (this.options.ecmaVersion < 10) {
+        this.unexpected();
+      }
+      clause.param = null;
+      this.enterScope(0);
+    }
+    clause.body = this.parseBlock(false);
+    this.exitScope();
+    node.handler = this.finishNode(clause, "CatchClause");
+  }
+  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
+  if (!node.handler && !node.finalizer) {
+    this.raise(node.start, "Missing catch or finally clause");
+  }
+  return this.finishNode(node, "TryStatement");
+};
+pp$8.parseVarStatement = function(node, kind) {
+  this.next();
+  this.parseVar(node, false, kind);
+  this.semicolon();
+  return this.finishNode(node, "VariableDeclaration");
+};
+pp$8.parseWhileStatement = function(node) {
+  this.next();
+  node.test = this.parseParenExpression();
+  this.labels.push(loopLabel);
+  node.body = this.parseStatement("while");
+  this.labels.pop();
+  return this.finishNode(node, "WhileStatement");
+};
+pp$8.parseWithStatement = function(node) {
+  if (this.strict) {
+    this.raise(this.start, "'with' in strict mode");
+  }
+  this.next();
+  node.object = this.parseParenExpression();
+  node.body = this.parseStatement("with");
+  return this.finishNode(node, "WithStatement");
+};
+pp$8.parseEmptyStatement = function(node) {
+  this.next();
+  return this.finishNode(node, "EmptyStatement");
+};
+pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
+  for (var i$1 = 0, list3 = this.labels; i$1 < list3.length; i$1 += 1) {
+    var label = list3[i$1];
+    if (label.name === maybeName) {
+      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
+    }
+  }
+  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
+  for (var i = this.labels.length - 1; i >= 0; i--) {
+    var label$1 = this.labels[i];
+    if (label$1.statementStart === node.start) {
+      label$1.statementStart = this.start;
+      label$1.kind = kind;
+    } else {
+      break;
+    }
+  }
+  this.labels.push({ name: maybeName, kind, statementStart: this.start });
+  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
+  this.labels.pop();
+  node.label = expr;
+  return this.finishNode(node, "LabeledStatement");
+};
+pp$8.parseExpressionStatement = function(node, expr) {
+  node.expression = expr;
+  this.semicolon();
+  return this.finishNode(node, "ExpressionStatement");
+};
+pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
+  if (createNewLexicalScope === void 0)
+    createNewLexicalScope = true;
+  if (node === void 0)
+    node = this.startNode();
+  node.body = [];
+  this.expect(types$1.braceL);
+  if (createNewLexicalScope) {
+    this.enterScope(0);
+  }
+  while (this.type !== types$1.braceR) {
+    var stmt = this.parseStatement(null);
+    node.body.push(stmt);
+  }
+  if (exitStrict) {
+    this.strict = false;
+  }
+  this.next();
+  if (createNewLexicalScope) {
+    this.exitScope();
+  }
+  return this.finishNode(node, "BlockStatement");
+};
+pp$8.parseFor = function(node, init) {
+  node.init = init;
+  this.expect(types$1.semi);
+  node.test = this.type === types$1.semi ? null : this.parseExpression();
+  this.expect(types$1.semi);
+  node.update = this.type === types$1.parenR ? null : this.parseExpression();
+  this.expect(types$1.parenR);
+  node.body = this.parseStatement("for");
+  this.exitScope();
+  this.labels.pop();
+  return this.finishNode(node, "ForStatement");
+};
+pp$8.parseForIn = function(node, init) {
+  var isForIn = this.type === types$1._in;
+  this.next();
+  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
+    this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
+  }
+  node.left = init;
+  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
+  this.expect(types$1.parenR);
+  node.body = this.parseStatement("for");
+  this.exitScope();
+  this.labels.pop();
+  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
+};
+pp$8.parseVar = function(node, isFor, kind) {
+  node.declarations = [];
+  node.kind = kind;
+  for (; ; ) {
+    var decl = this.startNode();
+    this.parseVarId(decl, kind);
+    if (this.eat(types$1.eq)) {
+      decl.init = this.parseMaybeAssign(isFor);
+    } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
+      this.unexpected();
+    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
+      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
+    } else {
+      decl.init = null;
+    }
+    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
+    if (!this.eat(types$1.comma)) {
+      break;
+    }
+  }
+  return node;
+};
+pp$8.parseVarId = function(decl, kind) {
+  decl.id = this.parseBindingAtom();
+  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
+};
+var FUNC_STATEMENT = 1;
+var FUNC_HANGING_STATEMENT = 2;
+var FUNC_NULLABLE_ID = 4;
+pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
+  this.initFunction(node);
+  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
+    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
+      this.unexpected();
+    }
+    node.generator = this.eat(types$1.star);
+  }
+  if (this.options.ecmaVersion >= 8) {
+    node.async = !!isAsync;
+  }
+  if (statement & FUNC_STATEMENT) {
+    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
+    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
+      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
+    }
+  }
+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
+  this.yieldPos = 0;
+  this.awaitPos = 0;
+  this.awaitIdentPos = 0;
+  this.enterScope(functionFlags(node.async, node.generator));
+  if (!(statement & FUNC_STATEMENT)) {
+    node.id = this.type === types$1.name ? this.parseIdent() : null;
+  }
+  this.parseFunctionParams(node);
+  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
+  this.yieldPos = oldYieldPos;
+  this.awaitPos = oldAwaitPos;
+  this.awaitIdentPos = oldAwaitIdentPos;
+  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
+};
+pp$8.parseFunctionParams = function(node) {
+  this.expect(types$1.parenL);
+  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
+  this.checkYieldAwaitInDefaultParams();
+};
+pp$8.parseClass = function(node, isStatement) {
+  this.next();
+  var oldStrict = this.strict;
+  this.strict = true;
+  this.parseClassId(node, isStatement);
+  this.parseClassSuper(node);
+  var privateNameMap = this.enterClassBody();
+  var classBody = this.startNode();
+  var hadConstructor = false;
+  classBody.body = [];
+  this.expect(types$1.braceL);
+  while (this.type !== types$1.braceR) {
+    var element3 = this.parseClassElement(node.superClass !== null);
+    if (element3) {
+      classBody.body.push(element3);
+      if (element3.type === "MethodDefinition" && element3.kind === "constructor") {
+        if (hadConstructor) {
+          this.raise(element3.start, "Duplicate constructor in the same class");
+        }
+        hadConstructor = true;
+      } else if (element3.key && element3.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element3)) {
+        this.raiseRecoverable(element3.key.start, "Identifier '#" + element3.key.name + "' has already been declared");
+      }
+    }
+  }
+  this.strict = oldStrict;
+  this.next();
+  node.body = this.finishNode(classBody, "ClassBody");
+  this.exitClassBody();
+  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
+};
+pp$8.parseClassElement = function(constructorAllowsSuper) {
+  if (this.eat(types$1.semi)) {
+    return null;
+  }
+  var ecmaVersion = this.options.ecmaVersion;
+  var node = this.startNode();
+  var keyName = "";
+  var isGenerator = false;
+  var isAsync = false;
+  var kind = "method";
+  var isStatic = false;
+  if (this.eatContextual("static")) {
+    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
+      this.parseClassStaticBlock(node);
+      return node;
+    }
+    if (this.isClassElementNameStart() || this.type === types$1.star) {
+      isStatic = true;
+    } else {
+      keyName = "static";
+    }
+  }
+  node.static = isStatic;
+  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
+    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
+      isAsync = true;
+    } else {
+      keyName = "async";
+    }
+  }
+  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
+    isGenerator = true;
+  }
+  if (!keyName && !isAsync && !isGenerator) {
+    var lastValue = this.value;
+    if (this.eatContextual("get") || this.eatContextual("set")) {
+      if (this.isClassElementNameStart()) {
+        kind = lastValue;
+      } else {
+        keyName = lastValue;
+      }
+    }
+  }
+  if (keyName) {
+    node.computed = false;
+    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
+    node.key.name = keyName;
+    this.finishNode(node.key, "Identifier");
+  } else {
+    this.parseClassElementName(node);
+  }
+  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
+    var isConstructor = !node.static && checkKeyName(node, "constructor");
+    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
+    if (isConstructor && kind !== "method") {
+      this.raise(node.key.start, "Constructor can't have get/set modifier");
+    }
+    node.kind = isConstructor ? "constructor" : kind;
+    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
+  } else {
+    this.parseClassField(node);
+  }
+  return node;
+};
+pp$8.isClassElementNameStart = function() {
+  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
+};
+pp$8.parseClassElementName = function(element3) {
+  if (this.type === types$1.privateId) {
+    if (this.value === "constructor") {
+      this.raise(this.start, "Classes can't have an element named '#constructor'");
+    }
+    element3.computed = false;
+    element3.key = this.parsePrivateIdent();
+  } else {
+    this.parsePropertyName(element3);
+  }
+};
+pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
+  var key = method.key;
+  if (method.kind === "constructor") {
+    if (isGenerator) {
+      this.raise(key.start, "Constructor can't be a generator");
+    }
+    if (isAsync) {
+      this.raise(key.start, "Constructor can't be an async method");
+    }
+  } else if (method.static && checkKeyName(method, "prototype")) {
+    this.raise(key.start, "Classes may not have a static property named prototype");
+  }
+  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
+  if (method.kind === "get" && value.params.length !== 0) {
+    this.raiseRecoverable(value.start, "getter should have no params");
+  }
+  if (method.kind === "set" && value.params.length !== 1) {
+    this.raiseRecoverable(value.start, "setter should have exactly one param");
+  }
+  if (method.kind === "set" && value.params[0].type === "RestElement") {
+    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
+  }
+  return this.finishNode(method, "MethodDefinition");
+};
+pp$8.parseClassField = function(field) {
+  if (checkKeyName(field, "constructor")) {
+    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
+  } else if (field.static && checkKeyName(field, "prototype")) {
+    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
+  }
+  if (this.eat(types$1.eq)) {
+    var scope = this.currentThisScope();
+    var inClassFieldInit = scope.inClassFieldInit;
+    scope.inClassFieldInit = true;
+    field.value = this.parseMaybeAssign();
+    scope.inClassFieldInit = inClassFieldInit;
+  } else {
+    field.value = null;
+  }
+  this.semicolon();
+  return this.finishNode(field, "PropertyDefinition");
+};
+pp$8.parseClassStaticBlock = function(node) {
+  node.body = [];
+  var oldLabels = this.labels;
+  this.labels = [];
+  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
+  while (this.type !== types$1.braceR) {
+    var stmt = this.parseStatement(null);
+    node.body.push(stmt);
+  }
+  this.next();
+  this.exitScope();
+  this.labels = oldLabels;
+  return this.finishNode(node, "StaticBlock");
+};
+pp$8.parseClassId = function(node, isStatement) {
+  if (this.type === types$1.name) {
+    node.id = this.parseIdent();
+    if (isStatement) {
+      this.checkLValSimple(node.id, BIND_LEXICAL, false);
+    }
+  } else {
+    if (isStatement === true) {
+      this.unexpected();
+    }
+    node.id = null;
+  }
+};
+pp$8.parseClassSuper = function(node) {
+  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
+};
+pp$8.enterClassBody = function() {
+  var element3 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
+  this.privateNameStack.push(element3);
+  return element3.declared;
+};
+pp$8.exitClassBody = function() {
+  var ref2 = this.privateNameStack.pop();
+  var declared = ref2.declared;
+  var used = ref2.used;
+  var len = this.privateNameStack.length;
+  var parent = len === 0 ? null : this.privateNameStack[len - 1];
+  for (var i = 0; i < used.length; ++i) {
+    var id = used[i];
+    if (!hasOwn(declared, id.name)) {
+      if (parent) {
+        parent.used.push(id);
+      } else {
+        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
+      }
+    }
+  }
+};
+function isPrivateNameConflicted(privateNameMap, element3) {
+  var name3 = element3.key.name;
+  var curr = privateNameMap[name3];
+  var next = "true";
+  if (element3.type === "MethodDefinition" && (element3.kind === "get" || element3.kind === "set")) {
+    next = (element3.static ? "s" : "i") + element3.kind;
+  }
+  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
+    privateNameMap[name3] = "true";
+    return false;
+  } else if (!curr) {
+    privateNameMap[name3] = next;
+    return false;
+  } else {
+    return true;
+  }
+}
+function checkKeyName(node, name3) {
+  var computed = node.computed;
+  var key = node.key;
+  return !computed && (key.type === "Identifier" && key.name === name3 || key.type === "Literal" && key.value === name3);
+}
+pp$8.parseExport = function(node, exports) {
+  this.next();
+  if (this.eat(types$1.star)) {
+    if (this.options.ecmaVersion >= 11) {
+      if (this.eatContextual("as")) {
+        node.exported = this.parseModuleExportName();
+        this.checkExport(exports, node.exported.name, this.lastTokStart);
+      } else {
+        node.exported = null;
+      }
+    }
+    this.expectContextual("from");
+    if (this.type !== types$1.string) {
+      this.unexpected();
+    }
+    node.source = this.parseExprAtom();
+    this.semicolon();
+    return this.finishNode(node, "ExportAllDeclaration");
+  }
+  if (this.eat(types$1._default)) {
+    this.checkExport(exports, "default", this.lastTokStart);
+    var isAsync;
+    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
+      var fNode = this.startNode();
+      this.next();
+      if (isAsync) {
+        this.next();
+      }
+      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
+    } else if (this.type === types$1._class) {
+      var cNode = this.startNode();
+      node.declaration = this.parseClass(cNode, "nullableID");
+    } else {
+      node.declaration = this.parseMaybeAssign();
+      this.semicolon();
+    }
+    return this.finishNode(node, "ExportDefaultDeclaration");
+  }
+  if (this.shouldParseExportStatement()) {
+    node.declaration = this.parseStatement(null);
+    if (node.declaration.type === "VariableDeclaration") {
+      this.checkVariableExport(exports, node.declaration.declarations);
+    } else {
+      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
+    }
+    node.specifiers = [];
+    node.source = null;
+  } else {
+    node.declaration = null;
+    node.specifiers = this.parseExportSpecifiers(exports);
+    if (this.eatContextual("from")) {
+      if (this.type !== types$1.string) {
+        this.unexpected();
+      }
+      node.source = this.parseExprAtom();
+    } else {
+      for (var i = 0, list3 = node.specifiers; i < list3.length; i += 1) {
+        var spec = list3[i];
+        this.checkUnreserved(spec.local);
+        this.checkLocalExport(spec.local);
+        if (spec.local.type === "Literal") {
+          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
+        }
+      }
+      node.source = null;
+    }
+    this.semicolon();
+  }
+  return this.finishNode(node, "ExportNamedDeclaration");
+};
+pp$8.checkExport = function(exports, name3, pos) {
+  if (!exports) {
+    return;
+  }
+  if (hasOwn(exports, name3)) {
+    this.raiseRecoverable(pos, "Duplicate export '" + name3 + "'");
+  }
+  exports[name3] = true;
+};
+pp$8.checkPatternExport = function(exports, pat) {
+  var type2 = pat.type;
+  if (type2 === "Identifier") {
+    this.checkExport(exports, pat.name, pat.start);
+  } else if (type2 === "ObjectPattern") {
+    for (var i = 0, list3 = pat.properties; i < list3.length; i += 1) {
+      var prop = list3[i];
+      this.checkPatternExport(exports, prop);
+    }
+  } else if (type2 === "ArrayPattern") {
+    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
+      var elt = list$1[i$1];
+      if (elt) {
+        this.checkPatternExport(exports, elt);
+      }
+    }
+  } else if (type2 === "Property") {
+    this.checkPatternExport(exports, pat.value);
+  } else if (type2 === "AssignmentPattern") {
+    this.checkPatternExport(exports, pat.left);
+  } else if (type2 === "RestElement") {
+    this.checkPatternExport(exports, pat.argument);
+  } else if (type2 === "ParenthesizedExpression") {
+    this.checkPatternExport(exports, pat.expression);
+  }
+};
+pp$8.checkVariableExport = function(exports, decls) {
+  if (!exports) {
+    return;
+  }
+  for (var i = 0, list3 = decls; i < list3.length; i += 1) {
+    var decl = list3[i];
+    this.checkPatternExport(exports, decl.id);
+  }
+};
+pp$8.shouldParseExportStatement = function() {
+  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
+};
+pp$8.parseExportSpecifiers = function(exports) {
+  var nodes2 = [], first = true;
+  this.expect(types$1.braceL);
+  while (!this.eat(types$1.braceR)) {
+    if (!first) {
+      this.expect(types$1.comma);
+      if (this.afterTrailingComma(types$1.braceR)) {
+        break;
+      }
+    } else {
+      first = false;
+    }
+    var node = this.startNode();
+    node.local = this.parseModuleExportName();
+    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
+    this.checkExport(exports, node.exported[node.exported.type === "Identifier" ? "name" : "value"], node.exported.start);
+    nodes2.push(this.finishNode(node, "ExportSpecifier"));
+  }
+  return nodes2;
+};
+pp$8.parseImport = function(node) {
+  this.next();
+  if (this.type === types$1.string) {
+    node.specifiers = empty$1;
+    node.source = this.parseExprAtom();
+  } else {
+    node.specifiers = this.parseImportSpecifiers();
+    this.expectContextual("from");
+    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
+  }
+  this.semicolon();
+  return this.finishNode(node, "ImportDeclaration");
+};
+pp$8.parseImportSpecifiers = function() {
+  var nodes2 = [], first = true;
+  if (this.type === types$1.name) {
+    var node = this.startNode();
+    node.local = this.parseIdent();
+    this.checkLValSimple(node.local, BIND_LEXICAL);
+    nodes2.push(this.finishNode(node, "ImportDefaultSpecifier"));
+    if (!this.eat(types$1.comma)) {
+      return nodes2;
+    }
+  }
+  if (this.type === types$1.star) {
+    var node$1 = this.startNode();
+    this.next();
+    this.expectContextual("as");
+    node$1.local = this.parseIdent();
+    this.checkLValSimple(node$1.local, BIND_LEXICAL);
+    nodes2.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
+    return nodes2;
+  }
+  this.expect(types$1.braceL);
+  while (!this.eat(types$1.braceR)) {
+    if (!first) {
+      this.expect(types$1.comma);
+      if (this.afterTrailingComma(types$1.braceR)) {
+        break;
+      }
+    } else {
+      first = false;
+    }
+    var node$2 = this.startNode();
+    node$2.imported = this.parseModuleExportName();
+    if (this.eatContextual("as")) {
+      node$2.local = this.parseIdent();
+    } else {
+      this.checkUnreserved(node$2.imported);
+      node$2.local = node$2.imported;
+    }
+    this.checkLValSimple(node$2.local, BIND_LEXICAL);
+    nodes2.push(this.finishNode(node$2, "ImportSpecifier"));
+  }
+  return nodes2;
+};
+pp$8.parseModuleExportName = function() {
+  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
+    var stringLiteral = this.parseLiteral(this.value);
+    if (loneSurrogate.test(stringLiteral.value)) {
+      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
+    }
+    return stringLiteral;
+  }
+  return this.parseIdent(true);
+};
+pp$8.adaptDirectivePrologue = function(statements) {
+  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
+    statements[i].directive = statements[i].expression.raw.slice(1, -1);
+  }
+};
+pp$8.isDirectiveCandidate = function(statement) {
+  return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
+};
+var pp$7 = Parser.prototype;
+pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
+  if (this.options.ecmaVersion >= 6 && node) {
+    switch (node.type) {
+      case "Identifier":
+        if (this.inAsync && node.name === "await") {
+          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
+        }
+        break;
+      case "ObjectPattern":
+      case "ArrayPattern":
+      case "AssignmentPattern":
+      case "RestElement":
+        break;
+      case "ObjectExpression":
+        node.type = "ObjectPattern";
+        if (refDestructuringErrors) {
+          this.checkPatternErrors(refDestructuringErrors, true);
+        }
+        for (var i = 0, list3 = node.properties; i < list3.length; i += 1) {
+          var prop = list3[i];
+          this.toAssignable(prop, isBinding);
+          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
+            this.raise(prop.argument.start, "Unexpected token");
+          }
+        }
+        break;
+      case "Property":
+        if (node.kind !== "init") {
+          this.raise(node.key.start, "Object pattern can't contain getter or setter");
+        }
+        this.toAssignable(node.value, isBinding);
+        break;
+      case "ArrayExpression":
+        node.type = "ArrayPattern";
+        if (refDestructuringErrors) {
+          this.checkPatternErrors(refDestructuringErrors, true);
+        }
+        this.toAssignableList(node.elements, isBinding);
+        break;
+      case "SpreadElement":
+        node.type = "RestElement";
+        this.toAssignable(node.argument, isBinding);
+        if (node.argument.type === "AssignmentPattern") {
+          this.raise(node.argument.start, "Rest elements cannot have a default value");
+        }
+        break;
+      case "AssignmentExpression":
+        if (node.operator !== "=") {
+          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
+        }
+        node.type = "AssignmentPattern";
+        delete node.operator;
+        this.toAssignable(node.left, isBinding);
+        break;
+      case "ParenthesizedExpression":
+        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
+        break;
+      case "ChainExpression":
+        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
+        break;
+      case "MemberExpression":
+        if (!isBinding) {
+          break;
+        }
+      default:
+        this.raise(node.start, "Assigning to rvalue");
+    }
+  } else if (refDestructuringErrors) {
+    this.checkPatternErrors(refDestructuringErrors, true);
+  }
+  return node;
+};
+pp$7.toAssignableList = function(exprList, isBinding) {
+  var end = exprList.length;
+  for (var i = 0; i < end; i++) {
+    var elt = exprList[i];
+    if (elt) {
+      this.toAssignable(elt, isBinding);
+    }
+  }
+  if (end) {
+    var last = exprList[end - 1];
+    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
+      this.unexpected(last.argument.start);
+    }
+  }
+  return exprList;
+};
+pp$7.parseSpread = function(refDestructuringErrors) {
+  var node = this.startNode();
+  this.next();
+  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
+  return this.finishNode(node, "SpreadElement");
+};
+pp$7.parseRestBinding = function() {
+  var node = this.startNode();
+  this.next();
+  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
+    this.unexpected();
+  }
+  node.argument = this.parseBindingAtom();
+  return this.finishNode(node, "RestElement");
+};
+pp$7.parseBindingAtom = function() {
+  if (this.options.ecmaVersion >= 6) {
+    switch (this.type) {
+      case types$1.bracketL:
+        var node = this.startNode();
+        this.next();
+        node.elements = this.parseBindingList(types$1.bracketR, true, true);
+        return this.finishNode(node, "ArrayPattern");
+      case types$1.braceL:
+        return this.parseObj(true);
+    }
+  }
+  return this.parseIdent();
+};
+pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
+  var elts = [], first = true;
+  while (!this.eat(close)) {
+    if (first) {
+      first = false;
+    } else {
+      this.expect(types$1.comma);
+    }
+    if (allowEmpty && this.type === types$1.comma) {
+      elts.push(null);
+    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
+      break;
+    } else if (this.type === types$1.ellipsis) {
+      var rest = this.parseRestBinding();
+      this.parseBindingListItem(rest);
+      elts.push(rest);
+      if (this.type === types$1.comma) {
+        this.raise(this.start, "Comma is not permitted after the rest element");
+      }
+      this.expect(close);
+      break;
+    } else {
+      var elem = this.parseMaybeDefault(this.start, this.startLoc);
+      this.parseBindingListItem(elem);
+      elts.push(elem);
+    }
+  }
+  return elts;
+};
+pp$7.parseBindingListItem = function(param) {
+  return param;
+};
+pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
+  left = left || this.parseBindingAtom();
+  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
+    return left;
+  }
+  var node = this.startNodeAt(startPos, startLoc);
+  node.left = left;
+  node.right = this.parseMaybeAssign();
+  return this.finishNode(node, "AssignmentPattern");
+};
+pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
+  if (bindingType === void 0)
+    bindingType = BIND_NONE;
+  var isBind = bindingType !== BIND_NONE;
+  switch (expr.type) {
+    case "Identifier":
+      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
+        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
+      }
+      if (isBind) {
+        if (bindingType === BIND_LEXICAL && expr.name === "let") {
+          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
+        }
+        if (checkClashes) {
+          if (hasOwn(checkClashes, expr.name)) {
+            this.raiseRecoverable(expr.start, "Argument name clash");
+          }
+          checkClashes[expr.name] = true;
+        }
+        if (bindingType !== BIND_OUTSIDE) {
+          this.declareName(expr.name, bindingType, expr.start);
+        }
+      }
+      break;
+    case "ChainExpression":
+      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
+      break;
+    case "MemberExpression":
+      if (isBind) {
+        this.raiseRecoverable(expr.start, "Binding member expression");
+      }
+      break;
+    case "ParenthesizedExpression":
+      if (isBind) {
+        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
+      }
+      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
+    default:
+      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
+  }
+};
+pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
+  if (bindingType === void 0)
+    bindingType = BIND_NONE;
+  switch (expr.type) {
+    case "ObjectPattern":
+      for (var i = 0, list3 = expr.properties; i < list3.length; i += 1) {
+        var prop = list3[i];
+        this.checkLValInnerPattern(prop, bindingType, checkClashes);
+      }
+      break;
+    case "ArrayPattern":
+      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
+        var elem = list$1[i$1];
+        if (elem) {
+          this.checkLValInnerPattern(elem, bindingType, checkClashes);
+        }
+      }
+      break;
+    default:
+      this.checkLValSimple(expr, bindingType, checkClashes);
+  }
+};
+pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
+  if (bindingType === void 0)
+    bindingType = BIND_NONE;
+  switch (expr.type) {
+    case "Property":
+      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
+      break;
+    case "AssignmentPattern":
+      this.checkLValPattern(expr.left, bindingType, checkClashes);
+      break;
+    case "RestElement":
+      this.checkLValPattern(expr.argument, bindingType, checkClashes);
+      break;
+    default:
+      this.checkLValPattern(expr, bindingType, checkClashes);
+  }
+};
+var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
+  this.token = token;
+  this.isExpr = !!isExpr;
+  this.preserveSpace = !!preserveSpace;
+  this.override = override;
+  this.generator = !!generator;
+};
+var types = {
+  b_stat: new TokContext("{", false),
+  b_expr: new TokContext("{", true),
+  b_tmpl: new TokContext("${", false),
+  p_stat: new TokContext("(", false),
+  p_expr: new TokContext("(", true),
+  q_tmpl: new TokContext("`", true, true, function(p) {
+    return p.tryReadTemplateToken();
+  }),
+  f_stat: new TokContext("function", false),
+  f_expr: new TokContext("function", true),
+  f_expr_gen: new TokContext("function", true, false, null, true),
+  f_gen: new TokContext("function", false, false, null, true)
+};
+var pp$6 = Parser.prototype;
+pp$6.initialContext = function() {
+  return [types.b_stat];
+};
+pp$6.curContext = function() {
+  return this.context[this.context.length - 1];
+};
+pp$6.braceIsBlock = function(prevType) {
+  var parent = this.curContext();
+  if (parent === types.f_expr || parent === types.f_stat) {
+    return true;
+  }
+  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
+    return !parent.isExpr;
+  }
+  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
+    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
+  }
+  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
+    return true;
+  }
+  if (prevType === types$1.braceL) {
+    return parent === types.b_stat;
+  }
+  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
+    return false;
+  }
+  return !this.exprAllowed;
+};
+pp$6.inGeneratorContext = function() {
+  for (var i = this.context.length - 1; i >= 1; i--) {
+    var context = this.context[i];
+    if (context.token === "function") {
+      return context.generator;
+    }
+  }
+  return false;
+};
+pp$6.updateContext = function(prevType) {
+  var update, type2 = this.type;
+  if (type2.keyword && prevType === types$1.dot) {
+    this.exprAllowed = false;
+  } else if (update = type2.updateContext) {
+    update.call(this, prevType);
+  } else {
+    this.exprAllowed = type2.beforeExpr;
+  }
+};
+pp$6.overrideContext = function(tokenCtx) {
+  if (this.curContext() !== tokenCtx) {
+    this.context[this.context.length - 1] = tokenCtx;
+  }
+};
+types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
+  if (this.context.length === 1) {
+    this.exprAllowed = true;
+    return;
+  }
+  var out = this.context.pop();
+  if (out === types.b_stat && this.curContext().token === "function") {
+    out = this.context.pop();
+  }
+  this.exprAllowed = !out.isExpr;
+};
+types$1.braceL.updateContext = function(prevType) {
+  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
+  this.exprAllowed = true;
+};
+types$1.dollarBraceL.updateContext = function() {
+  this.context.push(types.b_tmpl);
+  this.exprAllowed = true;
+};
+types$1.parenL.updateContext = function(prevType) {
+  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
+  this.context.push(statementParens ? types.p_stat : types.p_expr);
+  this.exprAllowed = true;
+};
+types$1.incDec.updateContext = function() {
+};
+types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
+  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
+    this.context.push(types.f_expr);
+  } else {
+    this.context.push(types.f_stat);
+  }
+  this.exprAllowed = false;
+};
+types$1.backQuote.updateContext = function() {
+  if (this.curContext() === types.q_tmpl) {
+    this.context.pop();
+  } else {
+    this.context.push(types.q_tmpl);
+  }
+  this.exprAllowed = false;
+};
+types$1.star.updateContext = function(prevType) {
+  if (prevType === types$1._function) {
+    var index3 = this.context.length - 1;
+    if (this.context[index3] === types.f_expr) {
+      this.context[index3] = types.f_expr_gen;
+    } else {
+      this.context[index3] = types.f_gen;
+    }
+  }
+  this.exprAllowed = true;
+};
+types$1.name.updateContext = function(prevType) {
+  var allowed = false;
+  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
+    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
+      allowed = true;
+    }
+  }
+  this.exprAllowed = allowed;
+};
+var pp$5 = Parser.prototype;
+pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
+  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
+    return;
+  }
+  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
+    return;
+  }
+  var key = prop.key;
+  var name3;
+  switch (key.type) {
+    case "Identifier":
+      name3 = key.name;
+      break;
+    case "Literal":
+      name3 = String(key.value);
+      break;
+    default:
+      return;
+  }
+  var kind = prop.kind;
+  if (this.options.ecmaVersion >= 6) {
+    if (name3 === "__proto__" && kind === "init") {
+      if (propHash.proto) {
+        if (refDestructuringErrors) {
+          if (refDestructuringErrors.doubleProto < 0) {
+            refDestructuringErrors.doubleProto = key.start;
+          }
+        } else {
+          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
+        }
+      }
+      propHash.proto = true;
+    }
+    return;
+  }
+  name3 = "$" + name3;
+  var other = propHash[name3];
+  if (other) {
+    var redefinition;
+    if (kind === "init") {
+      redefinition = this.strict && other.init || other.get || other.set;
+    } else {
+      redefinition = other.init || other[kind];
+    }
+    if (redefinition) {
+      this.raiseRecoverable(key.start, "Redefinition of property");
+    }
+  } else {
+    other = propHash[name3] = {
+      init: false,
+      get: false,
+      set: false
+    };
+  }
+  other[kind] = true;
+};
+pp$5.parseExpression = function(forInit, refDestructuringErrors) {
+  var startPos = this.start, startLoc = this.startLoc;
+  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
+  if (this.type === types$1.comma) {
+    var node = this.startNodeAt(startPos, startLoc);
+    node.expressions = [expr];
+    while (this.eat(types$1.comma)) {
+      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
+    }
+    return this.finishNode(node, "SequenceExpression");
+  }
+  return expr;
+};
+pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
+  if (this.isContextual("yield")) {
+    if (this.inGenerator) {
+      return this.parseYield(forInit);
+    } else {
+      this.exprAllowed = false;
+    }
+  }
+  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
+  if (refDestructuringErrors) {
+    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
+    oldTrailingComma = refDestructuringErrors.trailingComma;
+    oldDoubleProto = refDestructuringErrors.doubleProto;
+    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
+  } else {
+    refDestructuringErrors = new DestructuringErrors();
+    ownDestructuringErrors = true;
+  }
+  var startPos = this.start, startLoc = this.startLoc;
+  if (this.type === types$1.parenL || this.type === types$1.name) {
+    this.potentialArrowAt = this.start;
+    this.potentialArrowInForAwait = forInit === "await";
+  }
+  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
+  if (afterLeftParse) {
+    left = afterLeftParse.call(this, left, startPos, startLoc);
+  }
+  if (this.type.isAssign) {
+    var node = this.startNodeAt(startPos, startLoc);
+    node.operator = this.value;
+    if (this.type === types$1.eq) {
+      left = this.toAssignable(left, false, refDestructuringErrors);
+    }
+    if (!ownDestructuringErrors) {
+      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
+    }
+    if (refDestructuringErrors.shorthandAssign >= left.start) {
+      refDestructuringErrors.shorthandAssign = -1;
+    }
+    if (this.type === types$1.eq) {
+      this.checkLValPattern(left);
+    } else {
+      this.checkLValSimple(left);
+    }
+    node.left = left;
+    this.next();
+    node.right = this.parseMaybeAssign(forInit);
+    if (oldDoubleProto > -1) {
+      refDestructuringErrors.doubleProto = oldDoubleProto;
+    }
+    return this.finishNode(node, "AssignmentExpression");
+  } else {
+    if (ownDestructuringErrors) {
+      this.checkExpressionErrors(refDestructuringErrors, true);
+    }
+  }
+  if (oldParenAssign > -1) {
+    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
+  }
+  if (oldTrailingComma > -1) {
+    refDestructuringErrors.trailingComma = oldTrailingComma;
+  }
+  return left;
+};
+pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
+  var startPos = this.start, startLoc = this.startLoc;
+  var expr = this.parseExprOps(forInit, refDestructuringErrors);
+  if (this.checkExpressionErrors(refDestructuringErrors)) {
+    return expr;
+  }
+  if (this.eat(types$1.question)) {
+    var node = this.startNodeAt(startPos, startLoc);
+    node.test = expr;
+    node.consequent = this.parseMaybeAssign();
+    this.expect(types$1.colon);
+    node.alternate = this.parseMaybeAssign(forInit);
+    return this.finishNode(node, "ConditionalExpression");
+  }
+  return expr;
+};
+pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
+  var startPos = this.start, startLoc = this.startLoc;
+  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
+  if (this.checkExpressionErrors(refDestructuringErrors)) {
+    return expr;
+  }
+  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
+};
+pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
+  var prec = this.type.binop;
+  if (prec != null && (!forInit || this.type !== types$1._in)) {
+    if (prec > minPrec) {
+      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
+      var coalesce = this.type === types$1.coalesce;
+      if (coalesce) {
+        prec = types$1.logicalAND.binop;
+      }
+      var op = this.value;
+      this.next();
+      var startPos = this.start, startLoc = this.startLoc;
+      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
+      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
+      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
+        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
+      }
+      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
+    }
+  }
+  return left;
+};
+pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
+  if (right.type === "PrivateIdentifier") {
+    this.raise(right.start, "Private identifier can only be left side of binary expression");
+  }
+  var node = this.startNodeAt(startPos, startLoc);
+  node.left = left;
+  node.operator = op;
+  node.right = right;
+  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
+};
+pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
+  var startPos = this.start, startLoc = this.startLoc, expr;
+  if (this.isContextual("await") && this.canAwait) {
+    expr = this.parseAwait(forInit);
+    sawUnary = true;
+  } else if (this.type.prefix) {
+    var node = this.startNode(), update = this.type === types$1.incDec;
+    node.operator = this.value;
+    node.prefix = true;
+    this.next();
+    node.argument = this.parseMaybeUnary(null, true, update, forInit);
+    this.checkExpressionErrors(refDestructuringErrors, true);
+    if (update) {
+      this.checkLValSimple(node.argument);
+    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
+      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
+    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
+      this.raiseRecoverable(node.start, "Private fields can not be deleted");
+    } else {
+      sawUnary = true;
+    }
+    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
+  } else if (!sawUnary && this.type === types$1.privateId) {
+    if (forInit || this.privateNameStack.length === 0) {
+      this.unexpected();
+    }
+    expr = this.parsePrivateIdent();
+    if (this.type !== types$1._in) {
+      this.unexpected();
+    }
+  } else {
+    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
+    if (this.checkExpressionErrors(refDestructuringErrors)) {
+      return expr;
+    }
+    while (this.type.postfix && !this.canInsertSemicolon()) {
+      var node$1 = this.startNodeAt(startPos, startLoc);
+      node$1.operator = this.value;
+      node$1.prefix = false;
+      node$1.argument = expr;
+      this.checkLValSimple(expr);
+      this.next();
+      expr = this.finishNode(node$1, "UpdateExpression");
+    }
+  }
+  if (!incDec && this.eat(types$1.starstar)) {
+    if (sawUnary) {
+      this.unexpected(this.lastTokStart);
+    } else {
+      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
+    }
+  } else {
+    return expr;
+  }
+};
+function isPrivateFieldAccess(node) {
+  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
+}
+pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
+  var startPos = this.start, startLoc = this.startLoc;
+  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
+  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
+    return expr;
+  }
+  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
+  if (refDestructuringErrors && result.type === "MemberExpression") {
+    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
+      refDestructuringErrors.parenthesizedAssign = -1;
+    }
+    if (refDestructuringErrors.parenthesizedBind >= result.start) {
+      refDestructuringErrors.parenthesizedBind = -1;
+    }
+    if (refDestructuringErrors.trailingComma >= result.start) {
+      refDestructuringErrors.trailingComma = -1;
+    }
+  }
+  return result;
+};
+pp$5.parseSubscripts = function(base3, startPos, startLoc, noCalls, forInit) {
+  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base3.type === "Identifier" && base3.name === "async" && this.lastTokEnd === base3.end && !this.canInsertSemicolon() && base3.end - base3.start === 5 && this.potentialArrowAt === base3.start;
+  var optionalChained = false;
+  while (true) {
+    var element3 = this.parseSubscript(base3, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
+    if (element3.optional) {
+      optionalChained = true;
+    }
+    if (element3 === base3 || element3.type === "ArrowFunctionExpression") {
+      if (optionalChained) {
+        var chainNode = this.startNodeAt(startPos, startLoc);
+        chainNode.expression = element3;
+        element3 = this.finishNode(chainNode, "ChainExpression");
+      }
+      return element3;
+    }
+    base3 = element3;
+  }
+};
+pp$5.parseSubscript = function(base3, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
+  var optionalSupported = this.options.ecmaVersion >= 11;
+  var optional = optionalSupported && this.eat(types$1.questionDot);
+  if (noCalls && optional) {
+    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
+  }
+  var computed = this.eat(types$1.bracketL);
+  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
+    var node = this.startNodeAt(startPos, startLoc);
+    node.object = base3;
+    if (computed) {
+      node.property = this.parseExpression();
+      this.expect(types$1.bracketR);
+    } else if (this.type === types$1.privateId && base3.type !== "Super") {
+      node.property = this.parsePrivateIdent();
+    } else {
+      node.property = this.parseIdent(this.options.allowReserved !== "never");
+    }
+    node.computed = !!computed;
+    if (optionalSupported) {
+      node.optional = optional;
+    }
+    base3 = this.finishNode(node, "MemberExpression");
+  } else if (!noCalls && this.eat(types$1.parenL)) {
+    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
+    this.yieldPos = 0;
+    this.awaitPos = 0;
+    this.awaitIdentPos = 0;
+    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
+    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
+      this.checkPatternErrors(refDestructuringErrors, false);
+      this.checkYieldAwaitInDefaultParams();
+      if (this.awaitIdentPos > 0) {
+        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
+      }
+      this.yieldPos = oldYieldPos;
+      this.awaitPos = oldAwaitPos;
+      this.awaitIdentPos = oldAwaitIdentPos;
+      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
+    }
+    this.checkExpressionErrors(refDestructuringErrors, true);
+    this.yieldPos = oldYieldPos || this.yieldPos;
+    this.awaitPos = oldAwaitPos || this.awaitPos;
+    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
+    var node$1 = this.startNodeAt(startPos, startLoc);
+    node$1.callee = base3;
+    node$1.arguments = exprList;
+    if (optionalSupported) {
+      node$1.optional = optional;
+    }
+    base3 = this.finishNode(node$1, "CallExpression");
+  } else if (this.type === types$1.backQuote) {
+    if (optional || optionalChained) {
+      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
+    }
+    var node$2 = this.startNodeAt(startPos, startLoc);
+    node$2.tag = base3;
+    node$2.quasi = this.parseTemplate({ isTagged: true });
+    base3 = this.finishNode(node$2, "TaggedTemplateExpression");
+  }
+  return base3;
+};
+pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
+  if (this.type === types$1.slash) {
+    this.readRegexp();
+  }
+  var node, canBeArrow = this.potentialArrowAt === this.start;
+  switch (this.type) {
+    case types$1._super:
+      if (!this.allowSuper) {
+        this.raise(this.start, "'super' keyword outside a method");
+      }
+      node = this.startNode();
+      this.next();
+      if (this.type === types$1.parenL && !this.allowDirectSuper) {
+        this.raise(node.start, "super() call outside constructor of a subclass");
+      }
+      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
+        this.unexpected();
+      }
+      return this.finishNode(node, "Super");
+    case types$1._this:
+      node = this.startNode();
+      this.next();
+      return this.finishNode(node, "ThisExpression");
+    case types$1.name:
+      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
+      var id = this.parseIdent(false);
+      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
+        this.overrideContext(types.f_expr);
+        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
+      }
+      if (canBeArrow && !this.canInsertSemicolon()) {
+        if (this.eat(types$1.arrow)) {
+          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
+        }
+        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
+          id = this.parseIdent(false);
+          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
+            this.unexpected();
+          }
+          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
+        }
+      }
+      return id;
+    case types$1.regexp:
+      var value = this.value;
+      node = this.parseLiteral(value.value);
+      node.regex = { pattern: value.pattern, flags: value.flags };
+      return node;
+    case types$1.num:
+    case types$1.string:
+      return this.parseLiteral(this.value);
+    case types$1._null:
+    case types$1._true:
+    case types$1._false:
+      node = this.startNode();
+      node.value = this.type === types$1._null ? null : this.type === types$1._true;
+      node.raw = this.type.keyword;
+      this.next();
+      return this.finishNode(node, "Literal");
+    case types$1.parenL:
+      var start3 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
+      if (refDestructuringErrors) {
+        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
+          refDestructuringErrors.parenthesizedAssign = start3;
+        }
+        if (refDestructuringErrors.parenthesizedBind < 0) {
+          refDestructuringErrors.parenthesizedBind = start3;
+        }
+      }
+      return expr;
+    case types$1.bracketL:
+      node = this.startNode();
+      this.next();
+      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
+      return this.finishNode(node, "ArrayExpression");
+    case types$1.braceL:
+      this.overrideContext(types.b_expr);
+      return this.parseObj(false, refDestructuringErrors);
+    case types$1._function:
+      node = this.startNode();
+      this.next();
+      return this.parseFunction(node, 0);
+    case types$1._class:
+      return this.parseClass(this.startNode(), false);
+    case types$1._new:
+      return this.parseNew();
+    case types$1.backQuote:
+      return this.parseTemplate();
+    case types$1._import:
+      if (this.options.ecmaVersion >= 11) {
+        return this.parseExprImport();
+      } else {
+        return this.unexpected();
+      }
+    default:
+      this.unexpected();
+  }
+};
+pp$5.parseExprImport = function() {
+  var node = this.startNode();
+  if (this.containsEsc) {
+    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
+  }
+  var meta = this.parseIdent(true);
+  switch (this.type) {
+    case types$1.parenL:
+      return this.parseDynamicImport(node);
+    case types$1.dot:
+      node.meta = meta;
+      return this.parseImportMeta(node);
+    default:
+      this.unexpected();
+  }
+};
+pp$5.parseDynamicImport = function(node) {
+  this.next();
+  node.source = this.parseMaybeAssign();
+  if (!this.eat(types$1.parenR)) {
+    var errorPos = this.start;
+    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
+      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
+    } else {
+      this.unexpected(errorPos);
+    }
+  }
+  return this.finishNode(node, "ImportExpression");
+};
+pp$5.parseImportMeta = function(node) {
+  this.next();
+  var containsEsc = this.containsEsc;
+  node.property = this.parseIdent(true);
+  if (node.property.name !== "meta") {
+    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
+  }
+  if (containsEsc) {
+    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
+  }
+  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
+    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
+  }
+  return this.finishNode(node, "MetaProperty");
+};
+pp$5.parseLiteral = function(value) {
+  var node = this.startNode();
+  node.value = value;
+  node.raw = this.input.slice(this.start, this.end);
+  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
+    node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
+  }
+  this.next();
+  return this.finishNode(node, "Literal");
+};
+pp$5.parseParenExpression = function() {
+  this.expect(types$1.parenL);
+  var val = this.parseExpression();
+  this.expect(types$1.parenR);
+  return val;
+};
+pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
+  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
+  if (this.options.ecmaVersion >= 6) {
+    this.next();
+    var innerStartPos = this.start, innerStartLoc = this.startLoc;
+    var exprList = [], first = true, lastIsComma = false;
+    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
+    this.yieldPos = 0;
+    this.awaitPos = 0;
+    while (this.type !== types$1.parenR) {
+      first ? first = false : this.expect(types$1.comma);
+      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
+        lastIsComma = true;
+        break;
+      } else if (this.type === types$1.ellipsis) {
+        spreadStart = this.start;
+        exprList.push(this.parseParenItem(this.parseRestBinding()));
+        if (this.type === types$1.comma) {
+          this.raise(this.start, "Comma is not permitted after the rest element");
+        }
+        break;
+      } else {
+        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
+      }
+    }
+    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
+    this.expect(types$1.parenR);
+    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
+      this.checkPatternErrors(refDestructuringErrors, false);
+      this.checkYieldAwaitInDefaultParams();
+      this.yieldPos = oldYieldPos;
+      this.awaitPos = oldAwaitPos;
+      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
+    }
+    if (!exprList.length || lastIsComma) {
+      this.unexpected(this.lastTokStart);
+    }
+    if (spreadStart) {
+      this.unexpected(spreadStart);
+    }
+    this.checkExpressionErrors(refDestructuringErrors, true);
+    this.yieldPos = oldYieldPos || this.yieldPos;
+    this.awaitPos = oldAwaitPos || this.awaitPos;
+    if (exprList.length > 1) {
+      val = this.startNodeAt(innerStartPos, innerStartLoc);
+      val.expressions = exprList;
+      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
+    } else {
+      val = exprList[0];
+    }
+  } else {
+    val = this.parseParenExpression();
+  }
+  if (this.options.preserveParens) {
+    var par = this.startNodeAt(startPos, startLoc);
+    par.expression = val;
+    return this.finishNode(par, "ParenthesizedExpression");
+  } else {
+    return val;
+  }
+};
+pp$5.parseParenItem = function(item) {
+  return item;
+};
+pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
+  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
+};
+var empty = [];
+pp$5.parseNew = function() {
+  if (this.containsEsc) {
+    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
+  }
+  var node = this.startNode();
+  var meta = this.parseIdent(true);
+  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
+    node.meta = meta;
+    var containsEsc = this.containsEsc;
+    node.property = this.parseIdent(true);
+    if (node.property.name !== "target") {
+      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
+    }
+    if (containsEsc) {
+      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
+    }
+    if (!this.allowNewDotTarget) {
+      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
+    }
+    return this.finishNode(node, "MetaProperty");
+  }
+  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
+  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
+  if (isImport && node.callee.type === "ImportExpression") {
+    this.raise(startPos, "Cannot use new with import()");
+  }
+  if (this.eat(types$1.parenL)) {
+    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
+  } else {
+    node.arguments = empty;
+  }
+  return this.finishNode(node, "NewExpression");
+};
+pp$5.parseTemplateElement = function(ref2) {
+  var isTagged = ref2.isTagged;
+  var elem = this.startNode();
+  if (this.type === types$1.invalidTemplate) {
+    if (!isTagged) {
+      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
+    }
+    elem.value = {
+      raw: this.value,
+      cooked: null
+    };
+  } else {
+    elem.value = {
+      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
+      cooked: this.value
+    };
+  }
+  this.next();
+  elem.tail = this.type === types$1.backQuote;
+  return this.finishNode(elem, "TemplateElement");
+};
+pp$5.parseTemplate = function(ref2) {
+  if (ref2 === void 0)
+    ref2 = {};
+  var isTagged = ref2.isTagged;
+  if (isTagged === void 0)
+    isTagged = false;
+  var node = this.startNode();
+  this.next();
+  node.expressions = [];
+  var curElt = this.parseTemplateElement({ isTagged });
+  node.quasis = [curElt];
+  while (!curElt.tail) {
+    if (this.type === types$1.eof) {
+      this.raise(this.pos, "Unterminated template literal");
+    }
+    this.expect(types$1.dollarBraceL);
+    node.expressions.push(this.parseExpression());
+    this.expect(types$1.braceR);
+    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
+  }
+  this.next();
+  return this.finishNode(node, "TemplateLiteral");
+};
+pp$5.isAsyncProp = function(prop) {
+  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
+};
+pp$5.parseObj = function(isPattern, refDestructuringErrors) {
+  var node = this.startNode(), first = true, propHash = {};
+  node.properties = [];
+  this.next();
+  while (!this.eat(types$1.braceR)) {
+    if (!first) {
+      this.expect(types$1.comma);
+      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
+        break;
+      }
+    } else {
+      first = false;
+    }
+    var prop = this.parseProperty(isPattern, refDestructuringErrors);
+    if (!isPattern) {
+      this.checkPropClash(prop, propHash, refDestructuringErrors);
+    }
+    node.properties.push(prop);
+  }
+  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
+};
+pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
+  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
+  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
+    if (isPattern) {
+      prop.argument = this.parseIdent(false);
+      if (this.type === types$1.comma) {
+        this.raise(this.start, "Comma is not permitted after the rest element");
+      }
+      return this.finishNode(prop, "RestElement");
+    }
+    if (this.type === types$1.parenL && refDestructuringErrors) {
+      if (refDestructuringErrors.parenthesizedAssign < 0) {
+        refDestructuringErrors.parenthesizedAssign = this.start;
+      }
+      if (refDestructuringErrors.parenthesizedBind < 0) {
+        refDestructuringErrors.parenthesizedBind = this.start;
+      }
+    }
+    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
+    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
+      refDestructuringErrors.trailingComma = this.start;
+    }
+    return this.finishNode(prop, "SpreadElement");
+  }
+  if (this.options.ecmaVersion >= 6) {
+    prop.method = false;
+    prop.shorthand = false;
+    if (isPattern || refDestructuringErrors) {
+      startPos = this.start;
+      startLoc = this.startLoc;
+    }
+    if (!isPattern) {
+      isGenerator = this.eat(types$1.star);
+    }
+  }
+  var containsEsc = this.containsEsc;
+  this.parsePropertyName(prop);
+  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
+    isAsync = true;
+    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
+    this.parsePropertyName(prop, refDestructuringErrors);
+  } else {
+    isAsync = false;
+  }
+  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
+  return this.finishNode(prop, "Property");
+};
+pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
+  if ((isGenerator || isAsync) && this.type === types$1.colon) {
+    this.unexpected();
+  }
+  if (this.eat(types$1.colon)) {
+    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
+    prop.kind = "init";
+  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
+    if (isPattern) {
+      this.unexpected();
+    }
+    prop.kind = "init";
+    prop.method = true;
+    prop.value = this.parseMethod(isGenerator, isAsync);
+  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
+    if (isGenerator || isAsync) {
+      this.unexpected();
+    }
+    prop.kind = prop.key.name;
+    this.parsePropertyName(prop);
+    prop.value = this.parseMethod(false);
+    var paramCount = prop.kind === "get" ? 0 : 1;
+    if (prop.value.params.length !== paramCount) {
+      var start3 = prop.value.start;
+      if (prop.kind === "get") {
+        this.raiseRecoverable(start3, "getter should have no params");
+      } else {
+        this.raiseRecoverable(start3, "setter should have exactly one param");
+      }
+    } else {
+      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
+        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
+      }
+    }
+  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
+    if (isGenerator || isAsync) {
+      this.unexpected();
+    }
+    this.checkUnreserved(prop.key);
+    if (prop.key.name === "await" && !this.awaitIdentPos) {
+      this.awaitIdentPos = startPos;
+    }
+    prop.kind = "init";
+    if (isPattern) {
+      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
+    } else if (this.type === types$1.eq && refDestructuringErrors) {
+      if (refDestructuringErrors.shorthandAssign < 0) {
+        refDestructuringErrors.shorthandAssign = this.start;
+      }
+      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
+    } else {
+      prop.value = this.copyNode(prop.key);
+    }
+    prop.shorthand = true;
+  } else {
+    this.unexpected();
+  }
+};
+pp$5.parsePropertyName = function(prop) {
+  if (this.options.ecmaVersion >= 6) {
+    if (this.eat(types$1.bracketL)) {
+      prop.computed = true;
+      prop.key = this.parseMaybeAssign();
+      this.expect(types$1.bracketR);
+      return prop.key;
+    } else {
+      prop.computed = false;
+    }
+  }
+  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
+};
+pp$5.initFunction = function(node) {
+  node.id = null;
+  if (this.options.ecmaVersion >= 6) {
+    node.generator = node.expression = false;
+  }
+  if (this.options.ecmaVersion >= 8) {
+    node.async = false;
+  }
+};
+pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
+  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
+  this.initFunction(node);
+  if (this.options.ecmaVersion >= 6) {
+    node.generator = isGenerator;
+  }
+  if (this.options.ecmaVersion >= 8) {
+    node.async = !!isAsync;
+  }
+  this.yieldPos = 0;
+  this.awaitPos = 0;
+  this.awaitIdentPos = 0;
+  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
+  this.expect(types$1.parenL);
+  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
+  this.checkYieldAwaitInDefaultParams();
+  this.parseFunctionBody(node, false, true, false);
+  this.yieldPos = oldYieldPos;
+  this.awaitPos = oldAwaitPos;
+  this.awaitIdentPos = oldAwaitIdentPos;
+  return this.finishNode(node, "FunctionExpression");
+};
+pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
+  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
+  this.initFunction(node);
+  if (this.options.ecmaVersion >= 8) {
+    node.async = !!isAsync;
+  }
+  this.yieldPos = 0;
+  this.awaitPos = 0;
+  this.awaitIdentPos = 0;
+  node.params = this.toAssignableList(params, true);
+  this.parseFunctionBody(node, true, false, forInit);
+  this.yieldPos = oldYieldPos;
+  this.awaitPos = oldAwaitPos;
+  this.awaitIdentPos = oldAwaitIdentPos;
+  return this.finishNode(node, "ArrowFunctionExpression");
+};
+pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
+  var isExpression = isArrowFunction && this.type !== types$1.braceL;
+  var oldStrict = this.strict, useStrict = false;
+  if (isExpression) {
+    node.body = this.parseMaybeAssign(forInit);
+    node.expression = true;
+    this.checkParams(node, false);
+  } else {
+    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
+    if (!oldStrict || nonSimple) {
+      useStrict = this.strictDirective(this.end);
+      if (useStrict && nonSimple) {
+        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
+      }
+    }
+    var oldLabels = this.labels;
+    this.labels = [];
+    if (useStrict) {
+      this.strict = true;
+    }
+    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
+    if (this.strict && node.id) {
+      this.checkLValSimple(node.id, BIND_OUTSIDE);
+    }
+    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
+    node.expression = false;
+    this.adaptDirectivePrologue(node.body.body);
+    this.labels = oldLabels;
+  }
+  this.exitScope();
+};
+pp$5.isSimpleParamList = function(params) {
+  for (var i = 0, list3 = params; i < list3.length; i += 1) {
+    var param = list3[i];
+    if (param.type !== "Identifier") {
+      return false;
+    }
+  }
+  return true;
+};
+pp$5.checkParams = function(node, allowDuplicates) {
+  var nameHash = /* @__PURE__ */ Object.create(null);
+  for (var i = 0, list3 = node.params; i < list3.length; i += 1) {
+    var param = list3[i];
+    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
+  }
+};
+pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
+  var elts = [], first = true;
+  while (!this.eat(close)) {
+    if (!first) {
+      this.expect(types$1.comma);
+      if (allowTrailingComma && this.afterTrailingComma(close)) {
+        break;
+      }
+    } else {
+      first = false;
+    }
+    var elt = void 0;
+    if (allowEmpty && this.type === types$1.comma) {
+      elt = null;
+    } else if (this.type === types$1.ellipsis) {
+      elt = this.parseSpread(refDestructuringErrors);
+      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
+        refDestructuringErrors.trailingComma = this.start;
+      }
+    } else {
+      elt = this.parseMaybeAssign(false, refDestructuringErrors);
+    }
+    elts.push(elt);
+  }
+  return elts;
+};
+pp$5.checkUnreserved = function(ref2) {
+  var start3 = ref2.start;
+  var end = ref2.end;
+  var name3 = ref2.name;
+  if (this.inGenerator && name3 === "yield") {
+    this.raiseRecoverable(start3, "Cannot use 'yield' as identifier inside a generator");
+  }
+  if (this.inAsync && name3 === "await") {
+    this.raiseRecoverable(start3, "Cannot use 'await' as identifier inside an async function");
+  }
+  if (this.currentThisScope().inClassFieldInit && name3 === "arguments") {
+    this.raiseRecoverable(start3, "Cannot use 'arguments' in class field initializer");
+  }
+  if (this.inClassStaticBlock && (name3 === "arguments" || name3 === "await")) {
+    this.raise(start3, "Cannot use " + name3 + " in class static initialization block");
+  }
+  if (this.keywords.test(name3)) {
+    this.raise(start3, "Unexpected keyword '" + name3 + "'");
+  }
+  if (this.options.ecmaVersion < 6 && this.input.slice(start3, end).indexOf("\\") !== -1) {
+    return;
+  }
+  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
+  if (re.test(name3)) {
+    if (!this.inAsync && name3 === "await") {
+      this.raiseRecoverable(start3, "Cannot use keyword 'await' outside an async function");
+    }
+    this.raiseRecoverable(start3, "The keyword '" + name3 + "' is reserved");
+  }
+};
+pp$5.parseIdent = function(liberal, isBinding) {
+  var node = this.startNode();
+  if (this.type === types$1.name) {
+    node.name = this.value;
+  } else if (this.type.keyword) {
+    node.name = this.type.keyword;
+    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
+      this.context.pop();
+    }
+  } else {
+    this.unexpected();
+  }
+  this.next(!!liberal);
+  this.finishNode(node, "Identifier");
+  if (!liberal) {
+    this.checkUnreserved(node);
+    if (node.name === "await" && !this.awaitIdentPos) {
+      this.awaitIdentPos = node.start;
+    }
+  }
+  return node;
+};
+pp$5.parsePrivateIdent = function() {
+  var node = this.startNode();
+  if (this.type === types$1.privateId) {
+    node.name = this.value;
+  } else {
+    this.unexpected();
+  }
+  this.next();
+  this.finishNode(node, "PrivateIdentifier");
+  if (this.privateNameStack.length === 0) {
+    this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
+  } else {
+    this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
+  }
+  return node;
+};
+pp$5.parseYield = function(forInit) {
+  if (!this.yieldPos) {
+    this.yieldPos = this.start;
+  }
+  var node = this.startNode();
+  this.next();
+  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
+    node.delegate = false;
+    node.argument = null;
+  } else {
+    node.delegate = this.eat(types$1.star);
+    node.argument = this.parseMaybeAssign(forInit);
+  }
+  return this.finishNode(node, "YieldExpression");
+};
+pp$5.parseAwait = function(forInit) {
+  if (!this.awaitPos) {
+    this.awaitPos = this.start;
+  }
+  var node = this.startNode();
+  this.next();
+  node.argument = this.parseMaybeUnary(null, true, false, forInit);
+  return this.finishNode(node, "AwaitExpression");
+};
+var pp$4 = Parser.prototype;
+pp$4.raise = function(pos, message) {
+  var loc = getLineInfo(this.input, pos);
+  message += " (" + loc.line + ":" + loc.column + ")";
+  var err = new SyntaxError(message);
+  err.pos = pos;
+  err.loc = loc;
+  err.raisedAt = this.pos;
+  throw err;
+};
+pp$4.raiseRecoverable = pp$4.raise;
+pp$4.curPosition = function() {
+  if (this.options.locations) {
+    return new Position(this.curLine, this.pos - this.lineStart);
+  }
+};
+var pp$3 = Parser.prototype;
+var Scope = function Scope2(flags) {
+  this.flags = flags;
+  this.var = [];
+  this.lexical = [];
+  this.functions = [];
+  this.inClassFieldInit = false;
+};
+pp$3.enterScope = function(flags) {
+  this.scopeStack.push(new Scope(flags));
+};
+pp$3.exitScope = function() {
+  this.scopeStack.pop();
+};
+pp$3.treatFunctionsAsVarInScope = function(scope) {
+  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
+};
+pp$3.declareName = function(name3, bindingType, pos) {
+  var redeclared = false;
+  if (bindingType === BIND_LEXICAL) {
+    var scope = this.currentScope();
+    redeclared = scope.lexical.indexOf(name3) > -1 || scope.functions.indexOf(name3) > -1 || scope.var.indexOf(name3) > -1;
+    scope.lexical.push(name3);
+    if (this.inModule && scope.flags & SCOPE_TOP) {
+      delete this.undefinedExports[name3];
+    }
+  } else if (bindingType === BIND_SIMPLE_CATCH) {
+    var scope$1 = this.currentScope();
+    scope$1.lexical.push(name3);
+  } else if (bindingType === BIND_FUNCTION) {
+    var scope$2 = this.currentScope();
+    if (this.treatFunctionsAsVar) {
+      redeclared = scope$2.lexical.indexOf(name3) > -1;
+    } else {
+      redeclared = scope$2.lexical.indexOf(name3) > -1 || scope$2.var.indexOf(name3) > -1;
+    }
+    scope$2.functions.push(name3);
+  } else {
+    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
+      var scope$3 = this.scopeStack[i];
+      if (scope$3.lexical.indexOf(name3) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name3) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name3) > -1) {
+        redeclared = true;
+        break;
+      }
+      scope$3.var.push(name3);
+      if (this.inModule && scope$3.flags & SCOPE_TOP) {
+        delete this.undefinedExports[name3];
+      }
+      if (scope$3.flags & SCOPE_VAR) {
+        break;
+      }
+    }
+  }
+  if (redeclared) {
+    this.raiseRecoverable(pos, "Identifier '" + name3 + "' has already been declared");
+  }
+};
+pp$3.checkLocalExport = function(id) {
+  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
+    this.undefinedExports[id.name] = id;
+  }
+};
+pp$3.currentScope = function() {
+  return this.scopeStack[this.scopeStack.length - 1];
+};
+pp$3.currentVarScope = function() {
+  for (var i = this.scopeStack.length - 1; ; i--) {
+    var scope = this.scopeStack[i];
+    if (scope.flags & SCOPE_VAR) {
+      return scope;
+    }
+  }
+};
+pp$3.currentThisScope = function() {
+  for (var i = this.scopeStack.length - 1; ; i--) {
+    var scope = this.scopeStack[i];
+    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
+      return scope;
+    }
+  }
+};
+var Node = function Node2(parser2, pos, loc) {
+  this.type = "";
+  this.start = pos;
+  this.end = 0;
+  if (parser2.options.locations) {
+    this.loc = new SourceLocation(parser2, loc);
+  }
+  if (parser2.options.directSourceFile) {
+    this.sourceFile = parser2.options.directSourceFile;
+  }
+  if (parser2.options.ranges) {
+    this.range = [pos, 0];
+  }
+};
+var pp$2 = Parser.prototype;
+pp$2.startNode = function() {
+  return new Node(this, this.start, this.startLoc);
+};
+pp$2.startNodeAt = function(pos, loc) {
+  return new Node(this, pos, loc);
+};
+function finishNodeAt(node, type2, pos, loc) {
+  node.type = type2;
+  node.end = pos;
+  if (this.options.locations) {
+    node.loc.end = loc;
+  }
+  if (this.options.ranges) {
+    node.range[1] = pos;
+  }
+  return node;
+}
+pp$2.finishNode = function(node, type2) {
+  return finishNodeAt.call(this, node, type2, this.lastTokEnd, this.lastTokEndLoc);
+};
+pp$2.finishNodeAt = function(node, type2, pos, loc) {
+  return finishNodeAt.call(this, node, type2, pos, loc);
+};
+pp$2.copyNode = function(node) {
+  var newNode = new Node(this, node.start, this.startLoc);
+  for (var prop in node) {
+    newNode[prop] = node[prop];
+  }
+  return newNode;
+};
+var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
+var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
+var ecma11BinaryProperties = ecma10BinaryProperties;
+var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
+var ecma13BinaryProperties = ecma12BinaryProperties;
+var unicodeBinaryProperties = {
+  9: ecma9BinaryProperties,
+  10: ecma10BinaryProperties,
+  11: ecma11BinaryProperties,
+  12: ecma12BinaryProperties,
+  13: ecma13BinaryProperties
+};
+var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
+var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
+var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
+var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
+var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
+var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
+var unicodeScriptValues = {
+  9: ecma9ScriptValues,
+  10: ecma10ScriptValues,
+  11: ecma11ScriptValues,
+  12: ecma12ScriptValues,
+  13: ecma13ScriptValues
+};
+var data = {};
+function buildUnicodeData(ecmaVersion) {
+  var d = data[ecmaVersion] = {
+    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
+    nonBinary: {
+      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
+      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
+    }
+  };
+  d.nonBinary.Script_Extensions = d.nonBinary.Script;
+  d.nonBinary.gc = d.nonBinary.General_Category;
+  d.nonBinary.sc = d.nonBinary.Script;
+  d.nonBinary.scx = d.nonBinary.Script_Extensions;
+}
+for (i = 0, list3 = [9, 10, 11, 12, 13]; i < list3.length; i += 1) {
+  ecmaVersion = list3[i];
+  buildUnicodeData(ecmaVersion);
+}
+var ecmaVersion;
+var i;
+var list3;
+var pp$1 = Parser.prototype;
+var RegExpValidationState = function RegExpValidationState2(parser2) {
+  this.parser = parser2;
+  this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
+  this.unicodeProperties = data[parser2.options.ecmaVersion >= 13 ? 13 : parser2.options.ecmaVersion];
+  this.source = "";
+  this.flags = "";
+  this.start = 0;
+  this.switchU = false;
+  this.switchN = false;
+  this.pos = 0;
+  this.lastIntValue = 0;
+  this.lastStringValue = "";
+  this.lastAssertionIsQuantifiable = false;
+  this.numCapturingParens = 0;
+  this.maxBackReference = 0;
+  this.groupNames = [];
+  this.backReferenceNames = [];
+};
+RegExpValidationState.prototype.reset = function reset(start3, pattern, flags) {
+  var unicode2 = flags.indexOf("u") !== -1;
+  this.start = start3 | 0;
+  this.source = pattern + "";
+  this.flags = flags;
+  this.switchU = unicode2 && this.parser.options.ecmaVersion >= 6;
+  this.switchN = unicode2 && this.parser.options.ecmaVersion >= 9;
+};
+RegExpValidationState.prototype.raise = function raise(message) {
+  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
+};
+RegExpValidationState.prototype.at = function at(i, forceU) {
+  if (forceU === void 0)
+    forceU = false;
+  var s2 = this.source;
+  var l = s2.length;
+  if (i >= l) {
+    return -1;
+  }
+  var c = s2.charCodeAt(i);
+  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
+    return c;
+  }
+  var next = s2.charCodeAt(i + 1);
+  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
+};
+RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
+  if (forceU === void 0)
+    forceU = false;
+  var s2 = this.source;
+  var l = s2.length;
+  if (i >= l) {
+    return l;
+  }
+  var c = s2.charCodeAt(i), next;
+  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s2.charCodeAt(i + 1)) < 56320 || next > 57343) {
+    return i + 1;
+  }
+  return i + 2;
+};
+RegExpValidationState.prototype.current = function current(forceU) {
+  if (forceU === void 0)
+    forceU = false;
+  return this.at(this.pos, forceU);
+};
+RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
+  if (forceU === void 0)
+    forceU = false;
+  return this.at(this.nextIndex(this.pos, forceU), forceU);
+};
+RegExpValidationState.prototype.advance = function advance(forceU) {
+  if (forceU === void 0)
+    forceU = false;
+  this.pos = this.nextIndex(this.pos, forceU);
+};
+RegExpValidationState.prototype.eat = function eat(ch, forceU) {
+  if (forceU === void 0)
+    forceU = false;
+  if (this.current(forceU) === ch) {
+    this.advance(forceU);
+    return true;
+  }
+  return false;
+};
+function codePointToString$1(ch) {
+  if (ch <= 65535) {
+    return String.fromCharCode(ch);
+  }
+  ch -= 65536;
+  return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
+}
+pp$1.validateRegExpFlags = function(state) {
+  var validFlags = state.validFlags;
+  var flags = state.flags;
+  for (var i = 0; i < flags.length; i++) {
+    var flag = flags.charAt(i);
+    if (validFlags.indexOf(flag) === -1) {
+      this.raise(state.start, "Invalid regular expression flag");
+    }
+    if (flags.indexOf(flag, i + 1) > -1) {
+      this.raise(state.start, "Duplicate regular expression flag");
+    }
+  }
+};
+pp$1.validateRegExpPattern = function(state) {
+  this.regexp_pattern(state);
+  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
+    state.switchN = true;
+    this.regexp_pattern(state);
+  }
+};
+pp$1.regexp_pattern = function(state) {
+  state.pos = 0;
+  state.lastIntValue = 0;
+  state.lastStringValue = "";
+  state.lastAssertionIsQuantifiable = false;
+  state.numCapturingParens = 0;
+  state.maxBackReference = 0;
+  state.groupNames.length = 0;
+  state.backReferenceNames.length = 0;
+  this.regexp_disjunction(state);
+  if (state.pos !== state.source.length) {
+    if (state.eat(41)) {
+      state.raise("Unmatched ')'");
+    }
+    if (state.eat(93) || state.eat(125)) {
+      state.raise("Lone quantifier brackets");
+    }
+  }
+  if (state.maxBackReference > state.numCapturingParens) {
+    state.raise("Invalid escape");
+  }
+  for (var i = 0, list3 = state.backReferenceNames; i < list3.length; i += 1) {
+    var name3 = list3[i];
+    if (state.groupNames.indexOf(name3) === -1) {
+      state.raise("Invalid named capture referenced");
+    }
+  }
+};
+pp$1.regexp_disjunction = function(state) {
+  this.regexp_alternative(state);
+  while (state.eat(124)) {
+    this.regexp_alternative(state);
+  }
+  if (this.regexp_eatQuantifier(state, true)) {
+    state.raise("Nothing to repeat");
+  }
+  if (state.eat(123)) {
+    state.raise("Lone quantifier brackets");
+  }
+};
+pp$1.regexp_alternative = function(state) {
+  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
+  }
+};
+pp$1.regexp_eatTerm = function(state) {
+  if (this.regexp_eatAssertion(state)) {
+    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
+      if (state.switchU) {
+        state.raise("Invalid quantifier");
+      }
+    }
+    return true;
+  }
+  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
+    this.regexp_eatQuantifier(state);
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatAssertion = function(state) {
+  var start3 = state.pos;
+  state.lastAssertionIsQuantifiable = false;
+  if (state.eat(94) || state.eat(36)) {
+    return true;
+  }
+  if (state.eat(92)) {
+    if (state.eat(66) || state.eat(98)) {
+      return true;
+    }
+    state.pos = start3;
+  }
+  if (state.eat(40) && state.eat(63)) {
+    var lookbehind = false;
+    if (this.options.ecmaVersion >= 9) {
+      lookbehind = state.eat(60);
+    }
+    if (state.eat(61) || state.eat(33)) {
+      this.regexp_disjunction(state);
+      if (!state.eat(41)) {
+        state.raise("Unterminated group");
+      }
+      state.lastAssertionIsQuantifiable = !lookbehind;
+      return true;
+    }
+  }
+  state.pos = start3;
+  return false;
+};
+pp$1.regexp_eatQuantifier = function(state, noError) {
+  if (noError === void 0)
+    noError = false;
+  if (this.regexp_eatQuantifierPrefix(state, noError)) {
+    state.eat(63);
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
+  return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
+};
+pp$1.regexp_eatBracedQuantifier = function(state, noError) {
+  var start3 = state.pos;
+  if (state.eat(123)) {
+    var min = 0, max = -1;
+    if (this.regexp_eatDecimalDigits(state)) {
+      min = state.lastIntValue;
+      if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
+        max = state.lastIntValue;
+      }
+      if (state.eat(125)) {
+        if (max !== -1 && max < min && !noError) {
+          state.raise("numbers out of order in {} quantifier");
+        }
+        return true;
+      }
+    }
+    if (state.switchU && !noError) {
+      state.raise("Incomplete quantifier");
+    }
+    state.pos = start3;
+  }
+  return false;
+};
+pp$1.regexp_eatAtom = function(state) {
+  return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
+};
+pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
+  var start3 = state.pos;
+  if (state.eat(92)) {
+    if (this.regexp_eatAtomEscape(state)) {
+      return true;
+    }
+    state.pos = start3;
+  }
+  return false;
+};
+pp$1.regexp_eatUncapturingGroup = function(state) {
+  var start3 = state.pos;
+  if (state.eat(40)) {
+    if (state.eat(63) && state.eat(58)) {
+      this.regexp_disjunction(state);
+      if (state.eat(41)) {
+        return true;
+      }
+      state.raise("Unterminated group");
+    }
+    state.pos = start3;
+  }
+  return false;
+};
+pp$1.regexp_eatCapturingGroup = function(state) {
+  if (state.eat(40)) {
+    if (this.options.ecmaVersion >= 9) {
+      this.regexp_groupSpecifier(state);
+    } else if (state.current() === 63) {
+      state.raise("Invalid group");
+    }
+    this.regexp_disjunction(state);
+    if (state.eat(41)) {
+      state.numCapturingParens += 1;
+      return true;
+    }
+    state.raise("Unterminated group");
+  }
+  return false;
+};
+pp$1.regexp_eatExtendedAtom = function(state) {
+  return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
+};
+pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
+  if (this.regexp_eatBracedQuantifier(state, true)) {
+    state.raise("Nothing to repeat");
+  }
+  return false;
+};
+pp$1.regexp_eatSyntaxCharacter = function(state) {
+  var ch = state.current();
+  if (isSyntaxCharacter(ch)) {
+    state.lastIntValue = ch;
+    state.advance();
+    return true;
+  }
+  return false;
+};
+function isSyntaxCharacter(ch) {
+  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
+}
+pp$1.regexp_eatPatternCharacters = function(state) {
+  var start3 = state.pos;
+  var ch = 0;
+  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
+    state.advance();
+  }
+  return state.pos !== start3;
+};
+pp$1.regexp_eatExtendedPatternCharacter = function(state) {
+  var ch = state.current();
+  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
+    state.advance();
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_groupSpecifier = function(state) {
+  if (state.eat(63)) {
+    if (this.regexp_eatGroupName(state)) {
+      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
+        state.raise("Duplicate capture group name");
+      }
+      state.groupNames.push(state.lastStringValue);
+      return;
+    }
+    state.raise("Invalid group");
+  }
+};
+pp$1.regexp_eatGroupName = function(state) {
+  state.lastStringValue = "";
+  if (state.eat(60)) {
+    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
+      return true;
+    }
+    state.raise("Invalid capture group name");
+  }
+  return false;
+};
+pp$1.regexp_eatRegExpIdentifierName = function(state) {
+  state.lastStringValue = "";
+  if (this.regexp_eatRegExpIdentifierStart(state)) {
+    state.lastStringValue += codePointToString$1(state.lastIntValue);
+    while (this.regexp_eatRegExpIdentifierPart(state)) {
+      state.lastStringValue += codePointToString$1(state.lastIntValue);
+    }
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatRegExpIdentifierStart = function(state) {
+  var start3 = state.pos;
+  var forceU = this.options.ecmaVersion >= 11;
+  var ch = state.current(forceU);
+  state.advance(forceU);
+  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
+    ch = state.lastIntValue;
+  }
+  if (isRegExpIdentifierStart(ch)) {
+    state.lastIntValue = ch;
+    return true;
+  }
+  state.pos = start3;
+  return false;
+};
+function isRegExpIdentifierStart(ch) {
+  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
+}
+pp$1.regexp_eatRegExpIdentifierPart = function(state) {
+  var start3 = state.pos;
+  var forceU = this.options.ecmaVersion >= 11;
+  var ch = state.current(forceU);
+  state.advance(forceU);
+  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
+    ch = state.lastIntValue;
+  }
+  if (isRegExpIdentifierPart(ch)) {
+    state.lastIntValue = ch;
+    return true;
+  }
+  state.pos = start3;
+  return false;
+};
+function isRegExpIdentifierPart(ch) {
+  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
+}
+pp$1.regexp_eatAtomEscape = function(state) {
+  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
+    return true;
+  }
+  if (state.switchU) {
+    if (state.current() === 99) {
+      state.raise("Invalid unicode escape");
+    }
+    state.raise("Invalid escape");
+  }
+  return false;
+};
+pp$1.regexp_eatBackReference = function(state) {
+  var start3 = state.pos;
+  if (this.regexp_eatDecimalEscape(state)) {
+    var n = state.lastIntValue;
+    if (state.switchU) {
+      if (n > state.maxBackReference) {
+        state.maxBackReference = n;
+      }
+      return true;
+    }
+    if (n <= state.numCapturingParens) {
+      return true;
+    }
+    state.pos = start3;
+  }
+  return false;
+};
+pp$1.regexp_eatKGroupName = function(state) {
+  if (state.eat(107)) {
+    if (this.regexp_eatGroupName(state)) {
+      state.backReferenceNames.push(state.lastStringValue);
+      return true;
+    }
+    state.raise("Invalid named reference");
+  }
+  return false;
+};
+pp$1.regexp_eatCharacterEscape = function(state) {
+  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
+};
+pp$1.regexp_eatCControlLetter = function(state) {
+  var start3 = state.pos;
+  if (state.eat(99)) {
+    if (this.regexp_eatControlLetter(state)) {
+      return true;
+    }
+    state.pos = start3;
+  }
+  return false;
+};
+pp$1.regexp_eatZero = function(state) {
+  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
+    state.lastIntValue = 0;
+    state.advance();
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatControlEscape = function(state) {
+  var ch = state.current();
+  if (ch === 116) {
+    state.lastIntValue = 9;
+    state.advance();
+    return true;
+  }
+  if (ch === 110) {
+    state.lastIntValue = 10;
+    state.advance();
+    return true;
+  }
+  if (ch === 118) {
+    state.lastIntValue = 11;
+    state.advance();
+    return true;
+  }
+  if (ch === 102) {
+    state.lastIntValue = 12;
+    state.advance();
+    return true;
+  }
+  if (ch === 114) {
+    state.lastIntValue = 13;
+    state.advance();
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatControlLetter = function(state) {
+  var ch = state.current();
+  if (isControlLetter(ch)) {
+    state.lastIntValue = ch % 32;
+    state.advance();
+    return true;
+  }
+  return false;
+};
+function isControlLetter(ch) {
+  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
+}
+pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
+  if (forceU === void 0)
+    forceU = false;
+  var start3 = state.pos;
+  var switchU = forceU || state.switchU;
+  if (state.eat(117)) {
+    if (this.regexp_eatFixedHexDigits(state, 4)) {
+      var lead = state.lastIntValue;
+      if (switchU && lead >= 55296 && lead <= 56319) {
+        var leadSurrogateEnd = state.pos;
+        if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
+          var trail = state.lastIntValue;
+          if (trail >= 56320 && trail <= 57343) {
+            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
+            return true;
+          }
+        }
+        state.pos = leadSurrogateEnd;
+        state.lastIntValue = lead;
+      }
+      return true;
+    }
+    if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
+      return true;
+    }
+    if (switchU) {
+      state.raise("Invalid unicode escape");
+    }
+    state.pos = start3;
+  }
+  return false;
+};
+function isValidUnicode(ch) {
+  return ch >= 0 && ch <= 1114111;
+}
+pp$1.regexp_eatIdentityEscape = function(state) {
+  if (state.switchU) {
+    if (this.regexp_eatSyntaxCharacter(state)) {
+      return true;
+    }
+    if (state.eat(47)) {
+      state.lastIntValue = 47;
+      return true;
+    }
+    return false;
+  }
+  var ch = state.current();
+  if (ch !== 99 && (!state.switchN || ch !== 107)) {
+    state.lastIntValue = ch;
+    state.advance();
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatDecimalEscape = function(state) {
+  state.lastIntValue = 0;
+  var ch = state.current();
+  if (ch >= 49 && ch <= 57) {
+    do {
+      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
+      state.advance();
+    } while ((ch = state.current()) >= 48 && ch <= 57);
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatCharacterClassEscape = function(state) {
+  var ch = state.current();
+  if (isCharacterClassEscape(ch)) {
+    state.lastIntValue = -1;
+    state.advance();
+    return true;
+  }
+  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
+    state.lastIntValue = -1;
+    state.advance();
+    if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
+      return true;
+    }
+    state.raise("Invalid property name");
+  }
+  return false;
+};
+function isCharacterClassEscape(ch) {
+  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
+}
+pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
+  var start3 = state.pos;
+  if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
+    var name3 = state.lastStringValue;
+    if (this.regexp_eatUnicodePropertyValue(state)) {
+      var value = state.lastStringValue;
+      this.regexp_validateUnicodePropertyNameAndValue(state, name3, value);
+      return true;
+    }
+  }
+  state.pos = start3;
+  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
+    var nameOrValue = state.lastStringValue;
+    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name3, value) {
+  if (!hasOwn(state.unicodeProperties.nonBinary, name3)) {
+    state.raise("Invalid property name");
+  }
+  if (!state.unicodeProperties.nonBinary[name3].test(value)) {
+    state.raise("Invalid property value");
+  }
+};
+pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
+  if (!state.unicodeProperties.binary.test(nameOrValue)) {
+    state.raise("Invalid property name");
+  }
+};
+pp$1.regexp_eatUnicodePropertyName = function(state) {
+  var ch = 0;
+  state.lastStringValue = "";
+  while (isUnicodePropertyNameCharacter(ch = state.current())) {
+    state.lastStringValue += codePointToString$1(ch);
+    state.advance();
+  }
+  return state.lastStringValue !== "";
+};
+function isUnicodePropertyNameCharacter(ch) {
+  return isControlLetter(ch) || ch === 95;
+}
+pp$1.regexp_eatUnicodePropertyValue = function(state) {
+  var ch = 0;
+  state.lastStringValue = "";
+  while (isUnicodePropertyValueCharacter(ch = state.current())) {
+    state.lastStringValue += codePointToString$1(ch);
+    state.advance();
+  }
+  return state.lastStringValue !== "";
+};
+function isUnicodePropertyValueCharacter(ch) {
+  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
+}
+pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
+  return this.regexp_eatUnicodePropertyValue(state);
+};
+pp$1.regexp_eatCharacterClass = function(state) {
+  if (state.eat(91)) {
+    state.eat(94);
+    this.regexp_classRanges(state);
+    if (state.eat(93)) {
+      return true;
+    }
+    state.raise("Unterminated character class");
+  }
+  return false;
+};
+pp$1.regexp_classRanges = function(state) {
+  while (this.regexp_eatClassAtom(state)) {
+    var left = state.lastIntValue;
+    if (state.eat(45) && this.regexp_eatClassAtom(state)) {
+      var right = state.lastIntValue;
+      if (state.switchU && (left === -1 || right === -1)) {
+        state.raise("Invalid character class");
+      }
+      if (left !== -1 && right !== -1 && left > right) {
+        state.raise("Range out of order in character class");
+      }
+    }
+  }
+};
+pp$1.regexp_eatClassAtom = function(state) {
+  var start3 = state.pos;
+  if (state.eat(92)) {
+    if (this.regexp_eatClassEscape(state)) {
+      return true;
+    }
+    if (state.switchU) {
+      var ch$1 = state.current();
+      if (ch$1 === 99 || isOctalDigit(ch$1)) {
+        state.raise("Invalid class escape");
+      }
+      state.raise("Invalid escape");
+    }
+    state.pos = start3;
+  }
+  var ch = state.current();
+  if (ch !== 93) {
+    state.lastIntValue = ch;
+    state.advance();
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatClassEscape = function(state) {
+  var start3 = state.pos;
+  if (state.eat(98)) {
+    state.lastIntValue = 8;
+    return true;
+  }
+  if (state.switchU && state.eat(45)) {
+    state.lastIntValue = 45;
+    return true;
+  }
+  if (!state.switchU && state.eat(99)) {
+    if (this.regexp_eatClassControlLetter(state)) {
+      return true;
+    }
+    state.pos = start3;
+  }
+  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
+};
+pp$1.regexp_eatClassControlLetter = function(state) {
+  var ch = state.current();
+  if (isDecimalDigit(ch) || ch === 95) {
+    state.lastIntValue = ch % 32;
+    state.advance();
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatHexEscapeSequence = function(state) {
+  var start3 = state.pos;
+  if (state.eat(120)) {
+    if (this.regexp_eatFixedHexDigits(state, 2)) {
+      return true;
+    }
+    if (state.switchU) {
+      state.raise("Invalid escape");
+    }
+    state.pos = start3;
+  }
+  return false;
+};
+pp$1.regexp_eatDecimalDigits = function(state) {
+  var start3 = state.pos;
+  var ch = 0;
+  state.lastIntValue = 0;
+  while (isDecimalDigit(ch = state.current())) {
+    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
+    state.advance();
+  }
+  return state.pos !== start3;
+};
+function isDecimalDigit(ch) {
+  return ch >= 48 && ch <= 57;
+}
+pp$1.regexp_eatHexDigits = function(state) {
+  var start3 = state.pos;
+  var ch = 0;
+  state.lastIntValue = 0;
+  while (isHexDigit(ch = state.current())) {
+    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
+    state.advance();
+  }
+  return state.pos !== start3;
+};
+function isHexDigit(ch) {
+  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
+}
+function hexToInt(ch) {
+  if (ch >= 65 && ch <= 70) {
+    return 10 + (ch - 65);
+  }
+  if (ch >= 97 && ch <= 102) {
+    return 10 + (ch - 97);
+  }
+  return ch - 48;
+}
+pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
+  if (this.regexp_eatOctalDigit(state)) {
+    var n1 = state.lastIntValue;
+    if (this.regexp_eatOctalDigit(state)) {
+      var n2 = state.lastIntValue;
+      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
+        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
+      } else {
+        state.lastIntValue = n1 * 8 + n2;
+      }
+    } else {
+      state.lastIntValue = n1;
+    }
+    return true;
+  }
+  return false;
+};
+pp$1.regexp_eatOctalDigit = function(state) {
+  var ch = state.current();
+  if (isOctalDigit(ch)) {
+    state.lastIntValue = ch - 48;
+    state.advance();
+    return true;
+  }
+  state.lastIntValue = 0;
+  return false;
+};
+function isOctalDigit(ch) {
+  return ch >= 48 && ch <= 55;
+}
+pp$1.regexp_eatFixedHexDigits = function(state, length) {
+  var start3 = state.pos;
+  state.lastIntValue = 0;
+  for (var i = 0; i < length; ++i) {
+    var ch = state.current();
+    if (!isHexDigit(ch)) {
+      state.pos = start3;
+      return false;
+    }
+    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
+    state.advance();
+  }
+  return true;
+};
+var Token = function Token2(p) {
+  this.type = p.type;
+  this.value = p.value;
+  this.start = p.start;
+  this.end = p.end;
+  if (p.options.locations) {
+    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
+  }
+  if (p.options.ranges) {
+    this.range = [p.start, p.end];
+  }
+};
+var pp = Parser.prototype;
+pp.next = function(ignoreEscapeSequenceInKeyword) {
+  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
+    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
+  }
+  if (this.options.onToken) {
+    this.options.onToken(new Token(this));
+  }
+  this.lastTokEnd = this.end;
+  this.lastTokStart = this.start;
+  this.lastTokEndLoc = this.endLoc;
+  this.lastTokStartLoc = this.startLoc;
+  this.nextToken();
+};
+pp.getToken = function() {
+  this.next();
+  return new Token(this);
+};
+if (typeof Symbol !== "undefined") {
+  pp[Symbol.iterator] = function() {
+    var this$1$1 = this;
+    return {
+      next: function() {
+        var token = this$1$1.getToken();
+        return {
+          done: token.type === types$1.eof,
+          value: token
+        };
+      }
+    };
+  };
+}
+pp.nextToken = function() {
+  var curContext = this.curContext();
+  if (!curContext || !curContext.preserveSpace) {
+    this.skipSpace();
+  }
+  this.start = this.pos;
+  if (this.options.locations) {
+    this.startLoc = this.curPosition();
+  }
+  if (this.pos >= this.input.length) {
+    return this.finishToken(types$1.eof);
+  }
+  if (curContext.override) {
+    return curContext.override(this);
+  } else {
+    this.readToken(this.fullCharCodeAtPos());
+  }
+};
+pp.readToken = function(code3) {
+  if (isIdentifierStart(code3, this.options.ecmaVersion >= 6) || code3 === 92) {
+    return this.readWord();
+  }
+  return this.getTokenFromCode(code3);
+};
+pp.fullCharCodeAtPos = function() {
+  var code3 = this.input.charCodeAt(this.pos);
+  if (code3 <= 55295 || code3 >= 56320) {
+    return code3;
+  }
+  var next = this.input.charCodeAt(this.pos + 1);
+  return next <= 56319 || next >= 57344 ? code3 : (code3 << 10) + next - 56613888;
+};
+pp.skipBlockComment = function() {
+  var startLoc = this.options.onComment && this.curPosition();
+  var start3 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
+  if (end === -1) {
+    this.raise(this.pos - 2, "Unterminated comment");
+  }
+  this.pos = end + 2;
+  if (this.options.locations) {
+    for (var nextBreak = void 0, pos = start3; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
+      ++this.curLine;
+      pos = this.lineStart = nextBreak;
+    }
+  }
+  if (this.options.onComment) {
+    this.options.onComment(true, this.input.slice(start3 + 2, end), start3, this.pos, startLoc, this.curPosition());
+  }
+};
+pp.skipLineComment = function(startSkip) {
+  var start3 = this.pos;
+  var startLoc = this.options.onComment && this.curPosition();
+  var ch = this.input.charCodeAt(this.pos += startSkip);
+  while (this.pos < this.input.length && !isNewLine(ch)) {
+    ch = this.input.charCodeAt(++this.pos);
+  }
+  if (this.options.onComment) {
+    this.options.onComment(false, this.input.slice(start3 + startSkip, this.pos), start3, this.pos, startLoc, this.curPosition());
+  }
+};
+pp.skipSpace = function() {
+  loop:
+    while (this.pos < this.input.length) {
+      var ch = this.input.charCodeAt(this.pos);
+      switch (ch) {
+        case 32:
+        case 160:
+          ++this.pos;
+          break;
+        case 13:
+          if (this.input.charCodeAt(this.pos + 1) === 10) {
+            ++this.pos;
+          }
+        case 10:
+        case 8232:
+        case 8233:
+          ++this.pos;
+          if (this.options.locations) {
+            ++this.curLine;
+            this.lineStart = this.pos;
+          }
+          break;
+        case 47:
+          switch (this.input.charCodeAt(this.pos + 1)) {
+            case 42:
+              this.skipBlockComment();
+              break;
+            case 47:
+              this.skipLineComment(2);
+              break;
+            default:
+              break loop;
+          }
+          break;
+        default:
+          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
+            ++this.pos;
+          } else {
+            break loop;
+          }
+      }
+    }
+};
+pp.finishToken = function(type2, val) {
+  this.end = this.pos;
+  if (this.options.locations) {
+    this.endLoc = this.curPosition();
+  }
+  var prevType = this.type;
+  this.type = type2;
+  this.value = val;
+  this.updateContext(prevType);
+};
+pp.readToken_dot = function() {
+  var next = this.input.charCodeAt(this.pos + 1);
+  if (next >= 48 && next <= 57) {
+    return this.readNumber(true);
+  }
+  var next2 = this.input.charCodeAt(this.pos + 2);
+  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
+    this.pos += 3;
+    return this.finishToken(types$1.ellipsis);
+  } else {
+    ++this.pos;
+    return this.finishToken(types$1.dot);
+  }
+};
+pp.readToken_slash = function() {
+  var next = this.input.charCodeAt(this.pos + 1);
+  if (this.exprAllowed) {
+    ++this.pos;
+    return this.readRegexp();
+  }
+  if (next === 61) {
+    return this.finishOp(types$1.assign, 2);
+  }
+  return this.finishOp(types$1.slash, 1);
+};
+pp.readToken_mult_modulo_exp = function(code3) {
+  var next = this.input.charCodeAt(this.pos + 1);
+  var size = 1;
+  var tokentype = code3 === 42 ? types$1.star : types$1.modulo;
+  if (this.options.ecmaVersion >= 7 && code3 === 42 && next === 42) {
+    ++size;
+    tokentype = types$1.starstar;
+    next = this.input.charCodeAt(this.pos + 2);
+  }
+  if (next === 61) {
+    return this.finishOp(types$1.assign, size + 1);
+  }
+  return this.finishOp(tokentype, size);
+};
+pp.readToken_pipe_amp = function(code3) {
+  var next = this.input.charCodeAt(this.pos + 1);
+  if (next === code3) {
+    if (this.options.ecmaVersion >= 12) {
+      var next2 = this.input.charCodeAt(this.pos + 2);
+      if (next2 === 61) {
+        return this.finishOp(types$1.assign, 3);
+      }
+    }
+    return this.finishOp(code3 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
+  }
+  if (next === 61) {
+    return this.finishOp(types$1.assign, 2);
+  }
+  return this.finishOp(code3 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
+};
+pp.readToken_caret = function() {
+  var next = this.input.charCodeAt(this.pos + 1);
+  if (next === 61) {
+    return this.finishOp(types$1.assign, 2);
+  }
+  return this.finishOp(types$1.bitwiseXOR, 1);
+};
+pp.readToken_plus_min = function(code3) {
+  var next = this.input.charCodeAt(this.pos + 1);
+  if (next === code3) {
+    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
+      this.skipLineComment(3);
+      this.skipSpace();
+      return this.nextToken();
+    }
+    return this.finishOp(types$1.incDec, 2);
+  }
+  if (next === 61) {
+    return this.finishOp(types$1.assign, 2);
+  }
+  return this.finishOp(types$1.plusMin, 1);
+};
+pp.readToken_lt_gt = function(code3) {
+  var next = this.input.charCodeAt(this.pos + 1);
+  var size = 1;
+  if (next === code3) {
+    size = code3 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
+    if (this.input.charCodeAt(this.pos + size) === 61) {
+      return this.finishOp(types$1.assign, size + 1);
+    }
+    return this.finishOp(types$1.bitShift, size);
+  }
+  if (next === 33 && code3 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
+    this.skipLineComment(4);
+    this.skipSpace();
+    return this.nextToken();
+  }
+  if (next === 61) {
+    size = 2;
+  }
+  return this.finishOp(types$1.relational, size);
+};
+pp.readToken_eq_excl = function(code3) {
+  var next = this.input.charCodeAt(this.pos + 1);
+  if (next === 61) {
+    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
+  }
+  if (code3 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
+    this.pos += 2;
+    return this.finishToken(types$1.arrow);
+  }
+  return this.finishOp(code3 === 61 ? types$1.eq : types$1.prefix, 1);
+};
+pp.readToken_question = function() {
+  var ecmaVersion = this.options.ecmaVersion;
+  if (ecmaVersion >= 11) {
+    var next = this.input.charCodeAt(this.pos + 1);
+    if (next === 46) {
+      var next2 = this.input.charCodeAt(this.pos + 2);
+      if (next2 < 48 || next2 > 57) {
+        return this.finishOp(types$1.questionDot, 2);
+      }
+    }
+    if (next === 63) {
+      if (ecmaVersion >= 12) {
+        var next2$1 = this.input.charCodeAt(this.pos + 2);
+        if (next2$1 === 61) {
+          return this.finishOp(types$1.assign, 3);
+        }
+      }
+      return this.finishOp(types$1.coalesce, 2);
+    }
+  }
+  return this.finishOp(types$1.question, 1);
+};
+pp.readToken_numberSign = function() {
+  var ecmaVersion = this.options.ecmaVersion;
+  var code3 = 35;
+  if (ecmaVersion >= 13) {
+    ++this.pos;
+    code3 = this.fullCharCodeAtPos();
+    if (isIdentifierStart(code3, true) || code3 === 92) {
+      return this.finishToken(types$1.privateId, this.readWord1());
+    }
+  }
+  this.raise(this.pos, "Unexpected character '" + codePointToString(code3) + "'");
+};
+pp.getTokenFromCode = function(code3) {
+  switch (code3) {
+    case 46:
+      return this.readToken_dot();
+    case 40:
+      ++this.pos;
+      return this.finishToken(types$1.parenL);
+    case 41:
+      ++this.pos;
+      return this.finishToken(types$1.parenR);
+    case 59:
+      ++this.pos;
+      return this.finishToken(types$1.semi);
+    case 44:
+      ++this.pos;
+      return this.finishToken(types$1.comma);
+    case 91:
+      ++this.pos;
+      return this.finishToken(types$1.bracketL);
+    case 93:
+      ++this.pos;
+      return this.finishToken(types$1.bracketR);
+    case 123:
+      ++this.pos;
+      return this.finishToken(types$1.braceL);
+    case 125:
+      ++this.pos;
+      return this.finishToken(types$1.braceR);
+    case 58:
+      ++this.pos;
+      return this.finishToken(types$1.colon);
+    case 96:
+      if (this.options.ecmaVersion < 6) {
+        break;
+      }
+      ++this.pos;
+      return this.finishToken(types$1.backQuote);
+    case 48:
+      var next = this.input.charCodeAt(this.pos + 1);
+      if (next === 120 || next === 88) {
+        return this.readRadixNumber(16);
+      }
+      if (this.options.ecmaVersion >= 6) {
+        if (next === 111 || next === 79) {
+          return this.readRadixNumber(8);
+        }
+        if (next === 98 || next === 66) {
+          return this.readRadixNumber(2);
+        }
+      }
+    case 49:
+    case 50:
+    case 51:
+    case 52:
+    case 53:
+    case 54:
+    case 55:
+    case 56:
+    case 57:
+      return this.readNumber(false);
+    case 34:
+    case 39:
+      return this.readString(code3);
+    case 47:
+      return this.readToken_slash();
+    case 37:
+    case 42:
+      return this.readToken_mult_modulo_exp(code3);
+    case 124:
+    case 38:
+      return this.readToken_pipe_amp(code3);
+    case 94:
+      return this.readToken_caret();
+    case 43:
+    case 45:
+      return this.readToken_plus_min(code3);
+    case 60:
+    case 62:
+      return this.readToken_lt_gt(code3);
+    case 61:
+    case 33:
+      return this.readToken_eq_excl(code3);
+    case 63:
+      return this.readToken_question();
+    case 126:
+      return this.finishOp(types$1.prefix, 1);
+    case 35:
+      return this.readToken_numberSign();
+  }
+  this.raise(this.pos, "Unexpected character '" + codePointToString(code3) + "'");
+};
+pp.finishOp = function(type2, size) {
+  var str = this.input.slice(this.pos, this.pos + size);
+  this.pos += size;
+  return this.finishToken(type2, str);
+};
+pp.readRegexp = function() {
+  var escaped, inClass, start3 = this.pos;
+  for (; ; ) {
+    if (this.pos >= this.input.length) {
+      this.raise(start3, "Unterminated regular expression");
+    }
+    var ch = this.input.charAt(this.pos);
+    if (lineBreak.test(ch)) {
+      this.raise(start3, "Unterminated regular expression");
+    }
+    if (!escaped) {
+      if (ch === "[") {
+        inClass = true;
+      } else if (ch === "]" && inClass) {
+        inClass = false;
+      } else if (ch === "/" && !inClass) {
+        break;
+      }
+      escaped = ch === "\\";
+    } else {
+      escaped = false;
+    }
+    ++this.pos;
+  }
+  var pattern = this.input.slice(start3, this.pos);
+  ++this.pos;
+  var flagsStart = this.pos;
+  var flags = this.readWord1();
+  if (this.containsEsc) {
+    this.unexpected(flagsStart);
+  }
+  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
+  state.reset(start3, pattern, flags);
+  this.validateRegExpFlags(state);
+  this.validateRegExpPattern(state);
+  var value = null;
+  try {
+    value = new RegExp(pattern, flags);
+  } catch (e) {
+  }
+  return this.finishToken(types$1.regexp, { pattern, flags, value });
+};
+pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
+  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
+  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
+  var start3 = this.pos, total = 0, lastCode = 0;
+  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
+    var code3 = this.input.charCodeAt(this.pos), val = void 0;
+    if (allowSeparators && code3 === 95) {
+      if (isLegacyOctalNumericLiteral) {
+        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
+      }
+      if (lastCode === 95) {
+        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
+      }
+      if (i === 0) {
+        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
+      }
+      lastCode = code3;
+      continue;
+    }
+    if (code3 >= 97) {
+      val = code3 - 97 + 10;
+    } else if (code3 >= 65) {
+      val = code3 - 65 + 10;
+    } else if (code3 >= 48 && code3 <= 57) {
+      val = code3 - 48;
+    } else {
+      val = Infinity;
+    }
+    if (val >= radix) {
+      break;
+    }
+    lastCode = code3;
+    total = total * radix + val;
+  }
+  if (allowSeparators && lastCode === 95) {
+    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
+  }
+  if (this.pos === start3 || len != null && this.pos - start3 !== len) {
+    return null;
+  }
+  return total;
+};
+function stringToNumber(str, isLegacyOctalNumericLiteral) {
+  if (isLegacyOctalNumericLiteral) {
+    return parseInt(str, 8);
+  }
+  return parseFloat(str.replace(/_/g, ""));
+}
+function stringToBigInt(str) {
+  if (typeof BigInt !== "function") {
+    return null;
+  }
+  return BigInt(str.replace(/_/g, ""));
+}
+pp.readRadixNumber = function(radix) {
+  var start3 = this.pos;
+  this.pos += 2;
+  var val = this.readInt(radix);
+  if (val == null) {
+    this.raise(this.start + 2, "Expected number in radix " + radix);
+  }
+  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
+    val = stringToBigInt(this.input.slice(start3, this.pos));
+    ++this.pos;
+  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
+    this.raise(this.pos, "Identifier directly after number");
+  }
+  return this.finishToken(types$1.num, val);
+};
+pp.readNumber = function(startsWithDot) {
+  var start3 = this.pos;
+  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
+    this.raise(start3, "Invalid number");
+  }
+  var octal = this.pos - start3 >= 2 && this.input.charCodeAt(start3) === 48;
+  if (octal && this.strict) {
+    this.raise(start3, "Invalid number");
+  }
+  var next = this.input.charCodeAt(this.pos);
+  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
+    var val$1 = stringToBigInt(this.input.slice(start3, this.pos));
+    ++this.pos;
+    if (isIdentifierStart(this.fullCharCodeAtPos())) {
+      this.raise(this.pos, "Identifier directly after number");
+    }
+    return this.finishToken(types$1.num, val$1);
+  }
+  if (octal && /[89]/.test(this.input.slice(start3, this.pos))) {
+    octal = false;
+  }
+  if (next === 46 && !octal) {
+    ++this.pos;
+    this.readInt(10);
+    next = this.input.charCodeAt(this.pos);
+  }
+  if ((next === 69 || next === 101) && !octal) {
+    next = this.input.charCodeAt(++this.pos);
+    if (next === 43 || next === 45) {
+      ++this.pos;
+    }
+    if (this.readInt(10) === null) {
+      this.raise(start3, "Invalid number");
+    }
+  }
+  if (isIdentifierStart(this.fullCharCodeAtPos())) {
+    this.raise(this.pos, "Identifier directly after number");
+  }
+  var val = stringToNumber(this.input.slice(start3, this.pos), octal);
+  return this.finishToken(types$1.num, val);
+};
+pp.readCodePoint = function() {
+  var ch = this.input.charCodeAt(this.pos), code3;
+  if (ch === 123) {
+    if (this.options.ecmaVersion < 6) {
+      this.unexpected();
+    }
+    var codePos = ++this.pos;
+    code3 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
+    ++this.pos;
+    if (code3 > 1114111) {
+      this.invalidStringToken(codePos, "Code point out of bounds");
+    }
+  } else {
+    code3 = this.readHexChar(4);
+  }
+  return code3;
+};
+function codePointToString(code3) {
+  if (code3 <= 65535) {
+    return String.fromCharCode(code3);
+  }
+  code3 -= 65536;
+  return String.fromCharCode((code3 >> 10) + 55296, (code3 & 1023) + 56320);
+}
+pp.readString = function(quote) {
+  var out = "", chunkStart = ++this.pos;
+  for (; ; ) {
+    if (this.pos >= this.input.length) {
+      this.raise(this.start, "Unterminated string constant");
+    }
+    var ch = this.input.charCodeAt(this.pos);
+    if (ch === quote) {
+      break;
+    }
+    if (ch === 92) {
+      out += this.input.slice(chunkStart, this.pos);
+      out += this.readEscapedChar(false);
+      chunkStart = this.pos;
+    } else if (ch === 8232 || ch === 8233) {
+      if (this.options.ecmaVersion < 10) {
+        this.raise(this.start, "Unterminated string constant");
+      }
+      ++this.pos;
+      if (this.options.locations) {
+        this.curLine++;
+        this.lineStart = this.pos;
+      }
+    } else {
+      if (isNewLine(ch)) {
+        this.raise(this.start, "Unterminated string constant");
+      }
+      ++this.pos;
+    }
+  }
+  out += this.input.slice(chunkStart, this.pos++);
+  return this.finishToken(types$1.string, out);
+};
+var INVALID_TEMPLATE_ESCAPE_ERROR = {};
+pp.tryReadTemplateToken = function() {
+  this.inTemplateElement = true;
+  try {
+    this.readTmplToken();
+  } catch (err) {
+    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
+      this.readInvalidTemplateToken();
+    } else {
+      throw err;
+    }
+  }
+  this.inTemplateElement = false;
+};
+pp.invalidStringToken = function(position4, message) {
+  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
+    throw INVALID_TEMPLATE_ESCAPE_ERROR;
+  } else {
+    this.raise(position4, message);
+  }
+};
+pp.readTmplToken = function() {
+  var out = "", chunkStart = this.pos;
+  for (; ; ) {
+    if (this.pos >= this.input.length) {
+      this.raise(this.start, "Unterminated template");
+    }
+    var ch = this.input.charCodeAt(this.pos);
+    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
+      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
+        if (ch === 36) {
+          this.pos += 2;
+          return this.finishToken(types$1.dollarBraceL);
+        } else {
+          ++this.pos;
+          return this.finishToken(types$1.backQuote);
+        }
+      }
+      out += this.input.slice(chunkStart, this.pos);
+      return this.finishToken(types$1.template, out);
+    }
+    if (ch === 92) {
+      out += this.input.slice(chunkStart, this.pos);
+      out += this.readEscapedChar(true);
+      chunkStart = this.pos;
+    } else if (isNewLine(ch)) {
+      out += this.input.slice(chunkStart, this.pos);
+      ++this.pos;
+      switch (ch) {
+        case 13:
+          if (this.input.charCodeAt(this.pos) === 10) {
+            ++this.pos;
+          }
+        case 10:
+          out += "\n";
+          break;
+        default:
+          out += String.fromCharCode(ch);
+          break;
+      }
+      if (this.options.locations) {
+        ++this.curLine;
+        this.lineStart = this.pos;
+      }
+      chunkStart = this.pos;
+    } else {
+      ++this.pos;
+    }
+  }
+};
+pp.readInvalidTemplateToken = function() {
+  for (; this.pos < this.input.length; this.pos++) {
+    switch (this.input[this.pos]) {
+      case "\\":
+        ++this.pos;
+        break;
+      case "$":
+        if (this.input[this.pos + 1] !== "{") {
+          break;
+        }
+      case "`":
+        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
+    }
+  }
+  this.raise(this.start, "Unterminated template");
+};
+pp.readEscapedChar = function(inTemplate) {
+  var ch = this.input.charCodeAt(++this.pos);
+  ++this.pos;
+  switch (ch) {
+    case 110:
+      return "\n";
+    case 114:
+      return "\r";
+    case 120:
+      return String.fromCharCode(this.readHexChar(2));
+    case 117:
+      return codePointToString(this.readCodePoint());
+    case 116:
+      return "	";
+    case 98:
+      return "\b";
+    case 118:
+      return "\v";
+    case 102:
+      return "\f";
+    case 13:
+      if (this.input.charCodeAt(this.pos) === 10) {
+        ++this.pos;
+      }
+    case 10:
+      if (this.options.locations) {
+        this.lineStart = this.pos;
+        ++this.curLine;
+      }
+      return "";
+    case 56:
+    case 57:
+      if (this.strict) {
+        this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
+      }
+      if (inTemplate) {
+        var codePos = this.pos - 1;
+        this.invalidStringToken(codePos, "Invalid escape sequence in template string");
+        return null;
+      }
+    default:
+      if (ch >= 48 && ch <= 55) {
+        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
+        var octal = parseInt(octalStr, 8);
+        if (octal > 255) {
+          octalStr = octalStr.slice(0, -1);
+          octal = parseInt(octalStr, 8);
+        }
+        this.pos += octalStr.length - 1;
+        ch = this.input.charCodeAt(this.pos);
+        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
+          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
+        }
+        return String.fromCharCode(octal);
+      }
+      if (isNewLine(ch)) {
+        return "";
+      }
+      return String.fromCharCode(ch);
+  }
+};
+pp.readHexChar = function(len) {
+  var codePos = this.pos;
+  var n = this.readInt(16, len);
+  if (n === null) {
+    this.invalidStringToken(codePos, "Bad character escape sequence");
+  }
+  return n;
+};
+pp.readWord1 = function() {
+  this.containsEsc = false;
+  var word = "", first = true, chunkStart = this.pos;
+  var astral = this.options.ecmaVersion >= 6;
+  while (this.pos < this.input.length) {
+    var ch = this.fullCharCodeAtPos();
+    if (isIdentifierChar(ch, astral)) {
+      this.pos += ch <= 65535 ? 1 : 2;
+    } else if (ch === 92) {
+      this.containsEsc = true;
+      word += this.input.slice(chunkStart, this.pos);
+      var escStart = this.pos;
+      if (this.input.charCodeAt(++this.pos) !== 117) {
+        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
+      }
+      ++this.pos;
+      var esc = this.readCodePoint();
+      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
+        this.invalidStringToken(escStart, "Invalid Unicode escape");
+      }
+      word += codePointToString(esc);
+      chunkStart = this.pos;
+    } else {
+      break;
+    }
+    first = false;
+  }
+  return word + this.input.slice(chunkStart, this.pos);
+};
+pp.readWord = function() {
+  var word = this.readWord1();
+  var type2 = types$1.name;
+  if (this.keywords.test(word)) {
+    type2 = keywords[word];
+  }
+  return this.finishToken(type2, word);
+};
+var version = "8.7.0";
+Parser.acorn = {
+  Parser,
+  version,
+  defaultOptions,
+  Position,
+  SourceLocation,
+  getLineInfo,
+  Node,
+  TokenType,
+  tokTypes: types$1,
+  keywordTypes: keywords,
+  TokContext,
+  tokContexts: types,
+  isIdentifierChar,
+  isIdentifierStart,
+  Token,
+  isNewLine,
+  lineBreak,
+  lineBreakG,
+  nonASCIIwhitespace
+};
+
+// ../../node_modules/.pnpm/micromark-extension-mdxjs@1.0.0/node_modules/micromark-extension-mdxjs/index.js
+var import_acorn_jsx = __toESM(require_acorn_jsx(), 1);
+
+// ../../node_modules/.pnpm/micromark-util-chunked@1.0.0/node_modules/micromark-util-chunked/index.js
+function splice(list3, start3, remove, items) {
+  const end = list3.length;
+  let chunkStart = 0;
+  let parameters;
+  if (start3 < 0) {
+    start3 = -start3 > end ? 0 : end + start3;
+  } else {
+    start3 = start3 > end ? end : start3;
+  }
+  remove = remove > 0 ? remove : 0;
+  if (items.length < 1e4) {
+    parameters = Array.from(items);
+    parameters.unshift(start3, remove);
+    [].splice.apply(list3, parameters);
+  } else {
+    if (remove)
+      [].splice.apply(list3, [start3, remove]);
+    while (chunkStart < items.length) {
+      parameters = items.slice(chunkStart, chunkStart + 1e4);
+      parameters.unshift(start3, 0);
+      [].splice.apply(list3, parameters);
+      chunkStart += 1e4;
+      start3 += 1e4;
+    }
+  }
+}
+function push(list3, items) {
+  if (list3.length > 0) {
+    splice(list3, list3.length, 0, items);
+    return list3;
+  }
+  return items;
+}
+
+// ../../node_modules/.pnpm/micromark-util-combine-extensions@1.0.0/node_modules/micromark-util-combine-extensions/index.js
+var hasOwnProperty2 = {}.hasOwnProperty;
+function combineExtensions(extensions) {
+  const all4 = {};
+  let index3 = -1;
+  while (++index3 < extensions.length) {
+    syntaxExtension(all4, extensions[index3]);
+  }
+  return all4;
+}
+function syntaxExtension(all4, extension2) {
+  let hook;
+  for (hook in extension2) {
+    const maybe = hasOwnProperty2.call(all4, hook) ? all4[hook] : void 0;
+    const left = maybe || (all4[hook] = {});
+    const right = extension2[hook];
+    let code3;
+    for (code3 in right) {
+      if (!hasOwnProperty2.call(left, code3))
+        left[code3] = [];
+      const value = right[code3];
+      constructs(left[code3], Array.isArray(value) ? value : value ? [value] : []);
+    }
+  }
+}
+function constructs(existing, list3) {
+  let index3 = -1;
+  const before = [];
+  while (++index3 < list3.length) {
+    ;
+    (list3[index3].add === "after" ? existing : before).push(list3[index3]);
+  }
+  splice(existing, 0, 0, before);
+}
+
+// ../../node_modules/.pnpm/micromark-util-character@1.1.0/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
+var unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
+
+// ../../node_modules/.pnpm/micromark-util-character@1.1.0/node_modules/micromark-util-character/index.js
+var asciiAlpha = regexCheck(/[A-Za-z]/);
+var asciiDigit = regexCheck(/\d/);
+var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
+var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
+var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
+var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
+function asciiControl(code3) {
+  return code3 !== null && (code3 < 32 || code3 === 127);
+}
+function markdownLineEndingOrSpace(code3) {
+  return code3 !== null && (code3 < 0 || code3 === 32);
+}
+function markdownLineEnding(code3) {
+  return code3 !== null && code3 < -2;
+}
+function markdownSpace(code3) {
+  return code3 === -2 || code3 === -1 || code3 === 32;
+}
+var unicodeWhitespace = regexCheck(/\s/);
+var unicodePunctuation = regexCheck(unicodePunctuationRegex);
+function regexCheck(regex2) {
+  return check;
+  function check(code3) {
+    return code3 !== null && regex2.test(String.fromCharCode(code3));
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-factory-space@1.0.0/node_modules/micromark-factory-space/index.js
+function factorySpace(effects, ok3, type2, max) {
+  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
+  let size = 0;
+  return start3;
+  function start3(code3) {
+    if (markdownSpace(code3)) {
+      effects.enter(type2);
+      return prefix(code3);
+    }
+    return ok3(code3);
+  }
+  function prefix(code3) {
+    if (markdownSpace(code3) && size++ < limit) {
+      effects.consume(code3);
+      return prefix;
+    }
+    effects.exit(type2);
+    return ok3(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/unist-util-position-from-estree@1.1.1/node_modules/unist-util-position-from-estree/index.js
+function positionFromEstree(value) {
+  const node = value || {};
+  const loc = node.loc || {};
+  const range = node.range || [0, 0];
+  const startOffset = range[0] || node.start;
+  const endOffset = range[1] || node.end;
+  return {
+    start: {
+      line: loc.start && typeof loc.start.line === "number" && loc.start.line > -1 ? loc.start.line : void 0,
+      column: loc.start && typeof loc.start.column === "number" && loc.start.column > -1 ? loc.start.column + 1 : void 0,
+      offset: typeof startOffset === "number" && startOffset > -1 ? startOffset : void 0
+    },
+    end: {
+      line: loc.end && typeof loc.end.line === "number" && loc.end.line > -1 ? loc.end.line : void 0,
+      column: loc.end && typeof loc.end.column === "number" && loc.end.column > -1 ? loc.end.column + 1 : void 0,
+      offset: typeof endOffset === "number" && endOffset > -1 ? endOffset : void 0
+    }
+  };
+}
+
+// ../../node_modules/.pnpm/estree-util-visit@1.1.0/node_modules/estree-util-visit/color.js
+function color(d) {
+  return "\x1B[33m" + d + "\x1B[39m";
+}
+
+// ../../node_modules/.pnpm/estree-util-visit@1.1.0/node_modules/estree-util-visit/index.js
+var own3 = {}.hasOwnProperty;
+var CONTINUE = Symbol("continue");
+var SKIP = Symbol("skip");
+var EXIT = Symbol("exit");
+function visit(tree, visitor) {
+  var enter;
+  var leave;
+  if (typeof visitor === "function") {
+    enter = visitor;
+  } else if (visitor && typeof visitor === "object") {
+    enter = visitor.enter;
+    leave = visitor.leave;
+  }
+  build(tree, null, null, [])();
+  function build(node, key, index3, parents) {
+    if (nodelike(node)) {
+      visit8.displayName = "node (" + color(node.type) + ")";
+    }
+    return visit8;
+    function visit8() {
+      var result = enter ? toResult(enter(node, key, index3, parents)) : [];
+      var cKey;
+      var cIndex;
+      var grandparents;
+      var subresult;
+      var value;
+      var subvalue;
+      if (result[0] === EXIT) {
+        return result;
+      }
+      if (result[0] !== SKIP) {
+        for (cKey in node) {
+          if (own3.call(node, cKey) && node[cKey] && typeof node[cKey] === "object" && cKey !== "data" && cKey !== "position") {
+            value = node[cKey];
+            grandparents = parents.concat(node);
+            if (Array.isArray(value)) {
+              cIndex = 0;
+              while (cIndex > -1 && cIndex < value.length) {
+                subvalue = value[cIndex];
+                if (nodelike(subvalue)) {
+                  subresult = build(subvalue, cKey, cIndex, grandparents)();
+                  if (subresult[0] === EXIT)
+                    return subresult;
+                  cIndex = typeof subresult[1] === "number" ? subresult[1] : cIndex + 1;
+                } else {
+                  cIndex++;
+                }
+              }
+            } else if (nodelike(value)) {
+              subresult = build(value, cKey, null, grandparents)();
+              if (subresult[0] === EXIT)
+                return subresult;
+            }
+          }
+        }
+      }
+      return leave ? toResult(leave(node, key, index3, parents)) : result;
+    }
+  }
+}
+function toResult(value) {
+  if (Array.isArray(value)) {
+    return value;
+  }
+  if (typeof value === "number") {
+    return [CONTINUE, value];
+  }
+  return [value];
+}
+function nodelike(value) {
+  return Boolean(value && typeof value === "object" && typeof value.type === "string" && value.type.length > 0);
+}
+
+// ../../node_modules/.pnpm/micromark-util-events-to-acorn@1.0.4/node_modules/micromark-util-events-to-acorn/index.js
+var own4 = {}.hasOwnProperty;
+function eventsToAcorn(events, options) {
+  const {
+    prefix = "",
+    suffix = ""
+  } = options;
+  const comments = [];
+  const acornConfig = Object.assign({}, options.acornOptions, {
+    onComment: comments,
+    preserveParens: true
+  });
+  const chunks = [];
+  const lines = {};
+  let index3 = -1;
+  let swallow = false;
+  let estree;
+  let exception;
+  let mdStartOffset;
+  if (options.start) {
+    mdStartOffset = options.start.offset;
+    lines[options.start.line] = options.start;
+  }
+  while (++index3 < events.length) {
+    const token = events[index3][1];
+    if (events[index3][0] === "exit") {
+      chunks.push(events[index3][2].sliceSerialize(token));
+      if (mdStartOffset === void 0) {
+        mdStartOffset = events[index3][1].start.offset;
+      }
+      if (!(token.start.line in lines) || lines[token.start.line].offset > token.start.offset) {
+        lines[token.start.line] = token.start;
+      }
+    }
+  }
+  const source = chunks.join("");
+  const value = prefix + source + suffix;
+  const isEmptyExpression = options.expression && empty2(source);
+  if (isEmptyExpression && !options.allowEmpty) {
+    throw new VFileMessage("Unexpected empty expression", parseOffsetToUnistPoint(0), "micromark-extension-mdx-expression:unexpected-empty-expression");
+  }
+  try {
+    estree = options.expression && !isEmptyExpression ? options.acorn.parseExpressionAt(value, 0, acornConfig) : options.acorn.parse(value, acornConfig);
+  } catch (error_) {
+    const error = error_;
+    const point4 = parseOffsetToUnistPoint(error.pos);
+    error.message = String(error.message).replace(/ \(\d+:\d+\)$/, "");
+    error.pos = point4.offset;
+    error.loc = {
+      line: point4.line,
+      column: point4.column - 1
+    };
+    exception = error;
+    swallow = error.raisedAt >= prefix.length + source.length || error.message === "Unterminated comment";
+  }
+  if (estree && options.expression && !isEmptyExpression) {
+    if (empty2(value.slice(estree.end, value.length - suffix.length))) {
+      estree = {
+        type: "Program",
+        start: 0,
+        end: prefix.length + source.length,
+        body: [{
+          type: "ExpressionStatement",
+          expression: estree,
+          start: 0,
+          end: prefix.length + source.length
+        }],
+        sourceType: "module",
+        comments: []
+      };
+    } else {
+      const point4 = parseOffsetToUnistPoint(estree.end);
+      exception = new Error("Unexpected content after expression");
+      exception.pos = point4.offset;
+      exception.loc = {
+        line: point4.line,
+        column: point4.column - 1
+      };
+      estree = void 0;
+    }
+  }
+  if (estree) {
+    estree.comments = comments;
+    visit(estree, (esnode, field, index4, parents) => {
+      let context = parents[parents.length - 1];
+      let prop = field;
+      if (esnode.type === "ParenthesizedExpression" && context && prop) {
+        if (typeof index4 === "number") {
+          context = context[prop];
+          prop = index4;
+        }
+        context[prop] = esnode.expression;
+      }
+      const pointStart2 = parseOffsetToUnistPoint(esnode.start);
+      const pointEnd2 = parseOffsetToUnistPoint(esnode.end);
+      esnode.start = pointStart2.offset;
+      esnode.end = pointEnd2.offset;
+      esnode.loc = {
+        start: {
+          line: pointStart2.line,
+          column: pointStart2.column - 1
+        },
+        end: {
+          line: pointEnd2.line,
+          column: pointEnd2.column - 1
+        }
+      };
+      esnode.range = [esnode.start, esnode.end];
+    });
+  }
+  return {
+    estree,
+    error: exception,
+    swallow
+  };
+  function parseOffsetToUnistPoint(offset2) {
+    let srcOffset = offset2 - prefix.length;
+    let line;
+    let lineStart;
+    if (srcOffset < 0) {
+      srcOffset = 0;
+    } else if (srcOffset > source.length) {
+      srcOffset = source.length;
+    }
+    srcOffset += mdStartOffset;
+    for (line in lines) {
+      if (own4.call(lines, line)) {
+        if (!lineStart) {
+          lineStart = lines[line];
+        }
+        if (lines[line].offset > offset2) {
+          break;
+        }
+        lineStart = lines[line];
+      }
+    }
+    return {
+      line: lineStart.line,
+      column: lineStart.column + (srcOffset - lineStart.offset),
+      offset: srcOffset
+    };
+  }
+}
+function empty2(value) {
+  return /^\s*$/.test(value.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
+}
+
+// ../../node_modules/.pnpm/micromark-factory-mdx-expression@1.0.5/node_modules/micromark-factory-mdx-expression/index.js
+function factoryMdxExpression(effects, ok3, type2, markerType, chunkType, acorn, acornOptions, addResult, spread, allowEmpty, allowLazy) {
+  const self2 = this;
+  const eventStart = this.events.length + 3;
+  const tail = this.events[this.events.length - 1];
+  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
+  let balance = 1;
+  let startPosition;
+  let lastCrash;
+  return start3;
+  function start3(code3) {
+    effects.enter(type2);
+    effects.enter(markerType);
+    effects.consume(code3);
+    effects.exit(markerType);
+    startPosition = self2.now();
+    return atBreak;
+  }
+  function atBreak(code3) {
+    if (code3 === null) {
+      throw lastCrash || new VFileMessage("Unexpected end of file in expression, expected a corresponding closing brace for `{`", self2.now(), "micromark-extension-mdx-expression:unexpected-eof");
+    }
+    if (code3 === 125) {
+      return atClosingBrace(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      effects.enter("lineEnding");
+      effects.consume(code3);
+      effects.exit("lineEnding");
+      return initialPrefix ? factorySpace(effects, atBreak, "linePrefix", initialPrefix + 1) : atBreak;
+    }
+    const now = self2.now();
+    if (now.line !== startPosition.line && !allowLazy && self2.parser.lazy[now.line]) {
+      throw new VFileMessage("Unexpected end of file in expression, expected a corresponding closing brace for `{`", self2.now(), "micromark-extension-mdx-expression:unexpected-eof");
+    }
+    effects.enter(chunkType);
+    return inside(code3);
+  }
+  function inside(code3) {
+    if (code3 === null || code3 === 125 || markdownLineEnding(code3)) {
+      effects.exit(chunkType);
+      return atBreak(code3);
+    }
+    if (code3 === 123 && !acorn) {
+      effects.consume(code3);
+      balance++;
+      return inside;
+    }
+    effects.consume(code3);
+    return inside;
+  }
+  function atClosingBrace(code3) {
+    balance--;
+    if (!acorn) {
+      if (balance) {
+        effects.enter(chunkType);
+        effects.consume(code3);
+        return inside;
+      }
+      effects.enter(markerType);
+      effects.consume(code3);
+      effects.exit(markerType);
+      effects.exit(type2);
+      return ok3;
+    }
+    const result = eventsToAcorn(self2.events.slice(eventStart), {
+      acorn,
+      acornOptions,
+      start: startPosition,
+      expression: true,
+      allowEmpty,
+      prefix: spread ? "({" : "",
+      suffix: spread ? "})" : ""
+    });
+    const estree = result.estree;
+    if (spread && estree) {
+      const head = estree.body[0];
+      if (head.type !== "ExpressionStatement" || head.expression.type !== "ObjectExpression") {
+        throw new VFileMessage("Unexpected `" + head.type + "` in code: expected an object spread (`{...spread}`)", positionFromEstree(head).start, "micromark-extension-mdx-expression:non-spread");
+      } else if (head.expression.properties[1]) {
+        throw new VFileMessage("Unexpected extra content in spread: only a single spread is supported", positionFromEstree(head.expression.properties[1]).start, "micromark-extension-mdx-expression:spread-extra");
+      } else if (head.expression.properties[0] && head.expression.properties[0].type !== "SpreadElement") {
+        throw new VFileMessage("Unexpected `" + head.expression.properties[0].type + "` in code: only spread elements are supported", positionFromEstree(head.expression.properties[0]).start, "micromark-extension-mdx-expression:non-spread");
+      }
+    }
+    if (result.error) {
+      lastCrash = new VFileMessage("Could not parse expression with acorn: " + result.error.message, {
+        line: result.error.loc.line,
+        column: result.error.loc.column + 1,
+        offset: result.error.pos
+      }, "micromark-extension-mdx-expression:acorn");
+      if (code3 !== null && result.swallow) {
+        effects.enter(chunkType);
+        effects.consume(code3);
+        return inside;
+      }
+      throw lastCrash;
+    }
+    effects.enter(markerType);
+    effects.consume(code3);
+    effects.exit(markerType);
+    Object.assign(effects.exit(type2), addResult ? {
+      estree
+    } : void 0);
+    return ok3;
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-mdx-expression@1.0.3/node_modules/micromark-extension-mdx-expression/lib/syntax.js
+function mdxExpression(options = {}) {
+  const addResult = options.addResult;
+  const acorn = options.acorn;
+  const spread = options.spread;
+  let allowEmpty = options.allowEmpty;
+  let acornOptions;
+  if (allowEmpty === null || allowEmpty === void 0) {
+    allowEmpty = true;
+  }
+  if (acorn) {
+    if (!acorn.parseExpressionAt) {
+      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
+    }
+    acornOptions = Object.assign({
+      ecmaVersion: 2020,
+      sourceType: "module"
+    }, options.acornOptions);
+  } else if (options.acornOptions || options.addResult) {
+    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
+  }
+  return {
+    flow: {
+      [123]: {
+        tokenize: tokenizeFlowExpression,
+        concrete: true
+      }
+    },
+    text: {
+      [123]: {
+        tokenize: tokenizeTextExpression
+      }
+    }
+  };
+  function tokenizeFlowExpression(effects, ok3, nok) {
+    const self2 = this;
+    return start3;
+    function start3(code3) {
+      return factoryMdxExpression.call(self2, effects, factorySpace(effects, after, "whitespace"), "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", acorn, acornOptions, addResult, spread, allowEmpty)(code3);
+    }
+    function after(code3) {
+      return code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
+    }
+  }
+  function tokenizeTextExpression(effects, ok3) {
+    const self2 = this;
+    return start3;
+    function start3(code3) {
+      return factoryMdxExpression.call(self2, effects, ok3, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", acorn, acornOptions, addResult, spread, allowEmpty, true)(code3);
+    }
+  }
+}
+
+// ../../node_modules/.pnpm/estree-util-is-identifier-name@2.0.0/node_modules/estree-util-is-identifier-name/regex.js
+var start = /[$A-Z_a-z\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
+var cont = /[\d\u00B7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]/;
+
+// ../../node_modules/.pnpm/estree-util-is-identifier-name@2.0.0/node_modules/estree-util-is-identifier-name/index.js
+function start2(code3) {
+  return start.test(String.fromCharCode(code3));
+}
+function cont2(code3) {
+  var character = String.fromCharCode(code3);
+  return start.test(character) || cont.test(character);
+}
+function name(name3) {
+  var index3 = -1;
+  while (++index3 < name3.length) {
+    if (!(index3 ? cont2 : start2)(name3.charCodeAt(index3)))
+      return false;
+  }
+  return index3 > 0;
+}
+
+// ../../node_modules/.pnpm/micromark-extension-mdx-jsx@1.0.2/node_modules/micromark-extension-mdx-jsx/lib/factory-tag.js
+var lazyLineEnd = {
+  tokenize: tokenizeLazyLineEnd,
+  partial: true
+};
+function factoryTag(effects, ok3, nok, acorn, acornOptions, addResult, allowLazy, tagType, tagMarkerType, tagClosingMarkerType, tagSelfClosingMarker, tagNameType, tagNamePrimaryType, tagNameMemberMarkerType, tagNameMemberType, tagNamePrefixMarkerType, tagNameLocalType, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, tagAttributeType, tagAttributeNameType, tagAttributeNamePrimaryType, tagAttributeNamePrefixMarkerType, tagAttributeNameLocalType, tagAttributeInitializerMarkerType, tagAttributeValueLiteralType, tagAttributeValueLiteralMarkerType, tagAttributeValueLiteralValueType, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionMarkerValue) {
+  const self2 = this;
+  let returnState;
+  let marker;
+  return start3;
+  function start3(code3) {
+    effects.enter(tagType);
+    effects.enter(tagMarkerType);
+    effects.consume(code3);
+    effects.exit(tagMarkerType);
+    return afterStart;
+  }
+  function afterStart(code3) {
+    if (markdownLineEnding(code3) || markdownSpace(code3)) {
+      return nok(code3);
+    }
+    returnState = beforeName;
+    return optionalEsWhitespace(code3);
+  }
+  function beforeName(code3) {
+    if (code3 === 47) {
+      effects.enter(tagClosingMarkerType);
+      effects.consume(code3);
+      effects.exit(tagClosingMarkerType);
+      returnState = beforeClosingTagName;
+      return optionalEsWhitespace;
+    }
+    if (code3 === 62) {
+      return tagEnd(code3);
+    }
+    if (code3 !== null && start2(code3)) {
+      effects.enter(tagNameType);
+      effects.enter(tagNamePrimaryType);
+      effects.consume(code3);
+      return primaryName;
+    }
+    crash(code3, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : ""));
+  }
+  function beforeClosingTagName(code3) {
+    if (code3 === 62) {
+      return tagEnd(code3);
+    }
+    if (code3 !== null && start2(code3)) {
+      effects.enter(tagNameType);
+      effects.enter(tagNamePrimaryType);
+      effects.consume(code3);
+      return primaryName;
+    }
+    crash(code3, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === 42 || code3 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
+  }
+  function primaryName(code3) {
+    if (code3 === 45 || code3 !== null && cont2(code3)) {
+      effects.consume(code3);
+      return primaryName;
+    }
+    if (code3 === 46 || code3 === 47 || code3 === 58 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
+      effects.exit(tagNamePrimaryType);
+      returnState = afterPrimaryName;
+      return optionalEsWhitespace(code3);
+    }
+    crash(code3, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code3 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
+  }
+  function afterPrimaryName(code3) {
+    if (code3 === 46) {
+      effects.enter(tagNameMemberMarkerType);
+      effects.consume(code3);
+      effects.exit(tagNameMemberMarkerType);
+      returnState = beforeMemberName;
+      return optionalEsWhitespace;
+    }
+    if (code3 === 58) {
+      effects.enter(tagNamePrefixMarkerType);
+      effects.consume(code3);
+      effects.exit(tagNamePrefixMarkerType);
+      returnState = beforeLocalName;
+      return optionalEsWhitespace;
+    }
+    if (code3 === 47 || code3 === 62 || code3 === 123 || code3 !== null && start2(code3)) {
+      effects.exit(tagNameType);
+      return beforeAttribute(code3);
+    }
+    crash(code3, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
+  }
+  function beforeMemberName(code3) {
+    if (code3 !== null && start2(code3)) {
+      effects.enter(tagNameMemberType);
+      effects.consume(code3);
+      return memberName;
+    }
+    crash(code3, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
+  }
+  function memberName(code3) {
+    if (code3 === 45 || code3 !== null && cont2(code3)) {
+      effects.consume(code3);
+      return memberName;
+    }
+    if (code3 === 46 || code3 === 47 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
+      effects.exit(tagNameMemberType);
+      returnState = afterMemberName;
+      return optionalEsWhitespace(code3);
+    }
+    crash(code3, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code3 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
+  }
+  function afterMemberName(code3) {
+    if (code3 === 46) {
+      effects.enter(tagNameMemberMarkerType);
+      effects.consume(code3);
+      effects.exit(tagNameMemberMarkerType);
+      returnState = beforeMemberName;
+      return optionalEsWhitespace;
+    }
+    if (code3 === 47 || code3 === 62 || code3 === 123 || code3 !== null && start2(code3)) {
+      effects.exit(tagNameType);
+      return beforeAttribute(code3);
+    }
+    crash(code3, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
+  }
+  function beforeLocalName(code3) {
+    if (code3 !== null && start2(code3)) {
+      effects.enter(tagNameLocalType);
+      effects.consume(code3);
+      return localName;
+    }
+    crash(code3, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === 43 || code3 !== null && code3 > 46 && code3 < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
+  }
+  function localName(code3) {
+    if (code3 === 45 || code3 !== null && cont2(code3)) {
+      effects.consume(code3);
+      return localName;
+    }
+    if (code3 === 47 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
+      effects.exit(tagNameLocalType);
+      returnState = afterLocalName;
+      return optionalEsWhitespace(code3);
+    }
+    crash(code3, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
+  }
+  function afterLocalName(code3) {
+    if (code3 === 47 || code3 === 62 || code3 === 123 || code3 !== null && start2(code3)) {
+      effects.exit(tagNameType);
+      return beforeAttribute(code3);
+    }
+    crash(code3, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
+  }
+  function beforeAttribute(code3) {
+    if (code3 === 47) {
+      effects.enter(tagSelfClosingMarker);
+      effects.consume(code3);
+      effects.exit(tagSelfClosingMarker);
+      returnState = selfClosing;
+      return optionalEsWhitespace;
+    }
+    if (code3 === 62) {
+      return tagEnd(code3);
+    }
+    if (code3 === 123) {
+      return factoryMdxExpression.call(self2, effects, afterAttributeExpression, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, acorn, acornOptions, addResult, true, false, allowLazy)(code3);
+    }
+    if (code3 !== null && start2(code3)) {
+      effects.enter(tagAttributeType);
+      effects.enter(tagAttributeNameType);
+      effects.enter(tagAttributeNamePrimaryType);
+      effects.consume(code3);
+      return attributePrimaryName;
+    }
+    crash(code3, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
+  }
+  function afterAttributeExpression(code3) {
+    returnState = beforeAttribute;
+    return optionalEsWhitespace(code3);
+  }
+  function attributePrimaryName(code3) {
+    if (code3 === 45 || code3 !== null && cont2(code3)) {
+      effects.consume(code3);
+      return attributePrimaryName;
+    }
+    if (code3 === 47 || code3 === 58 || code3 === 61 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
+      effects.exit(tagAttributeNamePrimaryType);
+      returnState = afterAttributePrimaryName;
+      return optionalEsWhitespace(code3);
+    }
+    crash(code3, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
+  }
+  function afterAttributePrimaryName(code3) {
+    if (code3 === 58) {
+      effects.enter(tagAttributeNamePrefixMarkerType);
+      effects.consume(code3);
+      effects.exit(tagAttributeNamePrefixMarkerType);
+      returnState = beforeAttributeLocalName;
+      return optionalEsWhitespace;
+    }
+    if (code3 === 61) {
+      effects.exit(tagAttributeNameType);
+      effects.enter(tagAttributeInitializerMarkerType);
+      effects.consume(code3);
+      effects.exit(tagAttributeInitializerMarkerType);
+      returnState = beforeAttributeValue;
+      return optionalEsWhitespace;
+    }
+    if (code3 === 47 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== null && start2(code3)) {
+      effects.exit(tagAttributeNameType);
+      effects.exit(tagAttributeType);
+      returnState = beforeAttribute;
+      return optionalEsWhitespace(code3);
+    }
+    crash(code3, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
+  }
+  function beforeAttributeLocalName(code3) {
+    if (code3 !== null && start2(code3)) {
+      effects.enter(tagAttributeNameLocalType);
+      effects.consume(code3);
+      return attributeLocalName;
+    }
+    crash(code3, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
+  }
+  function attributeLocalName(code3) {
+    if (code3 === 45 || code3 !== null && cont2(code3)) {
+      effects.consume(code3);
+      return attributeLocalName;
+    }
+    if (code3 === 47 || code3 === 61 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
+      effects.exit(tagAttributeNameLocalType);
+      effects.exit(tagAttributeNameType);
+      returnState = afterAttributeLocalName;
+      return optionalEsWhitespace(code3);
+    }
+    crash(code3, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
+  }
+  function afterAttributeLocalName(code3) {
+    if (code3 === 61) {
+      effects.enter(tagAttributeInitializerMarkerType);
+      effects.consume(code3);
+      effects.exit(tagAttributeInitializerMarkerType);
+      returnState = beforeAttributeValue;
+      return optionalEsWhitespace;
+    }
+    if (code3 === 47 || code3 === 62 || code3 === 123 || code3 !== null && start2(code3)) {
+      effects.exit(tagAttributeType);
+      return beforeAttribute(code3);
+    }
+    crash(code3, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
+  }
+  function beforeAttributeValue(code3) {
+    if (code3 === 34 || code3 === 39) {
+      effects.enter(tagAttributeValueLiteralType);
+      effects.enter(tagAttributeValueLiteralMarkerType);
+      effects.consume(code3);
+      effects.exit(tagAttributeValueLiteralMarkerType);
+      marker = code3;
+      return attributeValueQuotedStart;
+    }
+    if (code3 === 123) {
+      return factoryMdxExpression.call(self2, effects, afterAttributeValueExpression, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionMarkerValue, acorn, acornOptions, addResult, false, false, allowLazy)(code3);
+    }
+    crash(code3, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (code3 === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : ""));
+  }
+  function afterAttributeValueExpression(code3) {
+    effects.exit(tagAttributeType);
+    returnState = beforeAttribute;
+    return optionalEsWhitespace(code3);
+  }
+  function attributeValueQuotedStart(code3) {
+    if (code3 === null) {
+      crash(code3, "in attribute value", "a corresponding closing quote `" + String.fromCharCode(marker) + "`");
+    }
+    if (code3 === marker) {
+      effects.enter(tagAttributeValueLiteralMarkerType);
+      effects.consume(code3);
+      effects.exit(tagAttributeValueLiteralMarkerType);
+      effects.exit(tagAttributeValueLiteralType);
+      effects.exit(tagAttributeType);
+      marker = void 0;
+      returnState = beforeAttribute;
+      return optionalEsWhitespace;
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = attributeValueQuotedStart;
+      return optionalEsWhitespace(code3);
+    }
+    effects.enter(tagAttributeValueLiteralValueType);
+    return attributeValueQuoted(code3);
+  }
+  function attributeValueQuoted(code3) {
+    if (code3 === null || code3 === marker || markdownLineEnding(code3)) {
+      effects.exit(tagAttributeValueLiteralValueType);
+      return attributeValueQuotedStart(code3);
+    }
+    effects.consume(code3);
+    return attributeValueQuoted;
+  }
+  function selfClosing(code3) {
+    if (code3 === 62) {
+      return tagEnd(code3);
+    }
+    crash(code3, "after self-closing slash", "`>` to end the tag" + (code3 === 42 || code3 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
+  }
+  function tagEnd(code3) {
+    effects.enter(tagMarkerType);
+    effects.consume(code3);
+    effects.exit(tagMarkerType);
+    effects.exit(tagType);
+    return ok3;
+  }
+  function optionalEsWhitespace(code3) {
+    if (markdownLineEnding(code3)) {
+      if (allowLazy) {
+        effects.enter("lineEnding");
+        effects.consume(code3);
+        effects.exit("lineEnding");
+        return optionalEsWhitespace;
+      }
+      return effects.attempt(lazyLineEnd, optionalEsWhitespace, crashEol)(code3);
+    }
+    if (markdownSpace(code3) || unicodeWhitespace(code3)) {
+      effects.enter("esWhitespace");
+      return optionalEsWhitespaceContinue(code3);
+    }
+    return returnState(code3);
+  }
+  function optionalEsWhitespaceContinue(code3) {
+    if (markdownLineEnding(code3) || !(markdownSpace(code3) || unicodeWhitespace(code3))) {
+      effects.exit("esWhitespace");
+      return optionalEsWhitespace(code3);
+    }
+    effects.consume(code3);
+    return optionalEsWhitespaceContinue;
+  }
+  function crashEol() {
+    throw new VFileMessage("Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", self2.now(), "micromark-extension-mdx-jsx:unexpected-eof");
+  }
+  function crash(code3, at2, expect) {
+    throw new VFileMessage("Unexpected " + (code3 === null ? "end of file" : "character `" + (code3 === 96 ? "` ` `" : String.fromCharCode(code3)) + "` (" + serializeCharCode(code3) + ")") + " " + at2 + ", expected " + expect, self2.now(), "micromark-extension-mdx-jsx:unexpected-" + (code3 === null ? "eof" : "character"));
+  }
+}
+function tokenizeLazyLineEnd(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    effects.enter("lineEnding");
+    effects.consume(code3);
+    effects.exit("lineEnding");
+    return lineStart;
+  }
+  function lineStart(code3) {
+    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
+  }
+}
+function serializeCharCode(code3) {
+  return "U+" + code3.toString(16).toUpperCase().padStart(4, "0");
+}
+
+// ../../node_modules/.pnpm/micromark-extension-mdx-jsx@1.0.2/node_modules/micromark-extension-mdx-jsx/lib/jsx-text.js
+function jsxText(acorn, acornOptions, addResult) {
+  return {
+    tokenize: tokenizeJsxText
+  };
+  function tokenizeJsxText(effects, ok3, nok) {
+    return factoryTag.call(this, effects, ok3, nok, acorn, acornOptions, addResult, true, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember", "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker", "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "mdxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttributeValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpression", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue");
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-mdx-jsx@1.0.2/node_modules/micromark-extension-mdx-jsx/lib/jsx-flow.js
+function jsxFlow(acorn, acornOptions, addResult) {
+  return {
+    tokenize: tokenizeJsxFlow,
+    concrete: true
+  };
+  function tokenizeJsxFlow(effects, ok3, nok) {
+    const self2 = this;
+    return start3;
+    function start3(code3) {
+      return factoryTag.call(self2, effects, factorySpace(effects, after, "whitespace"), nok, acorn, acornOptions, addResult, false, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember", "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker", "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttributeValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpression", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(code3);
+    }
+    function after(code3) {
+      return code3 === 60 ? start3(code3) : code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
+    }
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-mdx-jsx@1.0.2/node_modules/micromark-extension-mdx-jsx/lib/syntax.js
+function mdxJsx(options = {}) {
+  const acorn = options.acorn;
+  let acornOptions;
+  if (acorn) {
+    if (!acorn.parse || !acorn.parseExpressionAt) {
+      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
+    }
+    acornOptions = Object.assign({
+      ecmaVersion: 2020,
+      sourceType: "module"
+    }, options.acornOptions, {
+      locations: true
+    });
+  } else if (options.acornOptions || options.addResult) {
+    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
+  }
+  return {
+    flow: {
+      [60]: jsxFlow(acorn, acornOptions, options.addResult)
+    },
+    text: {
+      [60]: jsxText(acorn, acornOptions, options.addResult)
+    }
+  };
+}
+
+// ../../node_modules/.pnpm/micromark-extension-mdx-md@1.0.0/node_modules/micromark-extension-mdx-md/index.js
+var mdxMd = {
+  disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
+};
+
+// ../../node_modules/.pnpm/micromark-util-classify-character@1.0.0/node_modules/micromark-util-classify-character/index.js
+function classifyCharacter(code3) {
+  if (code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
+    return 1;
+  }
+  if (unicodePunctuation(code3)) {
+    return 2;
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-util-resolve-all@1.0.0/node_modules/micromark-util-resolve-all/index.js
+function resolveAll(constructs2, events, context) {
+  const called = [];
+  let index3 = -1;
+  while (++index3 < constructs2.length) {
+    const resolve = constructs2[index3].resolveAll;
+    if (resolve && !called.includes(resolve)) {
+      events = resolve(events, context);
+      called.push(resolve);
+    }
+  }
+  return events;
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/attention.js
+var attention = {
+  name: "attention",
+  tokenize: tokenizeAttention,
+  resolveAll: resolveAllAttention
+};
+function resolveAllAttention(events, context) {
+  let index3 = -1;
+  let open;
+  let group;
+  let text7;
+  let openingSequence;
+  let closingSequence;
+  let use;
+  let nextEvents;
+  let offset2;
+  while (++index3 < events.length) {
+    if (events[index3][0] === "enter" && events[index3][1].type === "attentionSequence" && events[index3][1]._close) {
+      open = index3;
+      while (open--) {
+        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index3][1]).charCodeAt(0)) {
+          if ((events[open][1]._close || events[index3][1]._open) && (events[index3][1].end.offset - events[index3][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index3][1].end.offset - events[index3][1].start.offset) % 3)) {
+            continue;
+          }
+          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index3][1].end.offset - events[index3][1].start.offset > 1 ? 2 : 1;
+          const start3 = Object.assign({}, events[open][1].end);
+          const end = Object.assign({}, events[index3][1].start);
+          movePoint(start3, -use);
+          movePoint(end, use);
+          openingSequence = {
+            type: use > 1 ? "strongSequence" : "emphasisSequence",
+            start: start3,
+            end: Object.assign({}, events[open][1].end)
+          };
+          closingSequence = {
+            type: use > 1 ? "strongSequence" : "emphasisSequence",
+            start: Object.assign({}, events[index3][1].start),
+            end
+          };
+          text7 = {
+            type: use > 1 ? "strongText" : "emphasisText",
+            start: Object.assign({}, events[open][1].end),
+            end: Object.assign({}, events[index3][1].start)
+          };
+          group = {
+            type: use > 1 ? "strong" : "emphasis",
+            start: Object.assign({}, openingSequence.start),
+            end: Object.assign({}, closingSequence.end)
+          };
+          events[open][1].end = Object.assign({}, openingSequence.start);
+          events[index3][1].start = Object.assign({}, closingSequence.end);
+          nextEvents = [];
+          if (events[open][1].end.offset - events[open][1].start.offset) {
+            nextEvents = push(nextEvents, [
+              ["enter", events[open][1], context],
+              ["exit", events[open][1], context]
+            ]);
+          }
+          nextEvents = push(nextEvents, [
+            ["enter", group, context],
+            ["enter", openingSequence, context],
+            ["exit", openingSequence, context],
+            ["enter", text7, context]
+          ]);
+          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index3), context));
+          nextEvents = push(nextEvents, [
+            ["exit", text7, context],
+            ["enter", closingSequence, context],
+            ["exit", closingSequence, context],
+            ["exit", group, context]
+          ]);
+          if (events[index3][1].end.offset - events[index3][1].start.offset) {
+            offset2 = 2;
+            nextEvents = push(nextEvents, [
+              ["enter", events[index3][1], context],
+              ["exit", events[index3][1], context]
+            ]);
+          } else {
+            offset2 = 0;
+          }
+          splice(events, open - 1, index3 - open + 3, nextEvents);
+          index3 = open + nextEvents.length - offset2 - 2;
+          break;
+        }
+      }
+    }
+  }
+  index3 = -1;
+  while (++index3 < events.length) {
+    if (events[index3][1].type === "attentionSequence") {
+      events[index3][1].type = "data";
+    }
+  }
+  return events;
+}
+function tokenizeAttention(effects, ok3) {
+  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
+  const previous3 = this.previous;
+  const before = classifyCharacter(previous3);
+  let marker;
+  return start3;
+  function start3(code3) {
+    effects.enter("attentionSequence");
+    marker = code3;
+    return sequence(code3);
+  }
+  function sequence(code3) {
+    if (code3 === marker) {
+      effects.consume(code3);
+      return sequence;
+    }
+    const token = effects.exit("attentionSequence");
+    const after = classifyCharacter(code3);
+    const open = !after || after === 2 && before || attentionMarkers2.includes(code3);
+    const close = !before || before === 2 && after || attentionMarkers2.includes(previous3);
+    token._open = Boolean(marker === 42 ? open : open && (before || !close));
+    token._close = Boolean(marker === 42 ? close : close && (after || !open));
+    return ok3(code3);
+  }
+}
+function movePoint(point4, offset2) {
+  point4.column += offset2;
+  point4.offset += offset2;
+  point4._bufferIndex += offset2;
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/autolink.js
+var autolink = {
+  name: "autolink",
+  tokenize: tokenizeAutolink
+};
+function tokenizeAutolink(effects, ok3, nok) {
+  let size = 1;
+  return start3;
+  function start3(code3) {
+    effects.enter("autolink");
+    effects.enter("autolinkMarker");
+    effects.consume(code3);
+    effects.exit("autolinkMarker");
+    effects.enter("autolinkProtocol");
+    return open;
+  }
+  function open(code3) {
+    if (asciiAlpha(code3)) {
+      effects.consume(code3);
+      return schemeOrEmailAtext;
+    }
+    return asciiAtext(code3) ? emailAtext(code3) : nok(code3);
+  }
+  function schemeOrEmailAtext(code3) {
+    return code3 === 43 || code3 === 45 || code3 === 46 || asciiAlphanumeric(code3) ? schemeInsideOrEmailAtext(code3) : emailAtext(code3);
+  }
+  function schemeInsideOrEmailAtext(code3) {
+    if (code3 === 58) {
+      effects.consume(code3);
+      return urlInside;
+    }
+    if ((code3 === 43 || code3 === 45 || code3 === 46 || asciiAlphanumeric(code3)) && size++ < 32) {
+      effects.consume(code3);
+      return schemeInsideOrEmailAtext;
+    }
+    return emailAtext(code3);
+  }
+  function urlInside(code3) {
+    if (code3 === 62) {
+      effects.exit("autolinkProtocol");
+      return end(code3);
+    }
+    if (code3 === null || code3 === 32 || code3 === 60 || asciiControl(code3)) {
+      return nok(code3);
+    }
+    effects.consume(code3);
+    return urlInside;
+  }
+  function emailAtext(code3) {
+    if (code3 === 64) {
+      effects.consume(code3);
+      size = 0;
+      return emailAtSignOrDot;
+    }
+    if (asciiAtext(code3)) {
+      effects.consume(code3);
+      return emailAtext;
+    }
+    return nok(code3);
+  }
+  function emailAtSignOrDot(code3) {
+    return asciiAlphanumeric(code3) ? emailLabel(code3) : nok(code3);
+  }
+  function emailLabel(code3) {
+    if (code3 === 46) {
+      effects.consume(code3);
+      size = 0;
+      return emailAtSignOrDot;
+    }
+    if (code3 === 62) {
+      effects.exit("autolinkProtocol").type = "autolinkEmail";
+      return end(code3);
+    }
+    return emailValue(code3);
+  }
+  function emailValue(code3) {
+    if ((code3 === 45 || asciiAlphanumeric(code3)) && size++ < 63) {
+      effects.consume(code3);
+      return code3 === 45 ? emailValue : emailLabel;
+    }
+    return nok(code3);
+  }
+  function end(code3) {
+    effects.enter("autolinkMarker");
+    effects.consume(code3);
+    effects.exit("autolinkMarker");
+    effects.exit("autolink");
+    return ok3;
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/blank-line.js
+var blankLine = {
+  tokenize: tokenizeBlankLine,
+  partial: true
+};
+function tokenizeBlankLine(effects, ok3, nok) {
+  return factorySpace(effects, afterWhitespace, "linePrefix");
+  function afterWhitespace(code3) {
+    return code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/block-quote.js
+var blockQuote = {
+  name: "blockQuote",
+  tokenize: tokenizeBlockQuoteStart,
+  continuation: {
+    tokenize: tokenizeBlockQuoteContinuation
+  },
+  exit
+};
+function tokenizeBlockQuoteStart(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    if (code3 === 62) {
+      const state = self2.containerState;
+      if (!state.open) {
+        effects.enter("blockQuote", {
+          _container: true
+        });
+        state.open = true;
+      }
+      effects.enter("blockQuotePrefix");
+      effects.enter("blockQuoteMarker");
+      effects.consume(code3);
+      effects.exit("blockQuoteMarker");
+      return after;
+    }
+    return nok(code3);
+  }
+  function after(code3) {
+    if (markdownSpace(code3)) {
+      effects.enter("blockQuotePrefixWhitespace");
+      effects.consume(code3);
+      effects.exit("blockQuotePrefixWhitespace");
+      effects.exit("blockQuotePrefix");
+      return ok3;
+    }
+    effects.exit("blockQuotePrefix");
+    return ok3(code3);
+  }
+}
+function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
+  return factorySpace(effects, effects.attempt(blockQuote, ok3, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
+}
+function exit(effects) {
+  effects.exit("blockQuote");
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/character-escape.js
+var characterEscape = {
+  name: "characterEscape",
+  tokenize: tokenizeCharacterEscape
+};
+function tokenizeCharacterEscape(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.enter("characterEscape");
+    effects.enter("escapeMarker");
+    effects.consume(code3);
+    effects.exit("escapeMarker");
+    return open;
+  }
+  function open(code3) {
+    if (asciiPunctuation(code3)) {
+      effects.enter("characterEscapeValue");
+      effects.consume(code3);
+      effects.exit("characterEscapeValue");
+      effects.exit("characterEscape");
+      return ok3;
+    }
+    return nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/character-entities@2.0.1/node_modules/character-entities/index.js
+var characterEntities = {
+  AEli: "\xC6",
+  AElig: "\xC6",
+  AM: "&",
+  AMP: "&",
+  Aacut: "\xC1",
+  Aacute: "\xC1",
+  Abreve: "\u0102",
+  Acir: "\xC2",
+  Acirc: "\xC2",
+  Acy: "\u0410",
+  Afr: "\u{1D504}",
+  Agrav: "\xC0",
+  Agrave: "\xC0",
+  Alpha: "\u0391",
+  Amacr: "\u0100",
+  And: "\u2A53",
+  Aogon: "\u0104",
+  Aopf: "\u{1D538}",
+  ApplyFunction: "\u2061",
+  Arin: "\xC5",
+  Aring: "\xC5",
+  Ascr: "\u{1D49C}",
+  Assign: "\u2254",
+  Atild: "\xC3",
+  Atilde: "\xC3",
+  Aum: "\xC4",
+  Auml: "\xC4",
+  Backslash: "\u2216",
+  Barv: "\u2AE7",
+  Barwed: "\u2306",
+  Bcy: "\u0411",
+  Because: "\u2235",
+  Bernoullis: "\u212C",
+  Beta: "\u0392",
+  Bfr: "\u{1D505}",
+  Bopf: "\u{1D539}",
+  Breve: "\u02D8",
+  Bscr: "\u212C",
+  Bumpeq: "\u224E",
+  CHcy: "\u0427",
+  COP: "\xA9",
+  COPY: "\xA9",
+  Cacute: "\u0106",
+  Cap: "\u22D2",
+  CapitalDifferentialD: "\u2145",
+  Cayleys: "\u212D",
+  Ccaron: "\u010C",
+  Ccedi: "\xC7",
+  Ccedil: "\xC7",
+  Ccirc: "\u0108",
+  Cconint: "\u2230",
+  Cdot: "\u010A",
+  Cedilla: "\xB8",
+  CenterDot: "\xB7",
+  Cfr: "\u212D",
+  Chi: "\u03A7",
+  CircleDot: "\u2299",
+  CircleMinus: "\u2296",
+  CirclePlus: "\u2295",
+  CircleTimes: "\u2297",
+  ClockwiseContourIntegral: "\u2232",
+  CloseCurlyDoubleQuote: "\u201D",
+  CloseCurlyQuote: "\u2019",
+  Colon: "\u2237",
+  Colone: "\u2A74",
+  Congruent: "\u2261",
+  Conint: "\u222F",
+  ContourIntegral: "\u222E",
+  Copf: "\u2102",
+  Coproduct: "\u2210",
+  CounterClockwiseContourIntegral: "\u2233",
+  Cross: "\u2A2F",
+  Cscr: "\u{1D49E}",
+  Cup: "\u22D3",
+  CupCap: "\u224D",
+  DD: "\u2145",
+  DDotrahd: "\u2911",
+  DJcy: "\u0402",
+  DScy: "\u0405",
+  DZcy: "\u040F",
+  Dagger: "\u2021",
+  Darr: "\u21A1",
+  Dashv: "\u2AE4",
+  Dcaron: "\u010E",
+  Dcy: "\u0414",
+  Del: "\u2207",
+  Delta: "\u0394",
+  Dfr: "\u{1D507}",
+  DiacriticalAcute: "\xB4",
+  DiacriticalDot: "\u02D9",
+  DiacriticalDoubleAcute: "\u02DD",
+  DiacriticalGrave: "`",
+  DiacriticalTilde: "\u02DC",
+  Diamond: "\u22C4",
+  DifferentialD: "\u2146",
+  Dopf: "\u{1D53B}",
+  Dot: "\xA8",
+  DotDot: "\u20DC",
+  DotEqual: "\u2250",
+  DoubleContourIntegral: "\u222F",
+  DoubleDot: "\xA8",
+  DoubleDownArrow: "\u21D3",
+  DoubleLeftArrow: "\u21D0",
+  DoubleLeftRightArrow: "\u21D4",
+  DoubleLeftTee: "\u2AE4",
+  DoubleLongLeftArrow: "\u27F8",
+  DoubleLongLeftRightArrow: "\u27FA",
+  DoubleLongRightArrow: "\u27F9",
+  DoubleRightArrow: "\u21D2",
+  DoubleRightTee: "\u22A8",
+  DoubleUpArrow: "\u21D1",
+  DoubleUpDownArrow: "\u21D5",
+  DoubleVerticalBar: "\u2225",
+  DownArrow: "\u2193",
+  DownArrowBar: "\u2913",
+  DownArrowUpArrow: "\u21F5",
+  DownBreve: "\u0311",
+  DownLeftRightVector: "\u2950",
+  DownLeftTeeVector: "\u295E",
+  DownLeftVector: "\u21BD",
+  DownLeftVectorBar: "\u2956",
+  DownRightTeeVector: "\u295F",
+  DownRightVector: "\u21C1",
+  DownRightVectorBar: "\u2957",
+  DownTee: "\u22A4",
+  DownTeeArrow: "\u21A7",
+  Downarrow: "\u21D3",
+  Dscr: "\u{1D49F}",
+  Dstrok: "\u0110",
+  ENG: "\u014A",
+  ET: "\xD0",
+  ETH: "\xD0",
+  Eacut: "\xC9",
+  Eacute: "\xC9",
+  Ecaron: "\u011A",
+  Ecir: "\xCA",
+  Ecirc: "\xCA",
+  Ecy: "\u042D",
+  Edot: "\u0116",
+  Efr: "\u{1D508}",
+  Egrav: "\xC8",
+  Egrave: "\xC8",
+  Element: "\u2208",
+  Emacr: "\u0112",
+  EmptySmallSquare: "\u25FB",
+  EmptyVerySmallSquare: "\u25AB",
+  Eogon: "\u0118",
+  Eopf: "\u{1D53C}",
+  Epsilon: "\u0395",
+  Equal: "\u2A75",
+  EqualTilde: "\u2242",
+  Equilibrium: "\u21CC",
+  Escr: "\u2130",
+  Esim: "\u2A73",
+  Eta: "\u0397",
+  Eum: "\xCB",
+  Euml: "\xCB",
+  Exists: "\u2203",
+  ExponentialE: "\u2147",
+  Fcy: "\u0424",
+  Ffr: "\u{1D509}",
+  FilledSmallSquare: "\u25FC",
+  FilledVerySmallSquare: "\u25AA",
+  Fopf: "\u{1D53D}",
+  ForAll: "\u2200",
+  Fouriertrf: "\u2131",
+  Fscr: "\u2131",
+  GJcy: "\u0403",
+  G: ">",
+  GT: ">",
+  Gamma: "\u0393",
+  Gammad: "\u03DC",
+  Gbreve: "\u011E",
+  Gcedil: "\u0122",
+  Gcirc: "\u011C",
+  Gcy: "\u0413",
+  Gdot: "\u0120",
+  Gfr: "\u{1D50A}",
+  Gg: "\u22D9",
+  Gopf: "\u{1D53E}",
+  GreaterEqual: "\u2265",
+  GreaterEqualLess: "\u22DB",
+  GreaterFullEqual: "\u2267",
+  GreaterGreater: "\u2AA2",
+  GreaterLess: "\u2277",
+  GreaterSlantEqual: "\u2A7E",
+  GreaterTilde: "\u2273",
+  Gscr: "\u{1D4A2}",
+  Gt: "\u226B",
+  HARDcy: "\u042A",
+  Hacek: "\u02C7",
+  Hat: "^",
+  Hcirc: "\u0124",
+  Hfr: "\u210C",
+  HilbertSpace: "\u210B",
+  Hopf: "\u210D",
+  HorizontalLine: "\u2500",
+  Hscr: "\u210B",
+  Hstrok: "\u0126",
+  HumpDownHump: "\u224E",
+  HumpEqual: "\u224F",
+  IEcy: "\u0415",
+  IJlig: "\u0132",
+  IOcy: "\u0401",
+  Iacut: "\xCD",
+  Iacute: "\xCD",
+  Icir: "\xCE",
+  Icirc: "\xCE",
+  Icy: "\u0418",
+  Idot: "\u0130",
+  Ifr: "\u2111",
+  Igrav: "\xCC",
+  Igrave: "\xCC",
+  Im: "\u2111",
+  Imacr: "\u012A",
+  ImaginaryI: "\u2148",
+  Implies: "\u21D2",
+  Int: "\u222C",
+  Integral: "\u222B",
+  Intersection: "\u22C2",
+  InvisibleComma: "\u2063",
+  InvisibleTimes: "\u2062",
+  Iogon: "\u012E",
+  Iopf: "\u{1D540}",
+  Iota: "\u0399",
+  Iscr: "\u2110",
+  Itilde: "\u0128",
+  Iukcy: "\u0406",
+  Ium: "\xCF",
+  Iuml: "\xCF",
+  Jcirc: "\u0134",
+  Jcy: "\u0419",
+  Jfr: "\u{1D50D}",
+  Jopf: "\u{1D541}",
+  Jscr: "\u{1D4A5}",
+  Jsercy: "\u0408",
+  Jukcy: "\u0404",
+  KHcy: "\u0425",
+  KJcy: "\u040C",
+  Kappa: "\u039A",
+  Kcedil: "\u0136",
+  Kcy: "\u041A",
+  Kfr: "\u{1D50E}",
+  Kopf: "\u{1D542}",
+  Kscr: "\u{1D4A6}",
+  LJcy: "\u0409",
+  L: "<",
+  LT: "<",
+  Lacute: "\u0139",
+  Lambda: "\u039B",
+  Lang: "\u27EA",
+  Laplacetrf: "\u2112",
+  Larr: "\u219E",
+  Lcaron: "\u013D",
+  Lcedil: "\u013B",
+  Lcy: "\u041B",
+  LeftAngleBracket: "\u27E8",
+  LeftArrow: "\u2190",
+  LeftArrowBar: "\u21E4",
+  LeftArrowRightArrow: "\u21C6",
+  LeftCeiling: "\u2308",
+  LeftDoubleBracket: "\u27E6",
+  LeftDownTeeVector: "\u2961",
+  LeftDownVector: "\u21C3",
+  LeftDownVectorBar: "\u2959",
+  LeftFloor: "\u230A",
+  LeftRightArrow: "\u2194",
+  LeftRightVector: "\u294E",
+  LeftTee: "\u22A3",
+  LeftTeeArrow: "\u21A4",
+  LeftTeeVector: "\u295A",
+  LeftTriangle: "\u22B2",
+  LeftTriangleBar: "\u29CF",
+  LeftTriangleEqual: "\u22B4",
+  LeftUpDownVector: "\u2951",
+  LeftUpTeeVector: "\u2960",
+  LeftUpVector: "\u21BF",
+  LeftUpVectorBar: "\u2958",
+  LeftVector: "\u21BC",
+  LeftVectorBar: "\u2952",
+  Leftarrow: "\u21D0",
+  Leftrightarrow: "\u21D4",
+  LessEqualGreater: "\u22DA",
+  LessFullEqual: "\u2266",
+  LessGreater: "\u2276",
+  LessLess: "\u2AA1",
+  LessSlantEqual: "\u2A7D",
+  LessTilde: "\u2272",
+  Lfr: "\u{1D50F}",
+  Ll: "\u22D8",
+  Lleftarrow: "\u21DA",
+  Lmidot: "\u013F",
+  LongLeftArrow: "\u27F5",
+  LongLeftRightArrow: "\u27F7",
+  LongRightArrow: "\u27F6",
+  Longleftarrow: "\u27F8",
+  Longleftrightarrow: "\u27FA",
+  Longrightarrow: "\u27F9",
+  Lopf: "\u{1D543}",
+  LowerLeftArrow: "\u2199",
+  LowerRightArrow: "\u2198",
+  Lscr: "\u2112",
+  Lsh: "\u21B0",
+  Lstrok: "\u0141",
+  Lt: "\u226A",
+  Map: "\u2905",
+  Mcy: "\u041C",
+  MediumSpace: "\u205F",
+  Mellintrf: "\u2133",
+  Mfr: "\u{1D510}",
+  MinusPlus: "\u2213",
+  Mopf: "\u{1D544}",
+  Mscr: "\u2133",
+  Mu: "\u039C",
+  NJcy: "\u040A",
+  Nacute: "\u0143",
+  Ncaron: "\u0147",
+  Ncedil: "\u0145",
+  Ncy: "\u041D",
+  NegativeMediumSpace: "\u200B",
+  NegativeThickSpace: "\u200B",
+  NegativeThinSpace: "\u200B",
+  NegativeVeryThinSpace: "\u200B",
+  NestedGreaterGreater: "\u226B",
+  NestedLessLess: "\u226A",
+  NewLine: "\n",
+  Nfr: "\u{1D511}",
+  NoBreak: "\u2060",
+  NonBreakingSpace: "\xA0",
+  Nopf: "\u2115",
+  Not: "\u2AEC",
+  NotCongruent: "\u2262",
+  NotCupCap: "\u226D",
+  NotDoubleVerticalBar: "\u2226",
+  NotElement: "\u2209",
+  NotEqual: "\u2260",
+  NotEqualTilde: "\u2242\u0338",
+  NotExists: "\u2204",
+  NotGreater: "\u226F",
+  NotGreaterEqual: "\u2271",
+  NotGreaterFullEqual: "\u2267\u0338",
+  NotGreaterGreater: "\u226B\u0338",
+  NotGreaterLess: "\u2279",
+  NotGreaterSlantEqual: "\u2A7E\u0338",
+  NotGreaterTilde: "\u2275",
+  NotHumpDownHump: "\u224E\u0338",
+  NotHumpEqual: "\u224F\u0338",
+  NotLeftTriangle: "\u22EA",
+  NotLeftTriangleBar: "\u29CF\u0338",
+  NotLeftTriangleEqual: "\u22EC",
+  NotLess: "\u226E",
+  NotLessEqual: "\u2270",
+  NotLessGreater: "\u2278",
+  NotLessLess: "\u226A\u0338",
+  NotLessSlantEqual: "\u2A7D\u0338",
+  NotLessTilde: "\u2274",
+  NotNestedGreaterGreater: "\u2AA2\u0338",
+  NotNestedLessLess: "\u2AA1\u0338",
+  NotPrecedes: "\u2280",
+  NotPrecedesEqual: "\u2AAF\u0338",
+  NotPrecedesSlantEqual: "\u22E0",
+  NotReverseElement: "\u220C",
+  NotRightTriangle: "\u22EB",
+  NotRightTriangleBar: "\u29D0\u0338",
+  NotRightTriangleEqual: "\u22ED",
+  NotSquareSubset: "\u228F\u0338",
+  NotSquareSubsetEqual: "\u22E2",
+  NotSquareSuperset: "\u2290\u0338",
+  NotSquareSupersetEqual: "\u22E3",
+  NotSubset: "\u2282\u20D2",
+  NotSubsetEqual: "\u2288",
+  NotSucceeds: "\u2281",
+  NotSucceedsEqual: "\u2AB0\u0338",
+  NotSucceedsSlantEqual: "\u22E1",
+  NotSucceedsTilde: "\u227F\u0338",
+  NotSuperset: "\u2283\u20D2",
+  NotSupersetEqual: "\u2289",
+  NotTilde: "\u2241",
+  NotTildeEqual: "\u2244",
+  NotTildeFullEqual: "\u2247",
+  NotTildeTilde: "\u2249",
+  NotVerticalBar: "\u2224",
+  Nscr: "\u{1D4A9}",
+  Ntild: "\xD1",
+  Ntilde: "\xD1",
+  Nu: "\u039D",
+  OElig: "\u0152",
+  Oacut: "\xD3",
+  Oacute: "\xD3",
+  Ocir: "\xD4",
+  Ocirc: "\xD4",
+  Ocy: "\u041E",
+  Odblac: "\u0150",
+  Ofr: "\u{1D512}",
+  Ograv: "\xD2",
+  Ograve: "\xD2",
+  Omacr: "\u014C",
+  Omega: "\u03A9",
+  Omicron: "\u039F",
+  Oopf: "\u{1D546}",
+  OpenCurlyDoubleQuote: "\u201C",
+  OpenCurlyQuote: "\u2018",
+  Or: "\u2A54",
+  Oscr: "\u{1D4AA}",
+  Oslas: "\xD8",
+  Oslash: "\xD8",
+  Otild: "\xD5",
+  Otilde: "\xD5",
+  Otimes: "\u2A37",
+  Oum: "\xD6",
+  Ouml: "\xD6",
+  OverBar: "\u203E",
+  OverBrace: "\u23DE",
+  OverBracket: "\u23B4",
+  OverParenthesis: "\u23DC",
+  PartialD: "\u2202",
+  Pcy: "\u041F",
+  Pfr: "\u{1D513}",
+  Phi: "\u03A6",
+  Pi: "\u03A0",
+  PlusMinus: "\xB1",
+  Poincareplane: "\u210C",
+  Popf: "\u2119",
+  Pr: "\u2ABB",
+  Precedes: "\u227A",
+  PrecedesEqual: "\u2AAF",
+  PrecedesSlantEqual: "\u227C",
+  PrecedesTilde: "\u227E",
+  Prime: "\u2033",
+  Product: "\u220F",
+  Proportion: "\u2237",
+  Proportional: "\u221D",
+  Pscr: "\u{1D4AB}",
+  Psi: "\u03A8",
+  QUO: '"',
+  QUOT: '"',
+  Qfr: "\u{1D514}",
+  Qopf: "\u211A",
+  Qscr: "\u{1D4AC}",
+  RBarr: "\u2910",
+  RE: "\xAE",
+  REG: "\xAE",
+  Racute: "\u0154",
+  Rang: "\u27EB",
+  Rarr: "\u21A0",
+  Rarrtl: "\u2916",
+  Rcaron: "\u0158",
+  Rcedil: "\u0156",
+  Rcy: "\u0420",
+  Re: "\u211C",
+  ReverseElement: "\u220B",
+  ReverseEquilibrium: "\u21CB",
+  ReverseUpEquilibrium: "\u296F",
+  Rfr: "\u211C",
+  Rho: "\u03A1",
+  RightAngleBracket: "\u27E9",
+  RightArrow: "\u2192",
+  RightArrowBar: "\u21E5",
+  RightArrowLeftArrow: "\u21C4",
+  RightCeiling: "\u2309",
+  RightDoubleBracket: "\u27E7",
+  RightDownTeeVector: "\u295D",
+  RightDownVector: "\u21C2",
+  RightDownVectorBar: "\u2955",
+  RightFloor: "\u230B",
+  RightTee: "\u22A2",
+  RightTeeArrow: "\u21A6",
+  RightTeeVector: "\u295B",
+  RightTriangle: "\u22B3",
+  RightTriangleBar: "\u29D0",
+  RightTriangleEqual: "\u22B5",
+  RightUpDownVector: "\u294F",
+  RightUpTeeVector: "\u295C",
+  RightUpVector: "\u21BE",
+  RightUpVectorBar: "\u2954",
+  RightVector: "\u21C0",
+  RightVectorBar: "\u2953",
+  Rightarrow: "\u21D2",
+  Ropf: "\u211D",
+  RoundImplies: "\u2970",
+  Rrightarrow: "\u21DB",
+  Rscr: "\u211B",
+  Rsh: "\u21B1",
+  RuleDelayed: "\u29F4",
+  SHCHcy: "\u0429",
+  SHcy: "\u0428",
+  SOFTcy: "\u042C",
+  Sacute: "\u015A",
+  Sc: "\u2ABC",
+  Scaron: "\u0160",
+  Scedil: "\u015E",
+  Scirc: "\u015C",
+  Scy: "\u0421",
+  Sfr: "\u{1D516}",
+  ShortDownArrow: "\u2193",
+  ShortLeftArrow: "\u2190",
+  ShortRightArrow: "\u2192",
+  ShortUpArrow: "\u2191",
+  Sigma: "\u03A3",
+  SmallCircle: "\u2218",
+  Sopf: "\u{1D54A}",
+  Sqrt: "\u221A",
+  Square: "\u25A1",
+  SquareIntersection: "\u2293",
+  SquareSubset: "\u228F",
+  SquareSubsetEqual: "\u2291",
+  SquareSuperset: "\u2290",
+  SquareSupersetEqual: "\u2292",
+  SquareUnion: "\u2294",
+  Sscr: "\u{1D4AE}",
+  Star: "\u22C6",
+  Sub: "\u22D0",
+  Subset: "\u22D0",
+  SubsetEqual: "\u2286",
+  Succeeds: "\u227B",
+  SucceedsEqual: "\u2AB0",
+  SucceedsSlantEqual: "\u227D",
+  SucceedsTilde: "\u227F",
+  SuchThat: "\u220B",
+  Sum: "\u2211",
+  Sup: "\u22D1",
+  Superset: "\u2283",
+  SupersetEqual: "\u2287",
+  Supset: "\u22D1",
+  THOR: "\xDE",
+  THORN: "\xDE",
+  TRADE: "\u2122",
+  TSHcy: "\u040B",
+  TScy: "\u0426",
+  Tab: "	",
+  Tau: "\u03A4",
+  Tcaron: "\u0164",
+  Tcedil: "\u0162",
+  Tcy: "\u0422",
+  Tfr: "\u{1D517}",
+  Therefore: "\u2234",
+  Theta: "\u0398",
+  ThickSpace: "\u205F\u200A",
+  ThinSpace: "\u2009",
+  Tilde: "\u223C",
+  TildeEqual: "\u2243",
+  TildeFullEqual: "\u2245",
+  TildeTilde: "\u2248",
+  Topf: "\u{1D54B}",
+  TripleDot: "\u20DB",
+  Tscr: "\u{1D4AF}",
+  Tstrok: "\u0166",
+  Uacut: "\xDA",
+  Uacute: "\xDA",
+  Uarr: "\u219F",
+  Uarrocir: "\u2949",
+  Ubrcy: "\u040E",
+  Ubreve: "\u016C",
+  Ucir: "\xDB",
+  Ucirc: "\xDB",
+  Ucy: "\u0423",
+  Udblac: "\u0170",
+  Ufr: "\u{1D518}",
+  Ugrav: "\xD9",
+  Ugrave: "\xD9",
+  Umacr: "\u016A",
+  UnderBar: "_",
+  UnderBrace: "\u23DF",
+  UnderBracket: "\u23B5",
+  UnderParenthesis: "\u23DD",
+  Union: "\u22C3",
+  UnionPlus: "\u228E",
+  Uogon: "\u0172",
+  Uopf: "\u{1D54C}",
+  UpArrow: "\u2191",
+  UpArrowBar: "\u2912",
+  UpArrowDownArrow: "\u21C5",
+  UpDownArrow: "\u2195",
+  UpEquilibrium: "\u296E",
+  UpTee: "\u22A5",
+  UpTeeArrow: "\u21A5",
+  Uparrow: "\u21D1",
+  Updownarrow: "\u21D5",
+  UpperLeftArrow: "\u2196",
+  UpperRightArrow: "\u2197",
+  Upsi: "\u03D2",
+  Upsilon: "\u03A5",
+  Uring: "\u016E",
+  Uscr: "\u{1D4B0}",
+  Utilde: "\u0168",
+  Uum: "\xDC",
+  Uuml: "\xDC",
+  VDash: "\u22AB",
+  Vbar: "\u2AEB",
+  Vcy: "\u0412",
+  Vdash: "\u22A9",
+  Vdashl: "\u2AE6",
+  Vee: "\u22C1",
+  Verbar: "\u2016",
+  Vert: "\u2016",
+  VerticalBar: "\u2223",
+  VerticalLine: "|",
+  VerticalSeparator: "\u2758",
+  VerticalTilde: "\u2240",
+  VeryThinSpace: "\u200A",
+  Vfr: "\u{1D519}",
+  Vopf: "\u{1D54D}",
+  Vscr: "\u{1D4B1}",
+  Vvdash: "\u22AA",
+  Wcirc: "\u0174",
+  Wedge: "\u22C0",
+  Wfr: "\u{1D51A}",
+  Wopf: "\u{1D54E}",
+  Wscr: "\u{1D4B2}",
+  Xfr: "\u{1D51B}",
+  Xi: "\u039E",
+  Xopf: "\u{1D54F}",
+  Xscr: "\u{1D4B3}",
+  YAcy: "\u042F",
+  YIcy: "\u0407",
+  YUcy: "\u042E",
+  Yacut: "\xDD",
+  Yacute: "\xDD",
+  Ycirc: "\u0176",
+  Ycy: "\u042B",
+  Yfr: "\u{1D51C}",
+  Yopf: "\u{1D550}",
+  Yscr: "\u{1D4B4}",
+  Yuml: "\u0178",
+  ZHcy: "\u0416",
+  Zacute: "\u0179",
+  Zcaron: "\u017D",
+  Zcy: "\u0417",
+  Zdot: "\u017B",
+  ZeroWidthSpace: "\u200B",
+  Zeta: "\u0396",
+  Zfr: "\u2128",
+  Zopf: "\u2124",
+  Zscr: "\u{1D4B5}",
+  aacut: "\xE1",
+  aacute: "\xE1",
+  abreve: "\u0103",
+  ac: "\u223E",
+  acE: "\u223E\u0333",
+  acd: "\u223F",
+  acir: "\xE2",
+  acirc: "\xE2",
+  acut: "\xB4",
+  acute: "\xB4",
+  acy: "\u0430",
+  aeli: "\xE6",
+  aelig: "\xE6",
+  af: "\u2061",
+  afr: "\u{1D51E}",
+  agrav: "\xE0",
+  agrave: "\xE0",
+  alefsym: "\u2135",
+  aleph: "\u2135",
+  alpha: "\u03B1",
+  amacr: "\u0101",
+  amalg: "\u2A3F",
+  am: "&",
+  amp: "&",
+  and: "\u2227",
+  andand: "\u2A55",
+  andd: "\u2A5C",
+  andslope: "\u2A58",
+  andv: "\u2A5A",
+  ang: "\u2220",
+  ange: "\u29A4",
+  angle: "\u2220",
+  angmsd: "\u2221",
+  angmsdaa: "\u29A8",
+  angmsdab: "\u29A9",
+  angmsdac: "\u29AA",
+  angmsdad: "\u29AB",
+  angmsdae: "\u29AC",
+  angmsdaf: "\u29AD",
+  angmsdag: "\u29AE",
+  angmsdah: "\u29AF",
+  angrt: "\u221F",
+  angrtvb: "\u22BE",
+  angrtvbd: "\u299D",
+  angsph: "\u2222",
+  angst: "\xC5",
+  angzarr: "\u237C",
+  aogon: "\u0105",
+  aopf: "\u{1D552}",
+  ap: "\u2248",
+  apE: "\u2A70",
+  apacir: "\u2A6F",
+  ape: "\u224A",
+  apid: "\u224B",
+  apos: "'",
+  approx: "\u2248",
+  approxeq: "\u224A",
+  arin: "\xE5",
+  aring: "\xE5",
+  ascr: "\u{1D4B6}",
+  ast: "*",
+  asymp: "\u2248",
+  asympeq: "\u224D",
+  atild: "\xE3",
+  atilde: "\xE3",
+  aum: "\xE4",
+  auml: "\xE4",
+  awconint: "\u2233",
+  awint: "\u2A11",
+  bNot: "\u2AED",
+  backcong: "\u224C",
+  backepsilon: "\u03F6",
+  backprime: "\u2035",
+  backsim: "\u223D",
+  backsimeq: "\u22CD",
+  barvee: "\u22BD",
+  barwed: "\u2305",
+  barwedge: "\u2305",
+  bbrk: "\u23B5",
+  bbrktbrk: "\u23B6",
+  bcong: "\u224C",
+  bcy: "\u0431",
+  bdquo: "\u201E",
+  becaus: "\u2235",
+  because: "\u2235",
+  bemptyv: "\u29B0",
+  bepsi: "\u03F6",
+  bernou: "\u212C",
+  beta: "\u03B2",
+  beth: "\u2136",
+  between: "\u226C",
+  bfr: "\u{1D51F}",
+  bigcap: "\u22C2",
+  bigcirc: "\u25EF",
+  bigcup: "\u22C3",
+  bigodot: "\u2A00",
+  bigoplus: "\u2A01",
+  bigotimes: "\u2A02",
+  bigsqcup: "\u2A06",
+  bigstar: "\u2605",
+  bigtriangledown: "\u25BD",
+  bigtriangleup: "\u25B3",
+  biguplus: "\u2A04",
+  bigvee: "\u22C1",
+  bigwedge: "\u22C0",
+  bkarow: "\u290D",
+  blacklozenge: "\u29EB",
+  blacksquare: "\u25AA",
+  blacktriangle: "\u25B4",
+  blacktriangledown: "\u25BE",
+  blacktriangleleft: "\u25C2",
+  blacktriangleright: "\u25B8",
+  blank: "\u2423",
+  blk12: "\u2592",
+  blk14: "\u2591",
+  blk34: "\u2593",
+  block: "\u2588",
+  bne: "=\u20E5",
+  bnequiv: "\u2261\u20E5",
+  bnot: "\u2310",
+  bopf: "\u{1D553}",
+  bot: "\u22A5",
+  bottom: "\u22A5",
+  bowtie: "\u22C8",
+  boxDL: "\u2557",
+  boxDR: "\u2554",
+  boxDl: "\u2556",
+  boxDr: "\u2553",
+  boxH: "\u2550",
+  boxHD: "\u2566",
+  boxHU: "\u2569",
+  boxHd: "\u2564",
+  boxHu: "\u2567",
+  boxUL: "\u255D",
+  boxUR: "\u255A",
+  boxUl: "\u255C",
+  boxUr: "\u2559",
+  boxV: "\u2551",
+  boxVH: "\u256C",
+  boxVL: "\u2563",
+  boxVR: "\u2560",
+  boxVh: "\u256B",
+  boxVl: "\u2562",
+  boxVr: "\u255F",
+  boxbox: "\u29C9",
+  boxdL: "\u2555",
+  boxdR: "\u2552",
+  boxdl: "\u2510",
+  boxdr: "\u250C",
+  boxh: "\u2500",
+  boxhD: "\u2565",
+  boxhU: "\u2568",
+  boxhd: "\u252C",
+  boxhu: "\u2534",
+  boxminus: "\u229F",
+  boxplus: "\u229E",
+  boxtimes: "\u22A0",
+  boxuL: "\u255B",
+  boxuR: "\u2558",
+  boxul: "\u2518",
+  boxur: "\u2514",
+  boxv: "\u2502",
+  boxvH: "\u256A",
+  boxvL: "\u2561",
+  boxvR: "\u255E",
+  boxvh: "\u253C",
+  boxvl: "\u2524",
+  boxvr: "\u251C",
+  bprime: "\u2035",
+  breve: "\u02D8",
+  brvba: "\xA6",
+  brvbar: "\xA6",
+  bscr: "\u{1D4B7}",
+  bsemi: "\u204F",
+  bsim: "\u223D",
+  bsime: "\u22CD",
+  bsol: "\\",
+  bsolb: "\u29C5",
+  bsolhsub: "\u27C8",
+  bull: "\u2022",
+  bullet: "\u2022",
+  bump: "\u224E",
+  bumpE: "\u2AAE",
+  bumpe: "\u224F",
+  bumpeq: "\u224F",
+  cacute: "\u0107",
+  cap: "\u2229",
+  capand: "\u2A44",
+  capbrcup: "\u2A49",
+  capcap: "\u2A4B",
+  capcup: "\u2A47",
+  capdot: "\u2A40",
+  caps: "\u2229\uFE00",
+  caret: "\u2041",
+  caron: "\u02C7",
+  ccaps: "\u2A4D",
+  ccaron: "\u010D",
+  ccedi: "\xE7",
+  ccedil: "\xE7",
+  ccirc: "\u0109",
+  ccups: "\u2A4C",
+  ccupssm: "\u2A50",
+  cdot: "\u010B",
+  cedi: "\xB8",
+  cedil: "\xB8",
+  cemptyv: "\u29B2",
+  cen: "\xA2",
+  cent: "\xA2",
+  centerdot: "\xB7",
+  cfr: "\u{1D520}",
+  chcy: "\u0447",
+  check: "\u2713",
+  checkmark: "\u2713",
+  chi: "\u03C7",
+  cir: "\u25CB",
+  cirE: "\u29C3",
+  circ: "\u02C6",
+  circeq: "\u2257",
+  circlearrowleft: "\u21BA",
+  circlearrowright: "\u21BB",
+  circledR: "\xAE",
+  circledS: "\u24C8",
+  circledast: "\u229B",
+  circledcirc: "\u229A",
+  circleddash: "\u229D",
+  cire: "\u2257",
+  cirfnint: "\u2A10",
+  cirmid: "\u2AEF",
+  cirscir: "\u29C2",
+  clubs: "\u2663",
+  clubsuit: "\u2663",
+  colon: ":",
+  colone: "\u2254",
+  coloneq: "\u2254",
+  comma: ",",
+  commat: "@",
+  comp: "\u2201",
+  compfn: "\u2218",
+  complement: "\u2201",
+  complexes: "\u2102",
+  cong: "\u2245",
+  congdot: "\u2A6D",
+  conint: "\u222E",
+  copf: "\u{1D554}",
+  coprod: "\u2210",
+  cop: "\xA9",
+  copy: "\xA9",
+  copysr: "\u2117",
+  crarr: "\u21B5",
+  cross: "\u2717",
+  cscr: "\u{1D4B8}",
+  csub: "\u2ACF",
+  csube: "\u2AD1",
+  csup: "\u2AD0",
+  csupe: "\u2AD2",
+  ctdot: "\u22EF",
+  cudarrl: "\u2938",
+  cudarrr: "\u2935",
+  cuepr: "\u22DE",
+  cuesc: "\u22DF",
+  cularr: "\u21B6",
+  cularrp: "\u293D",
+  cup: "\u222A",
+  cupbrcap: "\u2A48",
+  cupcap: "\u2A46",
+  cupcup: "\u2A4A",
+  cupdot: "\u228D",
+  cupor: "\u2A45",
+  cups: "\u222A\uFE00",
+  curarr: "\u21B7",
+  curarrm: "\u293C",
+  curlyeqprec: "\u22DE",
+  curlyeqsucc: "\u22DF",
+  curlyvee: "\u22CE",
+  curlywedge: "\u22CF",
+  curre: "\xA4",
+  curren: "\xA4",
+  curvearrowleft: "\u21B6",
+  curvearrowright: "\u21B7",
+  cuvee: "\u22CE",
+  cuwed: "\u22CF",
+  cwconint: "\u2232",
+  cwint: "\u2231",
+  cylcty: "\u232D",
+  dArr: "\u21D3",
+  dHar: "\u2965",
+  dagger: "\u2020",
+  daleth: "\u2138",
+  darr: "\u2193",
+  dash: "\u2010",
+  dashv: "\u22A3",
+  dbkarow: "\u290F",
+  dblac: "\u02DD",
+  dcaron: "\u010F",
+  dcy: "\u0434",
+  dd: "\u2146",
+  ddagger: "\u2021",
+  ddarr: "\u21CA",
+  ddotseq: "\u2A77",
+  de: "\xB0",
+  deg: "\xB0",
+  delta: "\u03B4",
+  demptyv: "\u29B1",
+  dfisht: "\u297F",
+  dfr: "\u{1D521}",
+  dharl: "\u21C3",
+  dharr: "\u21C2",
+  diam: "\u22C4",
+  diamond: "\u22C4",
+  diamondsuit: "\u2666",
+  diams: "\u2666",
+  die: "\xA8",
+  digamma: "\u03DD",
+  disin: "\u22F2",
+  div: "\xF7",
+  divid: "\xF7",
+  divide: "\xF7",
+  divideontimes: "\u22C7",
+  divonx: "\u22C7",
+  djcy: "\u0452",
+  dlcorn: "\u231E",
+  dlcrop: "\u230D",
+  dollar: "$",
+  dopf: "\u{1D555}",
+  dot: "\u02D9",
+  doteq: "\u2250",
+  doteqdot: "\u2251",
+  dotminus: "\u2238",
+  dotplus: "\u2214",
+  dotsquare: "\u22A1",
+  doublebarwedge: "\u2306",
+  downarrow: "\u2193",
+  downdownarrows: "\u21CA",
+  downharpoonleft: "\u21C3",
+  downharpoonright: "\u21C2",
+  drbkarow: "\u2910",
+  drcorn: "\u231F",
+  drcrop: "\u230C",
+  dscr: "\u{1D4B9}",
+  dscy: "\u0455",
+  dsol: "\u29F6",
+  dstrok: "\u0111",
+  dtdot: "\u22F1",
+  dtri: "\u25BF",
+  dtrif: "\u25BE",
+  duarr: "\u21F5",
+  duhar: "\u296F",
+  dwangle: "\u29A6",
+  dzcy: "\u045F",
+  dzigrarr: "\u27FF",
+  eDDot: "\u2A77",
+  eDot: "\u2251",
+  eacut: "\xE9",
+  eacute: "\xE9",
+  easter: "\u2A6E",
+  ecaron: "\u011B",
+  ecir: "\xEA",
+  ecirc: "\xEA",
+  ecolon: "\u2255",
+  ecy: "\u044D",
+  edot: "\u0117",
+  ee: "\u2147",
+  efDot: "\u2252",
+  efr: "\u{1D522}",
+  eg: "\u2A9A",
+  egrav: "\xE8",
+  egrave: "\xE8",
+  egs: "\u2A96",
+  egsdot: "\u2A98",
+  el: "\u2A99",
+  elinters: "\u23E7",
+  ell: "\u2113",
+  els: "\u2A95",
+  elsdot: "\u2A97",
+  emacr: "\u0113",
+  empty: "\u2205",
+  emptyset: "\u2205",
+  emptyv: "\u2205",
+  emsp13: "\u2004",
+  emsp14: "\u2005",
+  emsp: "\u2003",
+  eng: "\u014B",
+  ensp: "\u2002",
+  eogon: "\u0119",
+  eopf: "\u{1D556}",
+  epar: "\u22D5",
+  eparsl: "\u29E3",
+  eplus: "\u2A71",
+  epsi: "\u03B5",
+  epsilon: "\u03B5",
+  epsiv: "\u03F5",
+  eqcirc: "\u2256",
+  eqcolon: "\u2255",
+  eqsim: "\u2242",
+  eqslantgtr: "\u2A96",
+  eqslantless: "\u2A95",
+  equals: "=",
+  equest: "\u225F",
+  equiv: "\u2261",
+  equivDD: "\u2A78",
+  eqvparsl: "\u29E5",
+  erDot: "\u2253",
+  erarr: "\u2971",
+  escr: "\u212F",
+  esdot: "\u2250",
+  esim: "\u2242",
+  eta: "\u03B7",
+  et: "\xF0",
+  eth: "\xF0",
+  eum: "\xEB",
+  euml: "\xEB",
+  euro: "\u20AC",
+  excl: "!",
+  exist: "\u2203",
+  expectation: "\u2130",
+  exponentiale: "\u2147",
+  fallingdotseq: "\u2252",
+  fcy: "\u0444",
+  female: "\u2640",
+  ffilig: "\uFB03",
+  fflig: "\uFB00",
+  ffllig: "\uFB04",
+  ffr: "\u{1D523}",
+  filig: "\uFB01",
+  fjlig: "fj",
+  flat: "\u266D",
+  fllig: "\uFB02",
+  fltns: "\u25B1",
+  fnof: "\u0192",
+  fopf: "\u{1D557}",
+  forall: "\u2200",
+  fork: "\u22D4",
+  forkv: "\u2AD9",
+  fpartint: "\u2A0D",
+  frac1: "\xBC",
+  frac12: "\xBD",
+  frac13: "\u2153",
+  frac14: "\xBC",
+  frac15: "\u2155",
+  frac16: "\u2159",
+  frac18: "\u215B",
+  frac23: "\u2154",
+  frac25: "\u2156",
+  frac3: "\xBE",
+  frac34: "\xBE",
+  frac35: "\u2157",
+  frac38: "\u215C",
+  frac45: "\u2158",
+  frac56: "\u215A",
+  frac58: "\u215D",
+  frac78: "\u215E",
+  frasl: "\u2044",
+  frown: "\u2322",
+  fscr: "\u{1D4BB}",
+  gE: "\u2267",
+  gEl: "\u2A8C",
+  gacute: "\u01F5",
+  gamma: "\u03B3",
+  gammad: "\u03DD",
+  gap: "\u2A86",
+  gbreve: "\u011F",
+  gcirc: "\u011D",
+  gcy: "\u0433",
+  gdot: "\u0121",
+  ge: "\u2265",
+  gel: "\u22DB",
+  geq: "\u2265",
+  geqq: "\u2267",
+  geqslant: "\u2A7E",
+  ges: "\u2A7E",
+  gescc: "\u2AA9",
+  gesdot: "\u2A80",
+  gesdoto: "\u2A82",
+  gesdotol: "\u2A84",
+  gesl: "\u22DB\uFE00",
+  gesles: "\u2A94",
+  gfr: "\u{1D524}",
+  gg: "\u226B",
+  ggg: "\u22D9",
+  gimel: "\u2137",
+  gjcy: "\u0453",
+  gl: "\u2277",
+  glE: "\u2A92",
+  gla: "\u2AA5",
+  glj: "\u2AA4",
+  gnE: "\u2269",
+  gnap: "\u2A8A",
+  gnapprox: "\u2A8A",
+  gne: "\u2A88",
+  gneq: "\u2A88",
+  gneqq: "\u2269",
+  gnsim: "\u22E7",
+  gopf: "\u{1D558}",
+  grave: "`",
+  gscr: "\u210A",
+  gsim: "\u2273",
+  gsime: "\u2A8E",
+  gsiml: "\u2A90",
+  g: ">",
+  gt: ">",
+  gtcc: "\u2AA7",
+  gtcir: "\u2A7A",
+  gtdot: "\u22D7",
+  gtlPar: "\u2995",
+  gtquest: "\u2A7C",
+  gtrapprox: "\u2A86",
+  gtrarr: "\u2978",
+  gtrdot: "\u22D7",
+  gtreqless: "\u22DB",
+  gtreqqless: "\u2A8C",
+  gtrless: "\u2277",
+  gtrsim: "\u2273",
+  gvertneqq: "\u2269\uFE00",
+  gvnE: "\u2269\uFE00",
+  hArr: "\u21D4",
+  hairsp: "\u200A",
+  half: "\xBD",
+  hamilt: "\u210B",
+  hardcy: "\u044A",
+  harr: "\u2194",
+  harrcir: "\u2948",
+  harrw: "\u21AD",
+  hbar: "\u210F",
+  hcirc: "\u0125",
+  hearts: "\u2665",
+  heartsuit: "\u2665",
+  hellip: "\u2026",
+  hercon: "\u22B9",
+  hfr: "\u{1D525}",
+  hksearow: "\u2925",
+  hkswarow: "\u2926",
+  hoarr: "\u21FF",
+  homtht: "\u223B",
+  hookleftarrow: "\u21A9",
+  hookrightarrow: "\u21AA",
+  hopf: "\u{1D559}",
+  horbar: "\u2015",
+  hscr: "\u{1D4BD}",
+  hslash: "\u210F",
+  hstrok: "\u0127",
+  hybull: "\u2043",
+  hyphen: "\u2010",
+  iacut: "\xED",
+  iacute: "\xED",
+  ic: "\u2063",
+  icir: "\xEE",
+  icirc: "\xEE",
+  icy: "\u0438",
+  iecy: "\u0435",
+  iexc: "\xA1",
+  iexcl: "\xA1",
+  iff: "\u21D4",
+  ifr: "\u{1D526}",
+  igrav: "\xEC",
+  igrave: "\xEC",
+  ii: "\u2148",
+  iiiint: "\u2A0C",
+  iiint: "\u222D",
+  iinfin: "\u29DC",
+  iiota: "\u2129",
+  ijlig: "\u0133",
+  imacr: "\u012B",
+  image: "\u2111",
+  imagline: "\u2110",
+  imagpart: "\u2111",
+  imath: "\u0131",
+  imof: "\u22B7",
+  imped: "\u01B5",
+  in: "\u2208",
+  incare: "\u2105",
+  infin: "\u221E",
+  infintie: "\u29DD",
+  inodot: "\u0131",
+  int: "\u222B",
+  intcal: "\u22BA",
+  integers: "\u2124",
+  intercal: "\u22BA",
+  intlarhk: "\u2A17",
+  intprod: "\u2A3C",
+  iocy: "\u0451",
+  iogon: "\u012F",
+  iopf: "\u{1D55A}",
+  iota: "\u03B9",
+  iprod: "\u2A3C",
+  iques: "\xBF",
+  iquest: "\xBF",
+  iscr: "\u{1D4BE}",
+  isin: "\u2208",
+  isinE: "\u22F9",
+  isindot: "\u22F5",
+  isins: "\u22F4",
+  isinsv: "\u22F3",
+  isinv: "\u2208",
+  it: "\u2062",
+  itilde: "\u0129",
+  iukcy: "\u0456",
+  ium: "\xEF",
+  iuml: "\xEF",
+  jcirc: "\u0135",
+  jcy: "\u0439",
+  jfr: "\u{1D527}",
+  jmath: "\u0237",
+  jopf: "\u{1D55B}",
+  jscr: "\u{1D4BF}",
+  jsercy: "\u0458",
+  jukcy: "\u0454",
+  kappa: "\u03BA",
+  kappav: "\u03F0",
+  kcedil: "\u0137",
+  kcy: "\u043A",
+  kfr: "\u{1D528}",
+  kgreen: "\u0138",
+  khcy: "\u0445",
+  kjcy: "\u045C",
+  kopf: "\u{1D55C}",
+  kscr: "\u{1D4C0}",
+  lAarr: "\u21DA",
+  lArr: "\u21D0",
+  lAtail: "\u291B",
+  lBarr: "\u290E",
+  lE: "\u2266",
+  lEg: "\u2A8B",
+  lHar: "\u2962",
+  lacute: "\u013A",
+  laemptyv: "\u29B4",
+  lagran: "\u2112",
+  lambda: "\u03BB",
+  lang: "\u27E8",
+  langd: "\u2991",
+  langle: "\u27E8",
+  lap: "\u2A85",
+  laqu: "\xAB",
+  laquo: "\xAB",
+  larr: "\u2190",
+  larrb: "\u21E4",
+  larrbfs: "\u291F",
+  larrfs: "\u291D",
+  larrhk: "\u21A9",
+  larrlp: "\u21AB",
+  larrpl: "\u2939",
+  larrsim: "\u2973",
+  larrtl: "\u21A2",
+  lat: "\u2AAB",
+  latail: "\u2919",
+  late: "\u2AAD",
+  lates: "\u2AAD\uFE00",
+  lbarr: "\u290C",
+  lbbrk: "\u2772",
+  lbrace: "{",
+  lbrack: "[",
+  lbrke: "\u298B",
+  lbrksld: "\u298F",
+  lbrkslu: "\u298D",
+  lcaron: "\u013E",
+  lcedil: "\u013C",
+  lceil: "\u2308",
+  lcub: "{",
+  lcy: "\u043B",
+  ldca: "\u2936",
+  ldquo: "\u201C",
+  ldquor: "\u201E",
+  ldrdhar: "\u2967",
+  ldrushar: "\u294B",
+  ldsh: "\u21B2",
+  le: "\u2264",
+  leftarrow: "\u2190",
+  leftarrowtail: "\u21A2",
+  leftharpoondown: "\u21BD",
+  leftharpoonup: "\u21BC",
+  leftleftarrows: "\u21C7",
+  leftrightarrow: "\u2194",
+  leftrightarrows: "\u21C6",
+  leftrightharpoons: "\u21CB",
+  leftrightsquigarrow: "\u21AD",
+  leftthreetimes: "\u22CB",
+  leg: "\u22DA",
+  leq: "\u2264",
+  leqq: "\u2266",
+  leqslant: "\u2A7D",
+  les: "\u2A7D",
+  lescc: "\u2AA8",
+  lesdot: "\u2A7F",
+  lesdoto: "\u2A81",
+  lesdotor: "\u2A83",
+  lesg: "\u22DA\uFE00",
+  lesges: "\u2A93",
+  lessapprox: "\u2A85",
+  lessdot: "\u22D6",
+  lesseqgtr: "\u22DA",
+  lesseqqgtr: "\u2A8B",
+  lessgtr: "\u2276",
+  lesssim: "\u2272",
+  lfisht: "\u297C",
+  lfloor: "\u230A",
+  lfr: "\u{1D529}",
+  lg: "\u2276",
+  lgE: "\u2A91",
+  lhard: "\u21BD",
+  lharu: "\u21BC",
+  lharul: "\u296A",
+  lhblk: "\u2584",
+  ljcy: "\u0459",
+  ll: "\u226A",
+  llarr: "\u21C7",
+  llcorner: "\u231E",
+  llhard: "\u296B",
+  lltri: "\u25FA",
+  lmidot: "\u0140",
+  lmoust: "\u23B0",
+  lmoustache: "\u23B0",
+  lnE: "\u2268",
+  lnap: "\u2A89",
+  lnapprox: "\u2A89",
+  lne: "\u2A87",
+  lneq: "\u2A87",
+  lneqq: "\u2268",
+  lnsim: "\u22E6",
+  loang: "\u27EC",
+  loarr: "\u21FD",
+  lobrk: "\u27E6",
+  longleftarrow: "\u27F5",
+  longleftrightarrow: "\u27F7",
+  longmapsto: "\u27FC",
+  longrightarrow: "\u27F6",
+  looparrowleft: "\u21AB",
+  looparrowright: "\u21AC",
+  lopar: "\u2985",
+  lopf: "\u{1D55D}",
+  loplus: "\u2A2D",
+  lotimes: "\u2A34",
+  lowast: "\u2217",
+  lowbar: "_",
+  loz: "\u25CA",
+  lozenge: "\u25CA",
+  lozf: "\u29EB",
+  lpar: "(",
+  lparlt: "\u2993",
+  lrarr: "\u21C6",
+  lrcorner: "\u231F",
+  lrhar: "\u21CB",
+  lrhard: "\u296D",
+  lrm: "\u200E",
+  lrtri: "\u22BF",
+  lsaquo: "\u2039",
+  lscr: "\u{1D4C1}",
+  lsh: "\u21B0",
+  lsim: "\u2272",
+  lsime: "\u2A8D",
+  lsimg: "\u2A8F",
+  lsqb: "[",
+  lsquo: "\u2018",
+  lsquor: "\u201A",
+  lstrok: "\u0142",
+  l: "<",
+  lt: "<",
+  ltcc: "\u2AA6",
+  ltcir: "\u2A79",
+  ltdot: "\u22D6",
+  lthree: "\u22CB",
+  ltimes: "\u22C9",
+  ltlarr: "\u2976",
+  ltquest: "\u2A7B",
+  ltrPar: "\u2996",
+  ltri: "\u25C3",
+  ltrie: "\u22B4",
+  ltrif: "\u25C2",
+  lurdshar: "\u294A",
+  luruhar: "\u2966",
+  lvertneqq: "\u2268\uFE00",
+  lvnE: "\u2268\uFE00",
+  mDDot: "\u223A",
+  mac: "\xAF",
+  macr: "\xAF",
+  male: "\u2642",
+  malt: "\u2720",
+  maltese: "\u2720",
+  map: "\u21A6",
+  mapsto: "\u21A6",
+  mapstodown: "\u21A7",
+  mapstoleft: "\u21A4",
+  mapstoup: "\u21A5",
+  marker: "\u25AE",
+  mcomma: "\u2A29",
+  mcy: "\u043C",
+  mdash: "\u2014",
+  measuredangle: "\u2221",
+  mfr: "\u{1D52A}",
+  mho: "\u2127",
+  micr: "\xB5",
+  micro: "\xB5",
+  mid: "\u2223",
+  midast: "*",
+  midcir: "\u2AF0",
+  middo: "\xB7",
+  middot: "\xB7",
+  minus: "\u2212",
+  minusb: "\u229F",
+  minusd: "\u2238",
+  minusdu: "\u2A2A",
+  mlcp: "\u2ADB",
+  mldr: "\u2026",
+  mnplus: "\u2213",
+  models: "\u22A7",
+  mopf: "\u{1D55E}",
+  mp: "\u2213",
+  mscr: "\u{1D4C2}",
+  mstpos: "\u223E",
+  mu: "\u03BC",
+  multimap: "\u22B8",
+  mumap: "\u22B8",
+  nGg: "\u22D9\u0338",
+  nGt: "\u226B\u20D2",
+  nGtv: "\u226B\u0338",
+  nLeftarrow: "\u21CD",
+  nLeftrightarrow: "\u21CE",
+  nLl: "\u22D8\u0338",
+  nLt: "\u226A\u20D2",
+  nLtv: "\u226A\u0338",
+  nRightarrow: "\u21CF",
+  nVDash: "\u22AF",
+  nVdash: "\u22AE",
+  nabla: "\u2207",
+  nacute: "\u0144",
+  nang: "\u2220\u20D2",
+  nap: "\u2249",
+  napE: "\u2A70\u0338",
+  napid: "\u224B\u0338",
+  napos: "\u0149",
+  napprox: "\u2249",
+  natur: "\u266E",
+  natural: "\u266E",
+  naturals: "\u2115",
+  nbs: "\xA0",
+  nbsp: "\xA0",
+  nbump: "\u224E\u0338",
+  nbumpe: "\u224F\u0338",
+  ncap: "\u2A43",
+  ncaron: "\u0148",
+  ncedil: "\u0146",
+  ncong: "\u2247",
+  ncongdot: "\u2A6D\u0338",
+  ncup: "\u2A42",
+  ncy: "\u043D",
+  ndash: "\u2013",
+  ne: "\u2260",
+  neArr: "\u21D7",
+  nearhk: "\u2924",
+  nearr: "\u2197",
+  nearrow: "\u2197",
+  nedot: "\u2250\u0338",
+  nequiv: "\u2262",
+  nesear: "\u2928",
+  nesim: "\u2242\u0338",
+  nexist: "\u2204",
+  nexists: "\u2204",
+  nfr: "\u{1D52B}",
+  ngE: "\u2267\u0338",
+  nge: "\u2271",
+  ngeq: "\u2271",
+  ngeqq: "\u2267\u0338",
+  ngeqslant: "\u2A7E\u0338",
+  nges: "\u2A7E\u0338",
+  ngsim: "\u2275",
+  ngt: "\u226F",
+  ngtr: "\u226F",
+  nhArr: "\u21CE",
+  nharr: "\u21AE",
+  nhpar: "\u2AF2",
+  ni: "\u220B",
+  nis: "\u22FC",
+  nisd: "\u22FA",
+  niv: "\u220B",
+  njcy: "\u045A",
+  nlArr: "\u21CD",
+  nlE: "\u2266\u0338",
+  nlarr: "\u219A",
+  nldr: "\u2025",
+  nle: "\u2270",
+  nleftarrow: "\u219A",
+  nleftrightarrow: "\u21AE",
+  nleq: "\u2270",
+  nleqq: "\u2266\u0338",
+  nleqslant: "\u2A7D\u0338",
+  nles: "\u2A7D\u0338",
+  nless: "\u226E",
+  nlsim: "\u2274",
+  nlt: "\u226E",
+  nltri: "\u22EA",
+  nltrie: "\u22EC",
+  nmid: "\u2224",
+  nopf: "\u{1D55F}",
+  no: "\xAC",
+  not: "\xAC",
+  notin: "\u2209",
+  notinE: "\u22F9\u0338",
+  notindot: "\u22F5\u0338",
+  notinva: "\u2209",
+  notinvb: "\u22F7",
+  notinvc: "\u22F6",
+  notni: "\u220C",
+  notniva: "\u220C",
+  notnivb: "\u22FE",
+  notnivc: "\u22FD",
+  npar: "\u2226",
+  nparallel: "\u2226",
+  nparsl: "\u2AFD\u20E5",
+  npart: "\u2202\u0338",
+  npolint: "\u2A14",
+  npr: "\u2280",
+  nprcue: "\u22E0",
+  npre: "\u2AAF\u0338",
+  nprec: "\u2280",
+  npreceq: "\u2AAF\u0338",
+  nrArr: "\u21CF",
+  nrarr: "\u219B",
+  nrarrc: "\u2933\u0338",
+  nrarrw: "\u219D\u0338",
+  nrightarrow: "\u219B",
+  nrtri: "\u22EB",
+  nrtrie: "\u22ED",
+  nsc: "\u2281",
+  nsccue: "\u22E1",
+  nsce: "\u2AB0\u0338",
+  nscr: "\u{1D4C3}",
+  nshortmid: "\u2224",
+  nshortparallel: "\u2226",
+  nsim: "\u2241",
+  nsime: "\u2244",
+  nsimeq: "\u2244",
+  nsmid: "\u2224",
+  nspar: "\u2226",
+  nsqsube: "\u22E2",
+  nsqsupe: "\u22E3",
+  nsub: "\u2284",
+  nsubE: "\u2AC5\u0338",
+  nsube: "\u2288",
+  nsubset: "\u2282\u20D2",
+  nsubseteq: "\u2288",
+  nsubseteqq: "\u2AC5\u0338",
+  nsucc: "\u2281",
+  nsucceq: "\u2AB0\u0338",
+  nsup: "\u2285",
+  nsupE: "\u2AC6\u0338",
+  nsupe: "\u2289",
+  nsupset: "\u2283\u20D2",
+  nsupseteq: "\u2289",
+  nsupseteqq: "\u2AC6\u0338",
+  ntgl: "\u2279",
+  ntild: "\xF1",
+  ntilde: "\xF1",
+  ntlg: "\u2278",
+  ntriangleleft: "\u22EA",
+  ntrianglelefteq: "\u22EC",
+  ntriangleright: "\u22EB",
+  ntrianglerighteq: "\u22ED",
+  nu: "\u03BD",
+  num: "#",
+  numero: "\u2116",
+  numsp: "\u2007",
+  nvDash: "\u22AD",
+  nvHarr: "\u2904",
+  nvap: "\u224D\u20D2",
+  nvdash: "\u22AC",
+  nvge: "\u2265\u20D2",
+  nvgt: ">\u20D2",
+  nvinfin: "\u29DE",
+  nvlArr: "\u2902",
+  nvle: "\u2264\u20D2",
+  nvlt: "<\u20D2",
+  nvltrie: "\u22B4\u20D2",
+  nvrArr: "\u2903",
+  nvrtrie: "\u22B5\u20D2",
+  nvsim: "\u223C\u20D2",
+  nwArr: "\u21D6",
+  nwarhk: "\u2923",
+  nwarr: "\u2196",
+  nwarrow: "\u2196",
+  nwnear: "\u2927",
+  oS: "\u24C8",
+  oacut: "\xF3",
+  oacute: "\xF3",
+  oast: "\u229B",
+  ocir: "\xF4",
+  ocirc: "\xF4",
+  ocy: "\u043E",
+  odash: "\u229D",
+  odblac: "\u0151",
+  odiv: "\u2A38",
+  odot: "\u2299",
+  odsold: "\u29BC",
+  oelig: "\u0153",
+  ofcir: "\u29BF",
+  ofr: "\u{1D52C}",
+  ogon: "\u02DB",
+  ograv: "\xF2",
+  ograve: "\xF2",
+  ogt: "\u29C1",
+  ohbar: "\u29B5",
+  ohm: "\u03A9",
+  oint: "\u222E",
+  olarr: "\u21BA",
+  olcir: "\u29BE",
+  olcross: "\u29BB",
+  oline: "\u203E",
+  olt: "\u29C0",
+  omacr: "\u014D",
+  omega: "\u03C9",
+  omicron: "\u03BF",
+  omid: "\u29B6",
+  ominus: "\u2296",
+  oopf: "\u{1D560}",
+  opar: "\u29B7",
+  operp: "\u29B9",
+  oplus: "\u2295",
+  or: "\u2228",
+  orarr: "\u21BB",
+  ord: "\xBA",
+  order: "\u2134",
+  orderof: "\u2134",
+  ordf: "\xAA",
+  ordm: "\xBA",
+  origof: "\u22B6",
+  oror: "\u2A56",
+  orslope: "\u2A57",
+  orv: "\u2A5B",
+  oscr: "\u2134",
+  oslas: "\xF8",
+  oslash: "\xF8",
+  osol: "\u2298",
+  otild: "\xF5",
+  otilde: "\xF5",
+  otimes: "\u2297",
+  otimesas: "\u2A36",
+  oum: "\xF6",
+  ouml: "\xF6",
+  ovbar: "\u233D",
+  par: "\xB6",
+  para: "\xB6",
+  parallel: "\u2225",
+  parsim: "\u2AF3",
+  parsl: "\u2AFD",
+  part: "\u2202",
+  pcy: "\u043F",
+  percnt: "%",
+  period: ".",
+  permil: "\u2030",
+  perp: "\u22A5",
+  pertenk: "\u2031",
+  pfr: "\u{1D52D}",
+  phi: "\u03C6",
+  phiv: "\u03D5",
+  phmmat: "\u2133",
+  phone: "\u260E",
+  pi: "\u03C0",
+  pitchfork: "\u22D4",
+  piv: "\u03D6",
+  planck: "\u210F",
+  planckh: "\u210E",
+  plankv: "\u210F",
+  plus: "+",
+  plusacir: "\u2A23",
+  plusb: "\u229E",
+  pluscir: "\u2A22",
+  plusdo: "\u2214",
+  plusdu: "\u2A25",
+  pluse: "\u2A72",
+  plusm: "\xB1",
+  plusmn: "\xB1",
+  plussim: "\u2A26",
+  plustwo: "\u2A27",
+  pm: "\xB1",
+  pointint: "\u2A15",
+  popf: "\u{1D561}",
+  poun: "\xA3",
+  pound: "\xA3",
+  pr: "\u227A",
+  prE: "\u2AB3",
+  prap: "\u2AB7",
+  prcue: "\u227C",
+  pre: "\u2AAF",
+  prec: "\u227A",
+  precapprox: "\u2AB7",
+  preccurlyeq: "\u227C",
+  preceq: "\u2AAF",
+  precnapprox: "\u2AB9",
+  precneqq: "\u2AB5",
+  precnsim: "\u22E8",
+  precsim: "\u227E",
+  prime: "\u2032",
+  primes: "\u2119",
+  prnE: "\u2AB5",
+  prnap: "\u2AB9",
+  prnsim: "\u22E8",
+  prod: "\u220F",
+  profalar: "\u232E",
+  profline: "\u2312",
+  profsurf: "\u2313",
+  prop: "\u221D",
+  propto: "\u221D",
+  prsim: "\u227E",
+  prurel: "\u22B0",
+  pscr: "\u{1D4C5}",
+  psi: "\u03C8",
+  puncsp: "\u2008",
+  qfr: "\u{1D52E}",
+  qint: "\u2A0C",
+  qopf: "\u{1D562}",
+  qprime: "\u2057",
+  qscr: "\u{1D4C6}",
+  quaternions: "\u210D",
+  quatint: "\u2A16",
+  quest: "?",
+  questeq: "\u225F",
+  quo: '"',
+  quot: '"',
+  rAarr: "\u21DB",
+  rArr: "\u21D2",
+  rAtail: "\u291C",
+  rBarr: "\u290F",
+  rHar: "\u2964",
+  race: "\u223D\u0331",
+  racute: "\u0155",
+  radic: "\u221A",
+  raemptyv: "\u29B3",
+  rang: "\u27E9",
+  rangd: "\u2992",
+  range: "\u29A5",
+  rangle: "\u27E9",
+  raqu: "\xBB",
+  raquo: "\xBB",
+  rarr: "\u2192",
+  rarrap: "\u2975",
+  rarrb: "\u21E5",
+  rarrbfs: "\u2920",
+  rarrc: "\u2933",
+  rarrfs: "\u291E",
+  rarrhk: "\u21AA",
+  rarrlp: "\u21AC",
+  rarrpl: "\u2945",
+  rarrsim: "\u2974",
+  rarrtl: "\u21A3",
+  rarrw: "\u219D",
+  ratail: "\u291A",
+  ratio: "\u2236",
+  rationals: "\u211A",
+  rbarr: "\u290D",
+  rbbrk: "\u2773",
+  rbrace: "}",
+  rbrack: "]",
+  rbrke: "\u298C",
+  rbrksld: "\u298E",
+  rbrkslu: "\u2990",
+  rcaron: "\u0159",
+  rcedil: "\u0157",
+  rceil: "\u2309",
+  rcub: "}",
+  rcy: "\u0440",
+  rdca: "\u2937",
+  rdldhar: "\u2969",
+  rdquo: "\u201D",
+  rdquor: "\u201D",
+  rdsh: "\u21B3",
+  real: "\u211C",
+  realine: "\u211B",
+  realpart: "\u211C",
+  reals: "\u211D",
+  rect: "\u25AD",
+  re: "\xAE",
+  reg: "\xAE",
+  rfisht: "\u297D",
+  rfloor: "\u230B",
+  rfr: "\u{1D52F}",
+  rhard: "\u21C1",
+  rharu: "\u21C0",
+  rharul: "\u296C",
+  rho: "\u03C1",
+  rhov: "\u03F1",
+  rightarrow: "\u2192",
+  rightarrowtail: "\u21A3",
+  rightharpoondown: "\u21C1",
+  rightharpoonup: "\u21C0",
+  rightleftarrows: "\u21C4",
+  rightleftharpoons: "\u21CC",
+  rightrightarrows: "\u21C9",
+  rightsquigarrow: "\u219D",
+  rightthreetimes: "\u22CC",
+  ring: "\u02DA",
+  risingdotseq: "\u2253",
+  rlarr: "\u21C4",
+  rlhar: "\u21CC",
+  rlm: "\u200F",
+  rmoust: "\u23B1",
+  rmoustache: "\u23B1",
+  rnmid: "\u2AEE",
+  roang: "\u27ED",
+  roarr: "\u21FE",
+  robrk: "\u27E7",
+  ropar: "\u2986",
+  ropf: "\u{1D563}",
+  roplus: "\u2A2E",
+  rotimes: "\u2A35",
+  rpar: ")",
+  rpargt: "\u2994",
+  rppolint: "\u2A12",
+  rrarr: "\u21C9",
+  rsaquo: "\u203A",
+  rscr: "\u{1D4C7}",
+  rsh: "\u21B1",
+  rsqb: "]",
+  rsquo: "\u2019",
+  rsquor: "\u2019",
+  rthree: "\u22CC",
+  rtimes: "\u22CA",
+  rtri: "\u25B9",
+  rtrie: "\u22B5",
+  rtrif: "\u25B8",
+  rtriltri: "\u29CE",
+  ruluhar: "\u2968",
+  rx: "\u211E",
+  sacute: "\u015B",
+  sbquo: "\u201A",
+  sc: "\u227B",
+  scE: "\u2AB4",
+  scap: "\u2AB8",
+  scaron: "\u0161",
+  sccue: "\u227D",
+  sce: "\u2AB0",
+  scedil: "\u015F",
+  scirc: "\u015D",
+  scnE: "\u2AB6",
+  scnap: "\u2ABA",
+  scnsim: "\u22E9",
+  scpolint: "\u2A13",
+  scsim: "\u227F",
+  scy: "\u0441",
+  sdot: "\u22C5",
+  sdotb: "\u22A1",
+  sdote: "\u2A66",
+  seArr: "\u21D8",
+  searhk: "\u2925",
+  searr: "\u2198",
+  searrow: "\u2198",
+  sec: "\xA7",
+  sect: "\xA7",
+  semi: ";",
+  seswar: "\u2929",
+  setminus: "\u2216",
+  setmn: "\u2216",
+  sext: "\u2736",
+  sfr: "\u{1D530}",
+  sfrown: "\u2322",
+  sharp: "\u266F",
+  shchcy: "\u0449",
+  shcy: "\u0448",
+  shortmid: "\u2223",
+  shortparallel: "\u2225",
+  sh: "\xAD",
+  shy: "\xAD",
+  sigma: "\u03C3",
+  sigmaf: "\u03C2",
+  sigmav: "\u03C2",
+  sim: "\u223C",
+  simdot: "\u2A6A",
+  sime: "\u2243",
+  simeq: "\u2243",
+  simg: "\u2A9E",
+  simgE: "\u2AA0",
+  siml: "\u2A9D",
+  simlE: "\u2A9F",
+  simne: "\u2246",
+  simplus: "\u2A24",
+  simrarr: "\u2972",
+  slarr: "\u2190",
+  smallsetminus: "\u2216",
+  smashp: "\u2A33",
+  smeparsl: "\u29E4",
+  smid: "\u2223",
+  smile: "\u2323",
+  smt: "\u2AAA",
+  smte: "\u2AAC",
+  smtes: "\u2AAC\uFE00",
+  softcy: "\u044C",
+  sol: "/",
+  solb: "\u29C4",
+  solbar: "\u233F",
+  sopf: "\u{1D564}",
+  spades: "\u2660",
+  spadesuit: "\u2660",
+  spar: "\u2225",
+  sqcap: "\u2293",
+  sqcaps: "\u2293\uFE00",
+  sqcup: "\u2294",
+  sqcups: "\u2294\uFE00",
+  sqsub: "\u228F",
+  sqsube: "\u2291",
+  sqsubset: "\u228F",
+  sqsubseteq: "\u2291",
+  sqsup: "\u2290",
+  sqsupe: "\u2292",
+  sqsupset: "\u2290",
+  sqsupseteq: "\u2292",
+  squ: "\u25A1",
+  square: "\u25A1",
+  squarf: "\u25AA",
+  squf: "\u25AA",
+  srarr: "\u2192",
+  sscr: "\u{1D4C8}",
+  ssetmn: "\u2216",
+  ssmile: "\u2323",
+  sstarf: "\u22C6",
+  star: "\u2606",
+  starf: "\u2605",
+  straightepsilon: "\u03F5",
+  straightphi: "\u03D5",
+  strns: "\xAF",
+  sub: "\u2282",
+  subE: "\u2AC5",
+  subdot: "\u2ABD",
+  sube: "\u2286",
+  subedot: "\u2AC3",
+  submult: "\u2AC1",
+  subnE: "\u2ACB",
+  subne: "\u228A",
+  subplus: "\u2ABF",
+  subrarr: "\u2979",
+  subset: "\u2282",
+  subseteq: "\u2286",
+  subseteqq: "\u2AC5",
+  subsetneq: "\u228A",
+  subsetneqq: "\u2ACB",
+  subsim: "\u2AC7",
+  subsub: "\u2AD5",
+  subsup: "\u2AD3",
+  succ: "\u227B",
+  succapprox: "\u2AB8",
+  succcurlyeq: "\u227D",
+  succeq: "\u2AB0",
+  succnapprox: "\u2ABA",
+  succneqq: "\u2AB6",
+  succnsim: "\u22E9",
+  succsim: "\u227F",
+  sum: "\u2211",
+  sung: "\u266A",
+  sup: "\u2283",
+  sup1: "\xB9",
+  sup2: "\xB2",
+  sup3: "\xB3",
+  supE: "\u2AC6",
+  supdot: "\u2ABE",
+  supdsub: "\u2AD8",
+  supe: "\u2287",
+  supedot: "\u2AC4",
+  suphsol: "\u27C9",
+  suphsub: "\u2AD7",
+  suplarr: "\u297B",
+  supmult: "\u2AC2",
+  supnE: "\u2ACC",
+  supne: "\u228B",
+  supplus: "\u2AC0",
+  supset: "\u2283",
+  supseteq: "\u2287",
+  supseteqq: "\u2AC6",
+  supsetneq: "\u228B",
+  supsetneqq: "\u2ACC",
+  supsim: "\u2AC8",
+  supsub: "\u2AD4",
+  supsup: "\u2AD6",
+  swArr: "\u21D9",
+  swarhk: "\u2926",
+  swarr: "\u2199",
+  swarrow: "\u2199",
+  swnwar: "\u292A",
+  szli: "\xDF",
+  szlig: "\xDF",
+  target: "\u2316",
+  tau: "\u03C4",
+  tbrk: "\u23B4",
+  tcaron: "\u0165",
+  tcedil: "\u0163",
+  tcy: "\u0442",
+  tdot: "\u20DB",
+  telrec: "\u2315",
+  tfr: "\u{1D531}",
+  there4: "\u2234",
+  therefore: "\u2234",
+  theta: "\u03B8",
+  thetasym: "\u03D1",
+  thetav: "\u03D1",
+  thickapprox: "\u2248",
+  thicksim: "\u223C",
+  thinsp: "\u2009",
+  thkap: "\u2248",
+  thksim: "\u223C",
+  thor: "\xFE",
+  thorn: "\xFE",
+  tilde: "\u02DC",
+  time: "\xD7",
+  times: "\xD7",
+  timesb: "\u22A0",
+  timesbar: "\u2A31",
+  timesd: "\u2A30",
+  tint: "\u222D",
+  toea: "\u2928",
+  top: "\u22A4",
+  topbot: "\u2336",
+  topcir: "\u2AF1",
+  topf: "\u{1D565}",
+  topfork: "\u2ADA",
+  tosa: "\u2929",
+  tprime: "\u2034",
+  trade: "\u2122",
+  triangle: "\u25B5",
+  triangledown: "\u25BF",
+  triangleleft: "\u25C3",
+  trianglelefteq: "\u22B4",
+  triangleq: "\u225C",
+  triangleright: "\u25B9",
+  trianglerighteq: "\u22B5",
+  tridot: "\u25EC",
+  trie: "\u225C",
+  triminus: "\u2A3A",
+  triplus: "\u2A39",
+  trisb: "\u29CD",
+  tritime: "\u2A3B",
+  trpezium: "\u23E2",
+  tscr: "\u{1D4C9}",
+  tscy: "\u0446",
+  tshcy: "\u045B",
+  tstrok: "\u0167",
+  twixt: "\u226C",
+  twoheadleftarrow: "\u219E",
+  twoheadrightarrow: "\u21A0",
+  uArr: "\u21D1",
+  uHar: "\u2963",
+  uacut: "\xFA",
+  uacute: "\xFA",
+  uarr: "\u2191",
+  ubrcy: "\u045E",
+  ubreve: "\u016D",
+  ucir: "\xFB",
+  ucirc: "\xFB",
+  ucy: "\u0443",
+  udarr: "\u21C5",
+  udblac: "\u0171",
+  udhar: "\u296E",
+  ufisht: "\u297E",
+  ufr: "\u{1D532}",
+  ugrav: "\xF9",
+  ugrave: "\xF9",
+  uharl: "\u21BF",
+  uharr: "\u21BE",
+  uhblk: "\u2580",
+  ulcorn: "\u231C",
+  ulcorner: "\u231C",
+  ulcrop: "\u230F",
+  ultri: "\u25F8",
+  umacr: "\u016B",
+  um: "\xA8",
+  uml: "\xA8",
+  uogon: "\u0173",
+  uopf: "\u{1D566}",
+  uparrow: "\u2191",
+  updownarrow: "\u2195",
+  upharpoonleft: "\u21BF",
+  upharpoonright: "\u21BE",
+  uplus: "\u228E",
+  upsi: "\u03C5",
+  upsih: "\u03D2",
+  upsilon: "\u03C5",
+  upuparrows: "\u21C8",
+  urcorn: "\u231D",
+  urcorner: "\u231D",
+  urcrop: "\u230E",
+  uring: "\u016F",
+  urtri: "\u25F9",
+  uscr: "\u{1D4CA}",
+  utdot: "\u22F0",
+  utilde: "\u0169",
+  utri: "\u25B5",
+  utrif: "\u25B4",
+  uuarr: "\u21C8",
+  uum: "\xFC",
+  uuml: "\xFC",
+  uwangle: "\u29A7",
+  vArr: "\u21D5",
+  vBar: "\u2AE8",
+  vBarv: "\u2AE9",
+  vDash: "\u22A8",
+  vangrt: "\u299C",
+  varepsilon: "\u03F5",
+  varkappa: "\u03F0",
+  varnothing: "\u2205",
+  varphi: "\u03D5",
+  varpi: "\u03D6",
+  varpropto: "\u221D",
+  varr: "\u2195",
+  varrho: "\u03F1",
+  varsigma: "\u03C2",
+  varsubsetneq: "\u228A\uFE00",
+  varsubsetneqq: "\u2ACB\uFE00",
+  varsupsetneq: "\u228B\uFE00",
+  varsupsetneqq: "\u2ACC\uFE00",
+  vartheta: "\u03D1",
+  vartriangleleft: "\u22B2",
+  vartriangleright: "\u22B3",
+  vcy: "\u0432",
+  vdash: "\u22A2",
+  vee: "\u2228",
+  veebar: "\u22BB",
+  veeeq: "\u225A",
+  vellip: "\u22EE",
+  verbar: "|",
+  vert: "|",
+  vfr: "\u{1D533}",
+  vltri: "\u22B2",
+  vnsub: "\u2282\u20D2",
+  vnsup: "\u2283\u20D2",
+  vopf: "\u{1D567}",
+  vprop: "\u221D",
+  vrtri: "\u22B3",
+  vscr: "\u{1D4CB}",
+  vsubnE: "\u2ACB\uFE00",
+  vsubne: "\u228A\uFE00",
+  vsupnE: "\u2ACC\uFE00",
+  vsupne: "\u228B\uFE00",
+  vzigzag: "\u299A",
+  wcirc: "\u0175",
+  wedbar: "\u2A5F",
+  wedge: "\u2227",
+  wedgeq: "\u2259",
+  weierp: "\u2118",
+  wfr: "\u{1D534}",
+  wopf: "\u{1D568}",
+  wp: "\u2118",
+  wr: "\u2240",
+  wreath: "\u2240",
+  wscr: "\u{1D4CC}",
+  xcap: "\u22C2",
+  xcirc: "\u25EF",
+  xcup: "\u22C3",
+  xdtri: "\u25BD",
+  xfr: "\u{1D535}",
+  xhArr: "\u27FA",
+  xharr: "\u27F7",
+  xi: "\u03BE",
+  xlArr: "\u27F8",
+  xlarr: "\u27F5",
+  xmap: "\u27FC",
+  xnis: "\u22FB",
+  xodot: "\u2A00",
+  xopf: "\u{1D569}",
+  xoplus: "\u2A01",
+  xotime: "\u2A02",
+  xrArr: "\u27F9",
+  xrarr: "\u27F6",
+  xscr: "\u{1D4CD}",
+  xsqcup: "\u2A06",
+  xuplus: "\u2A04",
+  xutri: "\u25B3",
+  xvee: "\u22C1",
+  xwedge: "\u22C0",
+  yacut: "\xFD",
+  yacute: "\xFD",
+  yacy: "\u044F",
+  ycirc: "\u0177",
+  ycy: "\u044B",
+  ye: "\xA5",
+  yen: "\xA5",
+  yfr: "\u{1D536}",
+  yicy: "\u0457",
+  yopf: "\u{1D56A}",
+  yscr: "\u{1D4CE}",
+  yucy: "\u044E",
+  yum: "\xFF",
+  yuml: "\xFF",
+  zacute: "\u017A",
+  zcaron: "\u017E",
+  zcy: "\u0437",
+  zdot: "\u017C",
+  zeetrf: "\u2128",
+  zeta: "\u03B6",
+  zfr: "\u{1D537}",
+  zhcy: "\u0436",
+  zigrarr: "\u21DD",
+  zopf: "\u{1D56B}",
+  zscr: "\u{1D4CF}",
+  zwj: "\u200D",
+  zwnj: "\u200C"
+};
+
+// ../../node_modules/.pnpm/decode-named-character-reference@1.0.1/node_modules/decode-named-character-reference/index.js
+var own5 = {}.hasOwnProperty;
+function decodeNamedCharacterReference(value) {
+  return own5.call(characterEntities, value) ? characterEntities[value] : false;
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/character-reference.js
+var characterReference = {
+  name: "characterReference",
+  tokenize: tokenizeCharacterReference
+};
+function tokenizeCharacterReference(effects, ok3, nok) {
+  const self2 = this;
+  let size = 0;
+  let max;
+  let test;
+  return start3;
+  function start3(code3) {
+    effects.enter("characterReference");
+    effects.enter("characterReferenceMarker");
+    effects.consume(code3);
+    effects.exit("characterReferenceMarker");
+    return open;
+  }
+  function open(code3) {
+    if (code3 === 35) {
+      effects.enter("characterReferenceMarkerNumeric");
+      effects.consume(code3);
+      effects.exit("characterReferenceMarkerNumeric");
+      return numeric;
+    }
+    effects.enter("characterReferenceValue");
+    max = 31;
+    test = asciiAlphanumeric;
+    return value(code3);
+  }
+  function numeric(code3) {
+    if (code3 === 88 || code3 === 120) {
+      effects.enter("characterReferenceMarkerHexadecimal");
+      effects.consume(code3);
+      effects.exit("characterReferenceMarkerHexadecimal");
+      effects.enter("characterReferenceValue");
+      max = 6;
+      test = asciiHexDigit;
+      return value;
+    }
+    effects.enter("characterReferenceValue");
+    max = 7;
+    test = asciiDigit;
+    return value(code3);
+  }
+  function value(code3) {
+    let token;
+    if (code3 === 59 && size) {
+      token = effects.exit("characterReferenceValue");
+      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
+        return nok(code3);
+      }
+      effects.enter("characterReferenceMarker");
+      effects.consume(code3);
+      effects.exit("characterReferenceMarker");
+      effects.exit("characterReference");
+      return ok3;
+    }
+    if (test(code3) && size++ < max) {
+      effects.consume(code3);
+      return value;
+    }
+    return nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-fenced.js
+var codeFenced = {
+  name: "codeFenced",
+  tokenize: tokenizeCodeFenced,
+  concrete: true
+};
+function tokenizeCodeFenced(effects, ok3, nok) {
+  const self2 = this;
+  const closingFenceConstruct = {
+    tokenize: tokenizeClosingFence,
+    partial: true
+  };
+  const nonLazyLine = {
+    tokenize: tokenizeNonLazyLine,
+    partial: true
+  };
+  const tail = this.events[this.events.length - 1];
+  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
+  let sizeOpen = 0;
+  let marker;
+  return start3;
+  function start3(code3) {
+    effects.enter("codeFenced");
+    effects.enter("codeFencedFence");
+    effects.enter("codeFencedFenceSequence");
+    marker = code3;
+    return sequenceOpen(code3);
+  }
+  function sequenceOpen(code3) {
+    if (code3 === marker) {
+      effects.consume(code3);
+      sizeOpen++;
+      return sequenceOpen;
+    }
+    effects.exit("codeFencedFenceSequence");
+    return sizeOpen < 3 ? nok(code3) : factorySpace(effects, infoOpen, "whitespace")(code3);
+  }
+  function infoOpen(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      return openAfter(code3);
+    }
+    effects.enter("codeFencedFenceInfo");
+    effects.enter("chunkString", {
+      contentType: "string"
+    });
+    return info(code3);
+  }
+  function info(code3) {
+    if (code3 === null || markdownLineEndingOrSpace(code3)) {
+      effects.exit("chunkString");
+      effects.exit("codeFencedFenceInfo");
+      return factorySpace(effects, infoAfter, "whitespace")(code3);
+    }
+    if (code3 === 96 && code3 === marker)
+      return nok(code3);
+    effects.consume(code3);
+    return info;
+  }
+  function infoAfter(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      return openAfter(code3);
+    }
+    effects.enter("codeFencedFenceMeta");
+    effects.enter("chunkString", {
+      contentType: "string"
+    });
+    return meta(code3);
+  }
+  function meta(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      effects.exit("chunkString");
+      effects.exit("codeFencedFenceMeta");
+      return openAfter(code3);
+    }
+    if (code3 === 96 && code3 === marker)
+      return nok(code3);
+    effects.consume(code3);
+    return meta;
+  }
+  function openAfter(code3) {
+    effects.exit("codeFencedFence");
+    return self2.interrupt ? ok3(code3) : contentStart(code3);
+  }
+  function contentStart(code3) {
+    if (code3 === null) {
+      return after(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, "linePrefix", initialPrefix + 1) : contentStart), after)(code3);
+    }
+    effects.enter("codeFlowValue");
+    return contentContinue(code3);
+  }
+  function contentContinue(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      effects.exit("codeFlowValue");
+      return contentStart(code3);
+    }
+    effects.consume(code3);
+    return contentContinue;
+  }
+  function after(code3) {
+    effects.exit("codeFenced");
+    return ok3(code3);
+  }
+  function tokenizeNonLazyLine(effects2, ok4, nok2) {
+    const self3 = this;
+    return start4;
+    function start4(code3) {
+      effects2.enter("lineEnding");
+      effects2.consume(code3);
+      effects2.exit("lineEnding");
+      return lineStart;
+    }
+    function lineStart(code3) {
+      return self3.parser.lazy[self3.now().line] ? nok2(code3) : ok4(code3);
+    }
+  }
+  function tokenizeClosingFence(effects2, ok4, nok2) {
+    let size = 0;
+    return factorySpace(effects2, closingSequenceStart, "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
+    function closingSequenceStart(code3) {
+      effects2.enter("codeFencedFence");
+      effects2.enter("codeFencedFenceSequence");
+      return closingSequence(code3);
+    }
+    function closingSequence(code3) {
+      if (code3 === marker) {
+        effects2.consume(code3);
+        size++;
+        return closingSequence;
+      }
+      if (size < sizeOpen)
+        return nok2(code3);
+      effects2.exit("codeFencedFenceSequence");
+      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code3);
+    }
+    function closingSequenceEnd(code3) {
+      if (code3 === null || markdownLineEnding(code3)) {
+        effects2.exit("codeFencedFence");
+        return ok4(code3);
+      }
+      return nok2(code3);
+    }
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-indented.js
+var codeIndented = {
+  name: "codeIndented",
+  tokenize: tokenizeCodeIndented
+};
+var indentedContent = {
+  tokenize: tokenizeIndentedContent,
+  partial: true
+};
+function tokenizeCodeIndented(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    effects.enter("codeIndented");
+    return factorySpace(effects, afterStartPrefix, "linePrefix", 4 + 1)(code3);
+  }
+  function afterStartPrefix(code3) {
+    const tail = self2.events[self2.events.length - 1];
+    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code3) : nok(code3);
+  }
+  function afterPrefix(code3) {
+    if (code3 === null) {
+      return after(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      return effects.attempt(indentedContent, afterPrefix, after)(code3);
+    }
+    effects.enter("codeFlowValue");
+    return content3(code3);
+  }
+  function content3(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      effects.exit("codeFlowValue");
+      return afterPrefix(code3);
+    }
+    effects.consume(code3);
+    return content3;
+  }
+  function after(code3) {
+    effects.exit("codeIndented");
+    return ok3(code3);
+  }
+}
+function tokenizeIndentedContent(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    if (self2.parser.lazy[self2.now().line]) {
+      return nok(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      effects.enter("lineEnding");
+      effects.consume(code3);
+      effects.exit("lineEnding");
+      return start3;
+    }
+    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code3);
+  }
+  function afterPrefix(code3) {
+    const tail = self2.events[self2.events.length - 1];
+    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code3) : markdownLineEnding(code3) ? start3(code3) : nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-text.js
+var codeText = {
+  name: "codeText",
+  tokenize: tokenizeCodeText,
+  resolve: resolveCodeText,
+  previous
+};
+function resolveCodeText(events) {
+  let tailExitIndex = events.length - 4;
+  let headEnterIndex = 3;
+  let index3;
+  let enter;
+  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
+    index3 = headEnterIndex;
+    while (++index3 < tailExitIndex) {
+      if (events[index3][1].type === "codeTextData") {
+        events[headEnterIndex][1].type = "codeTextPadding";
+        events[tailExitIndex][1].type = "codeTextPadding";
+        headEnterIndex += 2;
+        tailExitIndex -= 2;
+        break;
+      }
+    }
+  }
+  index3 = headEnterIndex - 1;
+  tailExitIndex++;
+  while (++index3 <= tailExitIndex) {
+    if (enter === void 0) {
+      if (index3 !== tailExitIndex && events[index3][1].type !== "lineEnding") {
+        enter = index3;
+      }
+    } else if (index3 === tailExitIndex || events[index3][1].type === "lineEnding") {
+      events[enter][1].type = "codeTextData";
+      if (index3 !== enter + 2) {
+        events[enter][1].end = events[index3 - 1][1].end;
+        events.splice(enter + 2, index3 - enter - 2);
+        tailExitIndex -= index3 - enter - 2;
+        index3 = enter + 2;
+      }
+      enter = void 0;
+    }
+  }
+  return events;
+}
+function previous(code3) {
+  return code3 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
+}
+function tokenizeCodeText(effects, ok3, nok) {
+  const self2 = this;
+  let sizeOpen = 0;
+  let size;
+  let token;
+  return start3;
+  function start3(code3) {
+    effects.enter("codeText");
+    effects.enter("codeTextSequence");
+    return openingSequence(code3);
+  }
+  function openingSequence(code3) {
+    if (code3 === 96) {
+      effects.consume(code3);
+      sizeOpen++;
+      return openingSequence;
+    }
+    effects.exit("codeTextSequence");
+    return gap(code3);
+  }
+  function gap(code3) {
+    if (code3 === null) {
+      return nok(code3);
+    }
+    if (code3 === 96) {
+      token = effects.enter("codeTextSequence");
+      size = 0;
+      return closingSequence(code3);
+    }
+    if (code3 === 32) {
+      effects.enter("space");
+      effects.consume(code3);
+      effects.exit("space");
+      return gap;
+    }
+    if (markdownLineEnding(code3)) {
+      effects.enter("lineEnding");
+      effects.consume(code3);
+      effects.exit("lineEnding");
+      return gap;
+    }
+    effects.enter("codeTextData");
+    return data2(code3);
+  }
+  function data2(code3) {
+    if (code3 === null || code3 === 32 || code3 === 96 || markdownLineEnding(code3)) {
+      effects.exit("codeTextData");
+      return gap(code3);
+    }
+    effects.consume(code3);
+    return data2;
+  }
+  function closingSequence(code3) {
+    if (code3 === 96) {
+      effects.consume(code3);
+      size++;
+      return closingSequence;
+    }
+    if (size === sizeOpen) {
+      effects.exit("codeTextSequence");
+      effects.exit("codeText");
+      return ok3(code3);
+    }
+    token.type = "codeTextData";
+    return data2(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-util-subtokenize@1.0.2/node_modules/micromark-util-subtokenize/index.js
+function subtokenize(events) {
+  const jumps = {};
+  let index3 = -1;
+  let event;
+  let lineIndex;
+  let otherIndex;
+  let otherEvent;
+  let parameters;
+  let subevents;
+  let more;
+  while (++index3 < events.length) {
+    while (index3 in jumps) {
+      index3 = jumps[index3];
+    }
+    event = events[index3];
+    if (index3 && event[1].type === "chunkFlow" && events[index3 - 1][1].type === "listItemPrefix") {
+      subevents = event[1]._tokenizer.events;
+      otherIndex = 0;
+      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
+        otherIndex += 2;
+      }
+      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
+        while (++otherIndex < subevents.length) {
+          if (subevents[otherIndex][1].type === "content") {
+            break;
+          }
+          if (subevents[otherIndex][1].type === "chunkText") {
+            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
+            otherIndex++;
+          }
+        }
+      }
+    }
+    if (event[0] === "enter") {
+      if (event[1].contentType) {
+        Object.assign(jumps, subcontent(events, index3));
+        index3 = jumps[index3];
+        more = true;
+      }
+    } else if (event[1]._container) {
+      otherIndex = index3;
+      lineIndex = void 0;
+      while (otherIndex--) {
+        otherEvent = events[otherIndex];
+        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
+          if (otherEvent[0] === "enter") {
+            if (lineIndex) {
+              events[lineIndex][1].type = "lineEndingBlank";
+            }
+            otherEvent[1].type = "lineEnding";
+            lineIndex = otherIndex;
+          }
+        } else {
+          break;
+        }
+      }
+      if (lineIndex) {
+        event[1].end = Object.assign({}, events[lineIndex][1].start);
+        parameters = events.slice(lineIndex, index3);
+        parameters.unshift(event);
+        splice(events, lineIndex, index3 - lineIndex + 1, parameters);
+      }
+    }
+  }
+  return !more;
+}
+function subcontent(events, eventIndex) {
+  const token = events[eventIndex][1];
+  const context = events[eventIndex][2];
+  let startPosition = eventIndex - 1;
+  const startPositions = [];
+  const tokenizer3 = token._tokenizer || context.parser[token.contentType](token.start);
+  const childEvents = tokenizer3.events;
+  const jumps = [];
+  const gaps = {};
+  let stream;
+  let previous3;
+  let index3 = -1;
+  let current2 = token;
+  let adjust = 0;
+  let start3 = 0;
+  const breaks = [start3];
+  while (current2) {
+    while (events[++startPosition][1] !== current2) {
+    }
+    startPositions.push(startPosition);
+    if (!current2._tokenizer) {
+      stream = context.sliceStream(current2);
+      if (!current2.next) {
+        stream.push(null);
+      }
+      if (previous3) {
+        tokenizer3.defineSkip(current2.start);
+      }
+      if (current2._isInFirstContentOfListItem) {
+        tokenizer3._gfmTasklistFirstContentOfListItem = true;
+      }
+      tokenizer3.write(stream);
+      if (current2._isInFirstContentOfListItem) {
+        tokenizer3._gfmTasklistFirstContentOfListItem = void 0;
+      }
+    }
+    previous3 = current2;
+    current2 = current2.next;
+  }
+  current2 = token;
+  while (++index3 < childEvents.length) {
+    if (childEvents[index3][0] === "exit" && childEvents[index3 - 1][0] === "enter" && childEvents[index3][1].type === childEvents[index3 - 1][1].type && childEvents[index3][1].start.line !== childEvents[index3][1].end.line) {
+      start3 = index3 + 1;
+      breaks.push(start3);
+      current2._tokenizer = void 0;
+      current2.previous = void 0;
+      current2 = current2.next;
+    }
+  }
+  tokenizer3.events = [];
+  if (current2) {
+    current2._tokenizer = void 0;
+    current2.previous = void 0;
+  } else {
+    breaks.pop();
+  }
+  index3 = breaks.length;
+  while (index3--) {
+    const slice2 = childEvents.slice(breaks[index3], breaks[index3 + 1]);
+    const start4 = startPositions.pop();
+    jumps.unshift([start4, start4 + slice2.length - 1]);
+    splice(events, start4, 2, slice2);
+  }
+  index3 = -1;
+  while (++index3 < jumps.length) {
+    gaps[adjust + jumps[index3][0]] = adjust + jumps[index3][1];
+    adjust += jumps[index3][1] - jumps[index3][0] - 1;
+  }
+  return gaps;
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/content.js
+var content = {
+  tokenize: tokenizeContent,
+  resolve: resolveContent
+};
+var continuationConstruct = {
+  tokenize: tokenizeContinuation,
+  partial: true
+};
+function resolveContent(events) {
+  subtokenize(events);
+  return events;
+}
+function tokenizeContent(effects, ok3) {
+  let previous3;
+  return start3;
+  function start3(code3) {
+    effects.enter("content");
+    previous3 = effects.enter("chunkContent", {
+      contentType: "content"
+    });
+    return data2(code3);
+  }
+  function data2(code3) {
+    if (code3 === null) {
+      return contentEnd(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      return effects.check(continuationConstruct, contentContinue, contentEnd)(code3);
+    }
+    effects.consume(code3);
+    return data2;
+  }
+  function contentEnd(code3) {
+    effects.exit("chunkContent");
+    effects.exit("content");
+    return ok3(code3);
+  }
+  function contentContinue(code3) {
+    effects.consume(code3);
+    effects.exit("chunkContent");
+    previous3.next = effects.enter("chunkContent", {
+      contentType: "content",
+      previous: previous3
+    });
+    previous3 = previous3.next;
+    return data2;
+  }
+}
+function tokenizeContinuation(effects, ok3, nok) {
+  const self2 = this;
+  return startLookahead;
+  function startLookahead(code3) {
+    effects.exit("chunkContent");
+    effects.enter("lineEnding");
+    effects.consume(code3);
+    effects.exit("lineEnding");
+    return factorySpace(effects, prefixed, "linePrefix");
+  }
+  function prefixed(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      return nok(code3);
+    }
+    const tail = self2.events[self2.events.length - 1];
+    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
+      return ok3(code3);
+    }
+    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-factory-destination@1.0.0/node_modules/micromark-factory-destination/index.js
+function factoryDestination(effects, ok3, nok, type2, literalType, literalMarkerType, rawType, stringType, max) {
+  const limit = max || Number.POSITIVE_INFINITY;
+  let balance = 0;
+  return start3;
+  function start3(code3) {
+    if (code3 === 60) {
+      effects.enter(type2);
+      effects.enter(literalType);
+      effects.enter(literalMarkerType);
+      effects.consume(code3);
+      effects.exit(literalMarkerType);
+      return destinationEnclosedBefore;
+    }
+    if (code3 === null || code3 === 41 || asciiControl(code3)) {
+      return nok(code3);
+    }
+    effects.enter(type2);
+    effects.enter(rawType);
+    effects.enter(stringType);
+    effects.enter("chunkString", {
+      contentType: "string"
+    });
+    return destinationRaw(code3);
+  }
+  function destinationEnclosedBefore(code3) {
+    if (code3 === 62) {
+      effects.enter(literalMarkerType);
+      effects.consume(code3);
+      effects.exit(literalMarkerType);
+      effects.exit(literalType);
+      effects.exit(type2);
+      return ok3;
+    }
+    effects.enter(stringType);
+    effects.enter("chunkString", {
+      contentType: "string"
+    });
+    return destinationEnclosed(code3);
+  }
+  function destinationEnclosed(code3) {
+    if (code3 === 62) {
+      effects.exit("chunkString");
+      effects.exit(stringType);
+      return destinationEnclosedBefore(code3);
+    }
+    if (code3 === null || code3 === 60 || markdownLineEnding(code3)) {
+      return nok(code3);
+    }
+    effects.consume(code3);
+    return code3 === 92 ? destinationEnclosedEscape : destinationEnclosed;
+  }
+  function destinationEnclosedEscape(code3) {
+    if (code3 === 60 || code3 === 62 || code3 === 92) {
+      effects.consume(code3);
+      return destinationEnclosed;
+    }
+    return destinationEnclosed(code3);
+  }
+  function destinationRaw(code3) {
+    if (code3 === 40) {
+      if (++balance > limit)
+        return nok(code3);
+      effects.consume(code3);
+      return destinationRaw;
+    }
+    if (code3 === 41) {
+      if (!balance--) {
+        effects.exit("chunkString");
+        effects.exit(stringType);
+        effects.exit(rawType);
+        effects.exit(type2);
+        return ok3(code3);
+      }
+      effects.consume(code3);
+      return destinationRaw;
+    }
+    if (code3 === null || markdownLineEndingOrSpace(code3)) {
+      if (balance)
+        return nok(code3);
+      effects.exit("chunkString");
+      effects.exit(stringType);
+      effects.exit(rawType);
+      effects.exit(type2);
+      return ok3(code3);
+    }
+    if (asciiControl(code3))
+      return nok(code3);
+    effects.consume(code3);
+    return code3 === 92 ? destinationRawEscape : destinationRaw;
+  }
+  function destinationRawEscape(code3) {
+    if (code3 === 40 || code3 === 41 || code3 === 92) {
+      effects.consume(code3);
+      return destinationRaw;
+    }
+    return destinationRaw(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-factory-label@1.0.2/node_modules/micromark-factory-label/index.js
+function factoryLabel(effects, ok3, nok, type2, markerType, stringType) {
+  const self2 = this;
+  let size = 0;
+  let data2;
+  return start3;
+  function start3(code3) {
+    effects.enter(type2);
+    effects.enter(markerType);
+    effects.consume(code3);
+    effects.exit(markerType);
+    effects.enter(stringType);
+    return atBreak;
+  }
+  function atBreak(code3) {
+    if (code3 === null || code3 === 91 || code3 === 93 && !data2 || code3 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs || size > 999) {
+      return nok(code3);
+    }
+    if (code3 === 93) {
+      effects.exit(stringType);
+      effects.enter(markerType);
+      effects.consume(code3);
+      effects.exit(markerType);
+      effects.exit(type2);
+      return ok3;
+    }
+    if (markdownLineEnding(code3)) {
+      effects.enter("lineEnding");
+      effects.consume(code3);
+      effects.exit("lineEnding");
+      return atBreak;
+    }
+    effects.enter("chunkString", {
+      contentType: "string"
+    });
+    return label(code3);
+  }
+  function label(code3) {
+    if (code3 === null || code3 === 91 || code3 === 93 || markdownLineEnding(code3) || size++ > 999) {
+      effects.exit("chunkString");
+      return atBreak(code3);
+    }
+    effects.consume(code3);
+    data2 = data2 || !markdownSpace(code3);
+    return code3 === 92 ? labelEscape : label;
+  }
+  function labelEscape(code3) {
+    if (code3 === 91 || code3 === 92 || code3 === 93) {
+      effects.consume(code3);
+      size++;
+      return label;
+    }
+    return label(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-factory-title@1.0.2/node_modules/micromark-factory-title/index.js
+function factoryTitle(effects, ok3, nok, type2, markerType, stringType) {
+  let marker;
+  return start3;
+  function start3(code3) {
+    effects.enter(type2);
+    effects.enter(markerType);
+    effects.consume(code3);
+    effects.exit(markerType);
+    marker = code3 === 40 ? 41 : code3;
+    return atFirstTitleBreak;
+  }
+  function atFirstTitleBreak(code3) {
+    if (code3 === marker) {
+      effects.enter(markerType);
+      effects.consume(code3);
+      effects.exit(markerType);
+      effects.exit(type2);
+      return ok3;
+    }
+    effects.enter(stringType);
+    return atTitleBreak(code3);
+  }
+  function atTitleBreak(code3) {
+    if (code3 === marker) {
+      effects.exit(stringType);
+      return atFirstTitleBreak(marker);
+    }
+    if (code3 === null) {
+      return nok(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      effects.enter("lineEnding");
+      effects.consume(code3);
+      effects.exit("lineEnding");
+      return factorySpace(effects, atTitleBreak, "linePrefix");
+    }
+    effects.enter("chunkString", {
+      contentType: "string"
+    });
+    return title(code3);
+  }
+  function title(code3) {
+    if (code3 === marker || code3 === null || markdownLineEnding(code3)) {
+      effects.exit("chunkString");
+      return atTitleBreak(code3);
+    }
+    effects.consume(code3);
+    return code3 === 92 ? titleEscape : title;
+  }
+  function titleEscape(code3) {
+    if (code3 === marker || code3 === 92) {
+      effects.consume(code3);
+      return title;
+    }
+    return title(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-factory-whitespace@1.0.0/node_modules/micromark-factory-whitespace/index.js
+function factoryWhitespace(effects, ok3) {
+  let seen;
+  return start3;
+  function start3(code3) {
+    if (markdownLineEnding(code3)) {
+      effects.enter("lineEnding");
+      effects.consume(code3);
+      effects.exit("lineEnding");
+      seen = true;
+      return start3;
+    }
+    if (markdownSpace(code3)) {
+      return factorySpace(effects, start3, seen ? "linePrefix" : "lineSuffix")(code3);
+    }
+    return ok3(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-util-normalize-identifier@1.0.0/node_modules/micromark-util-normalize-identifier/index.js
+function normalizeIdentifier(value) {
+  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/definition.js
+var definition = {
+  name: "definition",
+  tokenize: tokenizeDefinition
+};
+var titleConstruct = {
+  tokenize: tokenizeTitle,
+  partial: true
+};
+function tokenizeDefinition(effects, ok3, nok) {
+  const self2 = this;
+  let identifier;
+  return start3;
+  function start3(code3) {
+    effects.enter("definition");
+    return factoryLabel.call(self2, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code3);
+  }
+  function labelAfter(code3) {
+    identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
+    if (code3 === 58) {
+      effects.enter("definitionMarker");
+      effects.consume(code3);
+      effects.exit("definitionMarker");
+      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, "whitespace"), factorySpace(effects, after, "whitespace")), nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"));
+    }
+    return nok(code3);
+  }
+  function after(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      effects.exit("definition");
+      if (!self2.parser.defined.includes(identifier)) {
+        self2.parser.defined.push(identifier);
+      }
+      return ok3(code3);
+    }
+    return nok(code3);
+  }
+}
+function tokenizeTitle(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, before)(code3) : nok(code3);
+  }
+  function before(code3) {
+    if (code3 === 34 || code3 === 39 || code3 === 40) {
+      return factoryTitle(effects, factorySpace(effects, after, "whitespace"), nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code3);
+    }
+    return nok(code3);
+  }
+  function after(code3) {
+    return code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/hard-break-escape.js
+var hardBreakEscape = {
+  name: "hardBreakEscape",
+  tokenize: tokenizeHardBreakEscape
+};
+function tokenizeHardBreakEscape(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.enter("hardBreakEscape");
+    effects.enter("escapeMarker");
+    effects.consume(code3);
+    return open;
+  }
+  function open(code3) {
+    if (markdownLineEnding(code3)) {
+      effects.exit("escapeMarker");
+      effects.exit("hardBreakEscape");
+      return ok3(code3);
+    }
+    return nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/heading-atx.js
+var headingAtx = {
+  name: "headingAtx",
+  tokenize: tokenizeHeadingAtx,
+  resolve: resolveHeadingAtx
+};
+function resolveHeadingAtx(events, context) {
+  let contentEnd = events.length - 2;
+  let contentStart = 3;
+  let content3;
+  let text7;
+  if (events[contentStart][1].type === "whitespace") {
+    contentStart += 2;
+  }
+  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
+    contentEnd -= 2;
+  }
+  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
+    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
+  }
+  if (contentEnd > contentStart) {
+    content3 = {
+      type: "atxHeadingText",
+      start: events[contentStart][1].start,
+      end: events[contentEnd][1].end
+    };
+    text7 = {
+      type: "chunkText",
+      start: events[contentStart][1].start,
+      end: events[contentEnd][1].end,
+      contentType: "text"
+    };
+    splice(events, contentStart, contentEnd - contentStart + 1, [
+      ["enter", content3, context],
+      ["enter", text7, context],
+      ["exit", text7, context],
+      ["exit", content3, context]
+    ]);
+  }
+  return events;
+}
+function tokenizeHeadingAtx(effects, ok3, nok) {
+  const self2 = this;
+  let size = 0;
+  return start3;
+  function start3(code3) {
+    effects.enter("atxHeading");
+    effects.enter("atxHeadingSequence");
+    return fenceOpenInside(code3);
+  }
+  function fenceOpenInside(code3) {
+    if (code3 === 35 && size++ < 6) {
+      effects.consume(code3);
+      return fenceOpenInside;
+    }
+    if (code3 === null || markdownLineEndingOrSpace(code3)) {
+      effects.exit("atxHeadingSequence");
+      return self2.interrupt ? ok3(code3) : headingBreak(code3);
+    }
+    return nok(code3);
+  }
+  function headingBreak(code3) {
+    if (code3 === 35) {
+      effects.enter("atxHeadingSequence");
+      return sequence(code3);
+    }
+    if (code3 === null || markdownLineEnding(code3)) {
+      effects.exit("atxHeading");
+      return ok3(code3);
+    }
+    if (markdownSpace(code3)) {
+      return factorySpace(effects, headingBreak, "whitespace")(code3);
+    }
+    effects.enter("atxHeadingText");
+    return data2(code3);
+  }
+  function sequence(code3) {
+    if (code3 === 35) {
+      effects.consume(code3);
+      return sequence;
+    }
+    effects.exit("atxHeadingSequence");
+    return headingBreak(code3);
+  }
+  function data2(code3) {
+    if (code3 === null || code3 === 35 || markdownLineEndingOrSpace(code3)) {
+      effects.exit("atxHeadingText");
+      return headingBreak(code3);
+    }
+    effects.consume(code3);
+    return data2;
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-util-html-tag-name@1.0.0/node_modules/micromark-util-html-tag-name/index.js
+var htmlBlockNames = [
+  "address",
+  "article",
+  "aside",
+  "base",
+  "basefont",
+  "blockquote",
+  "body",
+  "caption",
+  "center",
+  "col",
+  "colgroup",
+  "dd",
+  "details",
+  "dialog",
+  "dir",
+  "div",
+  "dl",
+  "dt",
+  "fieldset",
+  "figcaption",
+  "figure",
+  "footer",
+  "form",
+  "frame",
+  "frameset",
+  "h1",
+  "h2",
+  "h3",
+  "h4",
+  "h5",
+  "h6",
+  "head",
+  "header",
+  "hr",
+  "html",
+  "iframe",
+  "legend",
+  "li",
+  "link",
+  "main",
+  "menu",
+  "menuitem",
+  "nav",
+  "noframes",
+  "ol",
+  "optgroup",
+  "option",
+  "p",
+  "param",
+  "section",
+  "source",
+  "summary",
+  "table",
+  "tbody",
+  "td",
+  "tfoot",
+  "th",
+  "thead",
+  "title",
+  "tr",
+  "track",
+  "ul"
+];
+var htmlRawNames = ["pre", "script", "style", "textarea"];
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/html-flow.js
+var htmlFlow = {
+  name: "htmlFlow",
+  tokenize: tokenizeHtmlFlow,
+  resolveTo: resolveToHtmlFlow,
+  concrete: true
+};
+var nextBlankConstruct = {
+  tokenize: tokenizeNextBlank,
+  partial: true
+};
+function resolveToHtmlFlow(events) {
+  let index3 = events.length;
+  while (index3--) {
+    if (events[index3][0] === "enter" && events[index3][1].type === "htmlFlow") {
+      break;
+    }
+  }
+  if (index3 > 1 && events[index3 - 2][1].type === "linePrefix") {
+    events[index3][1].start = events[index3 - 2][1].start;
+    events[index3 + 1][1].start = events[index3 - 2][1].start;
+    events.splice(index3 - 2, 2);
+  }
+  return events;
+}
+function tokenizeHtmlFlow(effects, ok3, nok) {
+  const self2 = this;
+  let kind;
+  let startTag;
+  let buffer2;
+  let index3;
+  let marker;
+  return start3;
+  function start3(code3) {
+    effects.enter("htmlFlow");
+    effects.enter("htmlFlowData");
+    effects.consume(code3);
+    return open;
+  }
+  function open(code3) {
+    if (code3 === 33) {
+      effects.consume(code3);
+      return declarationStart;
+    }
+    if (code3 === 47) {
+      effects.consume(code3);
+      return tagCloseStart;
+    }
+    if (code3 === 63) {
+      effects.consume(code3);
+      kind = 3;
+      return self2.interrupt ? ok3 : continuationDeclarationInside;
+    }
+    if (asciiAlpha(code3)) {
+      effects.consume(code3);
+      buffer2 = String.fromCharCode(code3);
+      startTag = true;
+      return tagName;
+    }
+    return nok(code3);
+  }
+  function declarationStart(code3) {
+    if (code3 === 45) {
+      effects.consume(code3);
+      kind = 2;
+      return commentOpenInside;
+    }
+    if (code3 === 91) {
+      effects.consume(code3);
+      kind = 5;
+      buffer2 = "CDATA[";
+      index3 = 0;
+      return cdataOpenInside;
+    }
+    if (asciiAlpha(code3)) {
+      effects.consume(code3);
+      kind = 4;
+      return self2.interrupt ? ok3 : continuationDeclarationInside;
+    }
+    return nok(code3);
+  }
+  function commentOpenInside(code3) {
+    if (code3 === 45) {
+      effects.consume(code3);
+      return self2.interrupt ? ok3 : continuationDeclarationInside;
+    }
+    return nok(code3);
+  }
+  function cdataOpenInside(code3) {
+    if (code3 === buffer2.charCodeAt(index3++)) {
+      effects.consume(code3);
+      return index3 === buffer2.length ? self2.interrupt ? ok3 : continuation : cdataOpenInside;
+    }
+    return nok(code3);
+  }
+  function tagCloseStart(code3) {
+    if (asciiAlpha(code3)) {
+      effects.consume(code3);
+      buffer2 = String.fromCharCode(code3);
+      return tagName;
+    }
+    return nok(code3);
+  }
+  function tagName(code3) {
+    if (code3 === null || code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
+      if (code3 !== 47 && startTag && htmlRawNames.includes(buffer2.toLowerCase())) {
+        kind = 1;
+        return self2.interrupt ? ok3(code3) : continuation(code3);
+      }
+      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
+        kind = 6;
+        if (code3 === 47) {
+          effects.consume(code3);
+          return basicSelfClosing;
+        }
+        return self2.interrupt ? ok3(code3) : continuation(code3);
+      }
+      kind = 7;
+      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code3) : startTag ? completeAttributeNameBefore(code3) : completeClosingTagAfter(code3);
+    }
+    if (code3 === 45 || asciiAlphanumeric(code3)) {
+      effects.consume(code3);
+      buffer2 += String.fromCharCode(code3);
+      return tagName;
+    }
+    return nok(code3);
+  }
+  function basicSelfClosing(code3) {
+    if (code3 === 62) {
+      effects.consume(code3);
+      return self2.interrupt ? ok3 : continuation;
+    }
+    return nok(code3);
+  }
+  function completeClosingTagAfter(code3) {
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return completeClosingTagAfter;
+    }
+    return completeEnd(code3);
+  }
+  function completeAttributeNameBefore(code3) {
+    if (code3 === 47) {
+      effects.consume(code3);
+      return completeEnd;
+    }
+    if (code3 === 58 || code3 === 95 || asciiAlpha(code3)) {
+      effects.consume(code3);
+      return completeAttributeName;
+    }
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return completeAttributeNameBefore;
+    }
+    return completeEnd(code3);
+  }
+  function completeAttributeName(code3) {
+    if (code3 === 45 || code3 === 46 || code3 === 58 || code3 === 95 || asciiAlphanumeric(code3)) {
+      effects.consume(code3);
+      return completeAttributeName;
+    }
+    return completeAttributeNameAfter(code3);
+  }
+  function completeAttributeNameAfter(code3) {
+    if (code3 === 61) {
+      effects.consume(code3);
+      return completeAttributeValueBefore;
+    }
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return completeAttributeNameAfter;
+    }
+    return completeAttributeNameBefore(code3);
+  }
+  function completeAttributeValueBefore(code3) {
+    if (code3 === null || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96) {
+      return nok(code3);
+    }
+    if (code3 === 34 || code3 === 39) {
+      effects.consume(code3);
+      marker = code3;
+      return completeAttributeValueQuoted;
+    }
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return completeAttributeValueBefore;
+    }
+    marker = null;
+    return completeAttributeValueUnquoted(code3);
+  }
+  function completeAttributeValueQuoted(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      return nok(code3);
+    }
+    if (code3 === marker) {
+      effects.consume(code3);
+      return completeAttributeValueQuotedAfter;
+    }
+    effects.consume(code3);
+    return completeAttributeValueQuoted;
+  }
+  function completeAttributeValueUnquoted(code3) {
+    if (code3 === null || code3 === 34 || code3 === 39 || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96 || markdownLineEndingOrSpace(code3)) {
+      return completeAttributeNameAfter(code3);
+    }
+    effects.consume(code3);
+    return completeAttributeValueUnquoted;
+  }
+  function completeAttributeValueQuotedAfter(code3) {
+    if (code3 === 47 || code3 === 62 || markdownSpace(code3)) {
+      return completeAttributeNameBefore(code3);
+    }
+    return nok(code3);
+  }
+  function completeEnd(code3) {
+    if (code3 === 62) {
+      effects.consume(code3);
+      return completeAfter;
+    }
+    return nok(code3);
+  }
+  function completeAfter(code3) {
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return completeAfter;
+    }
+    return code3 === null || markdownLineEnding(code3) ? continuation(code3) : nok(code3);
+  }
+  function continuation(code3) {
+    if (code3 === 45 && kind === 2) {
+      effects.consume(code3);
+      return continuationCommentInside;
+    }
+    if (code3 === 60 && kind === 1) {
+      effects.consume(code3);
+      return continuationRawTagOpen;
+    }
+    if (code3 === 62 && kind === 4) {
+      effects.consume(code3);
+      return continuationClose;
+    }
+    if (code3 === 63 && kind === 3) {
+      effects.consume(code3);
+      return continuationDeclarationInside;
+    }
+    if (code3 === 93 && kind === 5) {
+      effects.consume(code3);
+      return continuationCharacterDataInside;
+    }
+    if (markdownLineEnding(code3) && (kind === 6 || kind === 7)) {
+      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code3);
+    }
+    if (code3 === null || markdownLineEnding(code3)) {
+      return continuationAtLineEnding(code3);
+    }
+    effects.consume(code3);
+    return continuation;
+  }
+  function continuationAtLineEnding(code3) {
+    effects.exit("htmlFlowData");
+    return htmlContinueStart(code3);
+  }
+  function htmlContinueStart(code3) {
+    if (code3 === null) {
+      return done(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      return effects.attempt({
+        tokenize: htmlLineEnd,
+        partial: true
+      }, htmlContinueStart, done)(code3);
+    }
+    effects.enter("htmlFlowData");
+    return continuation(code3);
+  }
+  function htmlLineEnd(effects2, ok4, nok2) {
+    return start4;
+    function start4(code3) {
+      effects2.enter("lineEnding");
+      effects2.consume(code3);
+      effects2.exit("lineEnding");
+      return lineStart;
+    }
+    function lineStart(code3) {
+      return self2.parser.lazy[self2.now().line] ? nok2(code3) : ok4(code3);
+    }
+  }
+  function continuationCommentInside(code3) {
+    if (code3 === 45) {
+      effects.consume(code3);
+      return continuationDeclarationInside;
+    }
+    return continuation(code3);
+  }
+  function continuationRawTagOpen(code3) {
+    if (code3 === 47) {
+      effects.consume(code3);
+      buffer2 = "";
+      return continuationRawEndTag;
+    }
+    return continuation(code3);
+  }
+  function continuationRawEndTag(code3) {
+    if (code3 === 62 && htmlRawNames.includes(buffer2.toLowerCase())) {
+      effects.consume(code3);
+      return continuationClose;
+    }
+    if (asciiAlpha(code3) && buffer2.length < 8) {
+      effects.consume(code3);
+      buffer2 += String.fromCharCode(code3);
+      return continuationRawEndTag;
+    }
+    return continuation(code3);
+  }
+  function continuationCharacterDataInside(code3) {
+    if (code3 === 93) {
+      effects.consume(code3);
+      return continuationDeclarationInside;
+    }
+    return continuation(code3);
+  }
+  function continuationDeclarationInside(code3) {
+    if (code3 === 62) {
+      effects.consume(code3);
+      return continuationClose;
+    }
+    if (code3 === 45 && kind === 2) {
+      effects.consume(code3);
+      return continuationDeclarationInside;
+    }
+    return continuation(code3);
+  }
+  function continuationClose(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      effects.exit("htmlFlowData");
+      return done(code3);
+    }
+    effects.consume(code3);
+    return continuationClose;
+  }
+  function done(code3) {
+    effects.exit("htmlFlow");
+    return ok3(code3);
+  }
+}
+function tokenizeNextBlank(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.exit("htmlFlowData");
+    effects.enter("lineEndingBlank");
+    effects.consume(code3);
+    effects.exit("lineEndingBlank");
+    return effects.attempt(blankLine, ok3, nok);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/html-text.js
+var htmlText = {
+  name: "htmlText",
+  tokenize: tokenizeHtmlText
+};
+function tokenizeHtmlText(effects, ok3, nok) {
+  const self2 = this;
+  let marker;
+  let buffer2;
+  let index3;
+  let returnState;
+  return start3;
+  function start3(code3) {
+    effects.enter("htmlText");
+    effects.enter("htmlTextData");
+    effects.consume(code3);
+    return open;
+  }
+  function open(code3) {
+    if (code3 === 33) {
+      effects.consume(code3);
+      return declarationOpen;
+    }
+    if (code3 === 47) {
+      effects.consume(code3);
+      return tagCloseStart;
+    }
+    if (code3 === 63) {
+      effects.consume(code3);
+      return instruction;
+    }
+    if (asciiAlpha(code3)) {
+      effects.consume(code3);
+      return tagOpen;
+    }
+    return nok(code3);
+  }
+  function declarationOpen(code3) {
+    if (code3 === 45) {
+      effects.consume(code3);
+      return commentOpen;
+    }
+    if (code3 === 91) {
+      effects.consume(code3);
+      buffer2 = "CDATA[";
+      index3 = 0;
+      return cdataOpen;
+    }
+    if (asciiAlpha(code3)) {
+      effects.consume(code3);
+      return declaration;
+    }
+    return nok(code3);
+  }
+  function commentOpen(code3) {
+    if (code3 === 45) {
+      effects.consume(code3);
+      return commentStart;
+    }
+    return nok(code3);
+  }
+  function commentStart(code3) {
+    if (code3 === null || code3 === 62) {
+      return nok(code3);
+    }
+    if (code3 === 45) {
+      effects.consume(code3);
+      return commentStartDash;
+    }
+    return comment3(code3);
+  }
+  function commentStartDash(code3) {
+    if (code3 === null || code3 === 62) {
+      return nok(code3);
+    }
+    return comment3(code3);
+  }
+  function comment3(code3) {
+    if (code3 === null) {
+      return nok(code3);
+    }
+    if (code3 === 45) {
+      effects.consume(code3);
+      return commentClose;
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = comment3;
+      return atLineEnding(code3);
+    }
+    effects.consume(code3);
+    return comment3;
+  }
+  function commentClose(code3) {
+    if (code3 === 45) {
+      effects.consume(code3);
+      return end;
+    }
+    return comment3(code3);
+  }
+  function cdataOpen(code3) {
+    if (code3 === buffer2.charCodeAt(index3++)) {
+      effects.consume(code3);
+      return index3 === buffer2.length ? cdata : cdataOpen;
+    }
+    return nok(code3);
+  }
+  function cdata(code3) {
+    if (code3 === null) {
+      return nok(code3);
+    }
+    if (code3 === 93) {
+      effects.consume(code3);
+      return cdataClose;
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = cdata;
+      return atLineEnding(code3);
+    }
+    effects.consume(code3);
+    return cdata;
+  }
+  function cdataClose(code3) {
+    if (code3 === 93) {
+      effects.consume(code3);
+      return cdataEnd;
+    }
+    return cdata(code3);
+  }
+  function cdataEnd(code3) {
+    if (code3 === 62) {
+      return end(code3);
+    }
+    if (code3 === 93) {
+      effects.consume(code3);
+      return cdataEnd;
+    }
+    return cdata(code3);
+  }
+  function declaration(code3) {
+    if (code3 === null || code3 === 62) {
+      return end(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = declaration;
+      return atLineEnding(code3);
+    }
+    effects.consume(code3);
+    return declaration;
+  }
+  function instruction(code3) {
+    if (code3 === null) {
+      return nok(code3);
+    }
+    if (code3 === 63) {
+      effects.consume(code3);
+      return instructionClose;
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = instruction;
+      return atLineEnding(code3);
+    }
+    effects.consume(code3);
+    return instruction;
+  }
+  function instructionClose(code3) {
+    return code3 === 62 ? end(code3) : instruction(code3);
+  }
+  function tagCloseStart(code3) {
+    if (asciiAlpha(code3)) {
+      effects.consume(code3);
+      return tagClose;
+    }
+    return nok(code3);
+  }
+  function tagClose(code3) {
+    if (code3 === 45 || asciiAlphanumeric(code3)) {
+      effects.consume(code3);
+      return tagClose;
+    }
+    return tagCloseBetween(code3);
+  }
+  function tagCloseBetween(code3) {
+    if (markdownLineEnding(code3)) {
+      returnState = tagCloseBetween;
+      return atLineEnding(code3);
+    }
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return tagCloseBetween;
+    }
+    return end(code3);
+  }
+  function tagOpen(code3) {
+    if (code3 === 45 || asciiAlphanumeric(code3)) {
+      effects.consume(code3);
+      return tagOpen;
+    }
+    if (code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
+      return tagOpenBetween(code3);
+    }
+    return nok(code3);
+  }
+  function tagOpenBetween(code3) {
+    if (code3 === 47) {
+      effects.consume(code3);
+      return end;
+    }
+    if (code3 === 58 || code3 === 95 || asciiAlpha(code3)) {
+      effects.consume(code3);
+      return tagOpenAttributeName;
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = tagOpenBetween;
+      return atLineEnding(code3);
+    }
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return tagOpenBetween;
+    }
+    return end(code3);
+  }
+  function tagOpenAttributeName(code3) {
+    if (code3 === 45 || code3 === 46 || code3 === 58 || code3 === 95 || asciiAlphanumeric(code3)) {
+      effects.consume(code3);
+      return tagOpenAttributeName;
+    }
+    return tagOpenAttributeNameAfter(code3);
+  }
+  function tagOpenAttributeNameAfter(code3) {
+    if (code3 === 61) {
+      effects.consume(code3);
+      return tagOpenAttributeValueBefore;
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = tagOpenAttributeNameAfter;
+      return atLineEnding(code3);
+    }
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return tagOpenAttributeNameAfter;
+    }
+    return tagOpenBetween(code3);
+  }
+  function tagOpenAttributeValueBefore(code3) {
+    if (code3 === null || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96) {
+      return nok(code3);
+    }
+    if (code3 === 34 || code3 === 39) {
+      effects.consume(code3);
+      marker = code3;
+      return tagOpenAttributeValueQuoted;
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = tagOpenAttributeValueBefore;
+      return atLineEnding(code3);
+    }
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return tagOpenAttributeValueBefore;
+    }
+    effects.consume(code3);
+    marker = void 0;
+    return tagOpenAttributeValueUnquoted;
+  }
+  function tagOpenAttributeValueQuoted(code3) {
+    if (code3 === marker) {
+      effects.consume(code3);
+      return tagOpenAttributeValueQuotedAfter;
+    }
+    if (code3 === null) {
+      return nok(code3);
+    }
+    if (markdownLineEnding(code3)) {
+      returnState = tagOpenAttributeValueQuoted;
+      return atLineEnding(code3);
+    }
+    effects.consume(code3);
+    return tagOpenAttributeValueQuoted;
+  }
+  function tagOpenAttributeValueQuotedAfter(code3) {
+    if (code3 === 62 || code3 === 47 || markdownLineEndingOrSpace(code3)) {
+      return tagOpenBetween(code3);
+    }
+    return nok(code3);
+  }
+  function tagOpenAttributeValueUnquoted(code3) {
+    if (code3 === null || code3 === 34 || code3 === 39 || code3 === 60 || code3 === 61 || code3 === 96) {
+      return nok(code3);
+    }
+    if (code3 === 62 || markdownLineEndingOrSpace(code3)) {
+      return tagOpenBetween(code3);
+    }
+    effects.consume(code3);
+    return tagOpenAttributeValueUnquoted;
+  }
+  function atLineEnding(code3) {
+    effects.exit("htmlTextData");
+    effects.enter("lineEnding");
+    effects.consume(code3);
+    effects.exit("lineEnding");
+    return factorySpace(effects, afterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
+  }
+  function afterPrefix(code3) {
+    effects.enter("htmlTextData");
+    return returnState(code3);
+  }
+  function end(code3) {
+    if (code3 === 62) {
+      effects.consume(code3);
+      effects.exit("htmlTextData");
+      effects.exit("htmlText");
+      return ok3;
+    }
+    return nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-end.js
+var labelEnd = {
+  name: "labelEnd",
+  tokenize: tokenizeLabelEnd,
+  resolveTo: resolveToLabelEnd,
+  resolveAll: resolveAllLabelEnd
+};
+var resourceConstruct = {
+  tokenize: tokenizeResource
+};
+var fullReferenceConstruct = {
+  tokenize: tokenizeFullReference
+};
+var collapsedReferenceConstruct = {
+  tokenize: tokenizeCollapsedReference
+};
+function resolveAllLabelEnd(events) {
+  let index3 = -1;
+  let token;
+  while (++index3 < events.length) {
+    token = events[index3][1];
+    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
+      events.splice(index3 + 1, token.type === "labelImage" ? 4 : 2);
+      token.type = "data";
+      index3++;
+    }
+  }
+  return events;
+}
+function resolveToLabelEnd(events, context) {
+  let index3 = events.length;
+  let offset2 = 0;
+  let token;
+  let open;
+  let close;
+  let media;
+  while (index3--) {
+    token = events[index3][1];
+    if (open) {
+      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
+        break;
+      }
+      if (events[index3][0] === "enter" && token.type === "labelLink") {
+        token._inactive = true;
+      }
+    } else if (close) {
+      if (events[index3][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
+        open = index3;
+        if (token.type !== "labelLink") {
+          offset2 = 2;
+          break;
+        }
+      }
+    } else if (token.type === "labelEnd") {
+      close = index3;
+    }
+  }
+  const group = {
+    type: events[open][1].type === "labelLink" ? "link" : "image",
+    start: Object.assign({}, events[open][1].start),
+    end: Object.assign({}, events[events.length - 1][1].end)
+  };
+  const label = {
+    type: "label",
+    start: Object.assign({}, events[open][1].start),
+    end: Object.assign({}, events[close][1].end)
+  };
+  const text7 = {
+    type: "labelText",
+    start: Object.assign({}, events[open + offset2 + 2][1].end),
+    end: Object.assign({}, events[close - 2][1].start)
+  };
+  media = [
+    ["enter", group, context],
+    ["enter", label, context]
+  ];
+  media = push(media, events.slice(open + 1, open + offset2 + 3));
+  media = push(media, [["enter", text7, context]]);
+  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset2 + 4, close - 3), context));
+  media = push(media, [
+    ["exit", text7, context],
+    events[close - 2],
+    events[close - 1],
+    ["exit", label, context]
+  ]);
+  media = push(media, events.slice(close + 1));
+  media = push(media, [["exit", group, context]]);
+  splice(events, open, events.length, media);
+  return events;
+}
+function tokenizeLabelEnd(effects, ok3, nok) {
+  const self2 = this;
+  let index3 = self2.events.length;
+  let labelStart;
+  let defined;
+  while (index3--) {
+    if ((self2.events[index3][1].type === "labelImage" || self2.events[index3][1].type === "labelLink") && !self2.events[index3][1]._balanced) {
+      labelStart = self2.events[index3][1];
+      break;
+    }
+  }
+  return start3;
+  function start3(code3) {
+    if (!labelStart) {
+      return nok(code3);
+    }
+    if (labelStart._inactive)
+      return balanced(code3);
+    defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
+      start: labelStart.end,
+      end: self2.now()
+    })));
+    effects.enter("labelEnd");
+    effects.enter("labelMarker");
+    effects.consume(code3);
+    effects.exit("labelMarker");
+    effects.exit("labelEnd");
+    return afterLabelEnd;
+  }
+  function afterLabelEnd(code3) {
+    if (code3 === 40) {
+      return effects.attempt(resourceConstruct, ok3, defined ? ok3 : balanced)(code3);
+    }
+    if (code3 === 91) {
+      return effects.attempt(fullReferenceConstruct, ok3, defined ? effects.attempt(collapsedReferenceConstruct, ok3, balanced) : balanced)(code3);
+    }
+    return defined ? ok3(code3) : balanced(code3);
+  }
+  function balanced(code3) {
+    labelStart._balanced = true;
+    return nok(code3);
+  }
+}
+function tokenizeResource(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.enter("resource");
+    effects.enter("resourceMarker");
+    effects.consume(code3);
+    effects.exit("resourceMarker");
+    return factoryWhitespace(effects, open);
+  }
+  function open(code3) {
+    if (code3 === 41) {
+      return end(code3);
+    }
+    return factoryDestination(effects, destinationAfter, nok, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code3);
+  }
+  function destinationAfter(code3) {
+    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, between)(code3) : end(code3);
+  }
+  function between(code3) {
+    if (code3 === 34 || code3 === 39 || code3 === 40) {
+      return factoryTitle(effects, factoryWhitespace(effects, end), nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code3);
+    }
+    return end(code3);
+  }
+  function end(code3) {
+    if (code3 === 41) {
+      effects.enter("resourceMarker");
+      effects.consume(code3);
+      effects.exit("resourceMarker");
+      effects.exit("resource");
+      return ok3;
+    }
+    return nok(code3);
+  }
+}
+function tokenizeFullReference(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    return factoryLabel.call(self2, effects, afterLabel, nok, "reference", "referenceMarker", "referenceString")(code3);
+  }
+  function afterLabel(code3) {
+    return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok3(code3) : nok(code3);
+  }
+}
+function tokenizeCollapsedReference(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.enter("reference");
+    effects.enter("referenceMarker");
+    effects.consume(code3);
+    effects.exit("referenceMarker");
+    return open;
+  }
+  function open(code3) {
+    if (code3 === 93) {
+      effects.enter("referenceMarker");
+      effects.consume(code3);
+      effects.exit("referenceMarker");
+      effects.exit("reference");
+      return ok3;
+    }
+    return nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-start-image.js
+var labelStartImage = {
+  name: "labelStartImage",
+  tokenize: tokenizeLabelStartImage,
+  resolveAll: labelEnd.resolveAll
+};
+function tokenizeLabelStartImage(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    effects.enter("labelImage");
+    effects.enter("labelImageMarker");
+    effects.consume(code3);
+    effects.exit("labelImageMarker");
+    return open;
+  }
+  function open(code3) {
+    if (code3 === 91) {
+      effects.enter("labelMarker");
+      effects.consume(code3);
+      effects.exit("labelMarker");
+      effects.exit("labelImage");
+      return after;
+    }
+    return nok(code3);
+  }
+  function after(code3) {
+    return code3 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-start-link.js
+var labelStartLink = {
+  name: "labelStartLink",
+  tokenize: tokenizeLabelStartLink,
+  resolveAll: labelEnd.resolveAll
+};
+function tokenizeLabelStartLink(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    effects.enter("labelLink");
+    effects.enter("labelMarker");
+    effects.consume(code3);
+    effects.exit("labelMarker");
+    effects.exit("labelLink");
+    return after;
+  }
+  function after(code3) {
+    return code3 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/line-ending.js
+var lineEnding = {
+  name: "lineEnding",
+  tokenize: tokenizeLineEnding
+};
+function tokenizeLineEnding(effects, ok3) {
+  return start3;
+  function start3(code3) {
+    effects.enter("lineEnding");
+    effects.consume(code3);
+    effects.exit("lineEnding");
+    return factorySpace(effects, ok3, "linePrefix");
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/thematic-break.js
+var thematicBreak = {
+  name: "thematicBreak",
+  tokenize: tokenizeThematicBreak
+};
+function tokenizeThematicBreak(effects, ok3, nok) {
+  let size = 0;
+  let marker;
+  return start3;
+  function start3(code3) {
+    effects.enter("thematicBreak");
+    marker = code3;
+    return atBreak(code3);
+  }
+  function atBreak(code3) {
+    if (code3 === marker) {
+      effects.enter("thematicBreakSequence");
+      return sequence(code3);
+    }
+    if (markdownSpace(code3)) {
+      return factorySpace(effects, atBreak, "whitespace")(code3);
+    }
+    if (size < 3 || code3 !== null && !markdownLineEnding(code3)) {
+      return nok(code3);
+    }
+    effects.exit("thematicBreak");
+    return ok3(code3);
+  }
+  function sequence(code3) {
+    if (code3 === marker) {
+      effects.consume(code3);
+      size++;
+      return sequence;
+    }
+    effects.exit("thematicBreakSequence");
+    return atBreak(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/list.js
+var list = {
+  name: "list",
+  tokenize: tokenizeListStart,
+  continuation: {
+    tokenize: tokenizeListContinuation
+  },
+  exit: tokenizeListEnd
+};
+var listItemPrefixWhitespaceConstruct = {
+  tokenize: tokenizeListItemPrefixWhitespace,
+  partial: true
+};
+var indentConstruct = {
+  tokenize: tokenizeIndent,
+  partial: true
+};
+function tokenizeListStart(effects, ok3, nok) {
+  const self2 = this;
+  const tail = self2.events[self2.events.length - 1];
+  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
+  let size = 0;
+  return start3;
+  function start3(code3) {
+    const kind = self2.containerState.type || (code3 === 42 || code3 === 43 || code3 === 45 ? "listUnordered" : "listOrdered");
+    if (kind === "listUnordered" ? !self2.containerState.marker || code3 === self2.containerState.marker : asciiDigit(code3)) {
+      if (!self2.containerState.type) {
+        self2.containerState.type = kind;
+        effects.enter(kind, {
+          _container: true
+        });
+      }
+      if (kind === "listUnordered") {
+        effects.enter("listItemPrefix");
+        return code3 === 42 || code3 === 45 ? effects.check(thematicBreak, nok, atMarker)(code3) : atMarker(code3);
+      }
+      if (!self2.interrupt || code3 === 49) {
+        effects.enter("listItemPrefix");
+        effects.enter("listItemValue");
+        return inside(code3);
+      }
+    }
+    return nok(code3);
+  }
+  function inside(code3) {
+    if (asciiDigit(code3) && ++size < 10) {
+      effects.consume(code3);
+      return inside;
+    }
+    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code3 === self2.containerState.marker : code3 === 41 || code3 === 46)) {
+      effects.exit("listItemValue");
+      return atMarker(code3);
+    }
+    return nok(code3);
+  }
+  function atMarker(code3) {
+    effects.enter("listItemMarker");
+    effects.consume(code3);
+    effects.exit("listItemMarker");
+    self2.containerState.marker = self2.containerState.marker || code3;
+    return effects.check(blankLine, self2.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
+  }
+  function onBlank(code3) {
+    self2.containerState.initialBlankLine = true;
+    initialSize++;
+    return endOfPrefix(code3);
+  }
+  function otherPrefix(code3) {
+    if (markdownSpace(code3)) {
+      effects.enter("listItemPrefixWhitespace");
+      effects.consume(code3);
+      effects.exit("listItemPrefixWhitespace");
+      return endOfPrefix;
+    }
+    return nok(code3);
+  }
+  function endOfPrefix(code3) {
+    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
+    return ok3(code3);
+  }
+}
+function tokenizeListContinuation(effects, ok3, nok) {
+  const self2 = this;
+  self2.containerState._closeFlow = void 0;
+  return effects.check(blankLine, onBlank, notBlank);
+  function onBlank(code3) {
+    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
+    return factorySpace(effects, ok3, "listItemIndent", self2.containerState.size + 1)(code3);
+  }
+  function notBlank(code3) {
+    if (self2.containerState.furtherBlankLines || !markdownSpace(code3)) {
+      self2.containerState.furtherBlankLines = void 0;
+      self2.containerState.initialBlankLine = void 0;
+      return notInCurrentItem(code3);
+    }
+    self2.containerState.furtherBlankLines = void 0;
+    self2.containerState.initialBlankLine = void 0;
+    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code3);
+  }
+  function notInCurrentItem(code3) {
+    self2.containerState._closeFlow = true;
+    self2.interrupt = void 0;
+    return factorySpace(effects, effects.attempt(list, ok3, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code3);
+  }
+}
+function tokenizeIndent(effects, ok3, nok) {
+  const self2 = this;
+  return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
+  function afterPrefix(code3) {
+    const tail = self2.events[self2.events.length - 1];
+    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code3) : nok(code3);
+  }
+}
+function tokenizeListEnd(effects) {
+  effects.exit(this.containerState.type);
+}
+function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
+  const self2 = this;
+  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
+  function afterPrefix(code3) {
+    const tail = self2.events[self2.events.length - 1];
+    return !markdownSpace(code3) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code3) : nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/setext-underline.js
+var setextUnderline = {
+  name: "setextUnderline",
+  tokenize: tokenizeSetextUnderline,
+  resolveTo: resolveToSetextUnderline
+};
+function resolveToSetextUnderline(events, context) {
+  let index3 = events.length;
+  let content3;
+  let text7;
+  let definition2;
+  while (index3--) {
+    if (events[index3][0] === "enter") {
+      if (events[index3][1].type === "content") {
+        content3 = index3;
+        break;
+      }
+      if (events[index3][1].type === "paragraph") {
+        text7 = index3;
+      }
+    } else {
+      if (events[index3][1].type === "content") {
+        events.splice(index3, 1);
+      }
+      if (!definition2 && events[index3][1].type === "definition") {
+        definition2 = index3;
+      }
+    }
+  }
+  const heading2 = {
+    type: "setextHeading",
+    start: Object.assign({}, events[text7][1].start),
+    end: Object.assign({}, events[events.length - 1][1].end)
+  };
+  events[text7][1].type = "setextHeadingText";
+  if (definition2) {
+    events.splice(text7, 0, ["enter", heading2, context]);
+    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
+    events[content3][1].end = Object.assign({}, events[definition2][1].end);
+  } else {
+    events[content3][1] = heading2;
+  }
+  events.push(["exit", heading2, context]);
+  return events;
+}
+function tokenizeSetextUnderline(effects, ok3, nok) {
+  const self2 = this;
+  let index3 = self2.events.length;
+  let marker;
+  let paragraph2;
+  while (index3--) {
+    if (self2.events[index3][1].type !== "lineEnding" && self2.events[index3][1].type !== "linePrefix" && self2.events[index3][1].type !== "content") {
+      paragraph2 = self2.events[index3][1].type === "paragraph";
+      break;
+    }
+  }
+  return start3;
+  function start3(code3) {
+    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
+      effects.enter("setextHeadingLine");
+      effects.enter("setextHeadingLineSequence");
+      marker = code3;
+      return closingSequence(code3);
+    }
+    return nok(code3);
+  }
+  function closingSequence(code3) {
+    if (code3 === marker) {
+      effects.consume(code3);
+      return closingSequence;
+    }
+    effects.exit("setextHeadingLineSequence");
+    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code3);
+  }
+  function closingSequenceEnd(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      effects.exit("setextHeadingLine");
+      return ok3(code3);
+    }
+    return nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-mdxjs-esm@1.0.2/node_modules/micromark-extension-mdxjs-esm/lib/syntax.js
+var nextBlankConstruct2 = {
+  tokenize: tokenizeNextBlank2,
+  partial: true
+};
+var allowedAcornTypes = /* @__PURE__ */ new Set([
+  "ExportAllDeclaration",
+  "ExportDefaultDeclaration",
+  "ExportNamedDeclaration",
+  "ImportDeclaration"
+]);
+function mdxjsEsm(options) {
+  const exportImportConstruct = {
+    tokenize: tokenizeExportImport,
+    concrete: true
+  };
+  if (!options || !options.acorn || !options.acorn.parse) {
+    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
+  }
+  const acorn = options.acorn;
+  const acornOptions = Object.assign({
+    ecmaVersion: 2020,
+    sourceType: "module"
+  }, options.acornOptions);
+  return {
+    flow: {
+      [101]: exportImportConstruct,
+      [105]: exportImportConstruct
+    }
+  };
+  function tokenizeExportImport(effects, ok3, nok) {
+    const self2 = this;
+    const definedModuleSpecifiers = self2.parser.definedModuleSpecifiers || (self2.parser.definedModuleSpecifiers = []);
+    const eventStart = this.events.length + 1;
+    let index3 = 0;
+    let buffer2;
+    return self2.interrupt ? nok : start3;
+    function start3(code3) {
+      if (self2.now().column > 1)
+        return nok(code3);
+      buffer2 = code3 === 101 ? "export" : "import";
+      effects.enter("mdxjsEsm");
+      effects.enter("mdxjsEsmData");
+      return keyword(code3);
+    }
+    function keyword(code3) {
+      if (code3 === buffer2.charCodeAt(index3++)) {
+        effects.consume(code3);
+        return index3 === buffer2.length ? after : keyword;
+      }
+      return nok(code3);
+    }
+    function after(code3) {
+      if (unicodeWhitespace(code3)) {
+        effects.consume(code3);
+        return rest;
+      }
+      return nok(code3);
+    }
+    function rest(code3) {
+      if (code3 === null) {
+        return atEnd(code3);
+      }
+      if (markdownLineEnding(code3)) {
+        return effects.check(nextBlankConstruct2, atEnd, atEol)(code3);
+      }
+      effects.consume(code3);
+      return rest;
+    }
+    function atEol(code3) {
+      effects.exit("mdxjsEsmData");
+      return lineStart(code3);
+    }
+    function lineStart(code3) {
+      if (markdownLineEnding(code3)) {
+        effects.enter("lineEnding");
+        effects.consume(code3);
+        effects.exit("lineEnding");
+        return lineStart;
+      }
+      effects.enter("mdxjsEsmData");
+      return rest(code3);
+    }
+    function atEnd(code3) {
+      effects.exit("mdxjsEsmData");
+      let index4 = -1;
+      const result = eventsToAcorn(self2.events.slice(eventStart), {
+        acorn,
+        acornOptions,
+        prefix: definedModuleSpecifiers.length > 0 ? "var " + definedModuleSpecifiers.join(",") + "\n" : ""
+      });
+      if (code3 !== null && result.swallow) {
+        return lineStart(code3);
+      }
+      if (result.error) {
+        throw new VFileMessage("Could not parse import/exports with acorn: " + String(result.error), {
+          line: result.error.loc.line,
+          column: result.error.loc.column + 1,
+          offset: result.error.pos
+        }, "micromark-extension-mdxjs-esm:acorn");
+      }
+      if (definedModuleSpecifiers.length > 0) {
+        result.estree.body.shift();
+      }
+      while (++index4 < result.estree.body.length) {
+        const node = result.estree.body[index4];
+        if (!allowedAcornTypes.has(node.type)) {
+          throw new VFileMessage("Unexpected `" + node.type + "` in code: only import/exports are supported", positionFromEstree(node), "micromark-extension-mdxjs-esm:non-esm");
+        }
+        if (node.type === "ImportDeclaration" && !self2.interrupt) {
+          let index5 = -1;
+          while (++index5 < node.specifiers.length) {
+            definedModuleSpecifiers.push(node.specifiers[index5].local.name);
+          }
+        }
+      }
+      Object.assign(effects.exit("mdxjsEsm"), options.addResult ? {
+        estree: result.estree
+      } : void 0);
+      return ok3(code3);
+    }
+  }
+}
+function tokenizeNextBlank2(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.exit("mdxjsEsmData");
+    effects.enter("lineEndingBlank");
+    effects.consume(code3);
+    effects.exit("lineEndingBlank");
+    return effects.attempt(blankLine, ok3, nok);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-mdxjs@1.0.0/node_modules/micromark-extension-mdxjs/index.js
+function mdxjs(options) {
+  const settings = Object.assign({
+    acorn: Parser.extend((0, import_acorn_jsx.default)()),
+    acornOptions: { ecmaVersion: 2020, sourceType: "module" },
+    addResult: true
+  }, options);
+  return combineExtensions([
+    mdxjsEsm(settings),
+    mdxExpression(settings),
+    mdxJsx(settings),
+    mdxMd
+  ]);
+}
+
+// ../../node_modules/.pnpm/mdast-util-mdx-expression@1.1.1/node_modules/mdast-util-mdx-expression/index.js
+var mdxExpressionFromMarkdown = {
+  enter: {
+    mdxFlowExpression: enterMdxFlowExpression,
+    mdxTextExpression: enterMdxTextExpression
+  },
+  exit: {
+    mdxFlowExpression: exitMdxExpression,
+    mdxFlowExpressionChunk: exitMdxExpressionData,
+    mdxTextExpression: exitMdxExpression,
+    mdxTextExpressionChunk: exitMdxExpressionData
+  }
+};
+var mdxExpressionToMarkdown = {
+  handlers: {
+    mdxFlowExpression: handleMdxExpression,
+    mdxTextExpression: handleMdxExpression
+  },
+  unsafe: [
+    { character: "{", inConstruct: ["phrasing"] },
+    { atBreak: true, character: "{" }
+  ]
+};
+function enterMdxFlowExpression(token) {
+  this.enter({ type: "mdxFlowExpression", value: "" }, token);
+  this.buffer();
+}
+function enterMdxTextExpression(token) {
+  this.enter({ type: "mdxTextExpression", value: "" }, token);
+  this.buffer();
+}
+function exitMdxExpression(token) {
+  const value = this.resume();
+  const estree = token.estree;
+  const node = this.exit(token);
+  node.value = value;
+  if (estree) {
+    node.data = { estree };
+  }
+}
+function exitMdxExpressionData(token) {
+  this.config.enter.data.call(this, token);
+  this.config.exit.data.call(this, token);
+}
+function handleMdxExpression(node) {
+  const value = node.value || "";
+  return "{" + value + "}";
+}
+
+// ../../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js
+function ccount(value, character) {
+  const source = String(value);
+  if (typeof character !== "string") {
+    throw new TypeError("Expected character");
+  }
+  let count = 0;
+  let index3 = source.indexOf(character);
+  while (index3 !== -1) {
+    count++;
+    index3 = source.indexOf(character, index3 + character.length);
+  }
+  return count;
+}
+
+// ../../node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js
+var characterEntitiesLegacy = [
+  "AElig",
+  "AMP",
+  "Aacute",
+  "Acirc",
+  "Agrave",
+  "Aring",
+  "Atilde",
+  "Auml",
+  "COPY",
+  "Ccedil",
+  "ETH",
+  "Eacute",
+  "Ecirc",
+  "Egrave",
+  "Euml",
+  "GT",
+  "Iacute",
+  "Icirc",
+  "Igrave",
+  "Iuml",
+  "LT",
+  "Ntilde",
+  "Oacute",
+  "Ocirc",
+  "Ograve",
+  "Oslash",
+  "Otilde",
+  "Ouml",
+  "QUOT",
+  "REG",
+  "THORN",
+  "Uacute",
+  "Ucirc",
+  "Ugrave",
+  "Uuml",
+  "Yacute",
+  "aacute",
+  "acirc",
+  "acute",
+  "aelig",
+  "agrave",
+  "amp",
+  "aring",
+  "atilde",
+  "auml",
+  "brvbar",
+  "ccedil",
+  "cedil",
+  "cent",
+  "copy",
+  "curren",
+  "deg",
+  "divide",
+  "eacute",
+  "ecirc",
+  "egrave",
+  "eth",
+  "euml",
+  "frac12",
+  "frac14",
+  "frac34",
+  "gt",
+  "iacute",
+  "icirc",
+  "iexcl",
+  "igrave",
+  "iquest",
+  "iuml",
+  "laquo",
+  "lt",
+  "macr",
+  "micro",
+  "middot",
+  "nbsp",
+  "not",
+  "ntilde",
+  "oacute",
+  "ocirc",
+  "ograve",
+  "ordf",
+  "ordm",
+  "oslash",
+  "otilde",
+  "ouml",
+  "para",
+  "plusmn",
+  "pound",
+  "quot",
+  "raquo",
+  "reg",
+  "sect",
+  "shy",
+  "sup1",
+  "sup2",
+  "sup3",
+  "szlig",
+  "thorn",
+  "times",
+  "uacute",
+  "ucirc",
+  "ugrave",
+  "uml",
+  "uuml",
+  "yacute",
+  "yen",
+  "yuml"
+];
+
+// ../../node_modules/.pnpm/character-reference-invalid@2.0.1/node_modules/character-reference-invalid/index.js
+var characterReferenceInvalid = {
+  0: "\uFFFD",
+  128: "\u20AC",
+  130: "\u201A",
+  131: "\u0192",
+  132: "\u201E",
+  133: "\u2026",
+  134: "\u2020",
+  135: "\u2021",
+  136: "\u02C6",
+  137: "\u2030",
+  138: "\u0160",
+  139: "\u2039",
+  140: "\u0152",
+  142: "\u017D",
+  145: "\u2018",
+  146: "\u2019",
+  147: "\u201C",
+  148: "\u201D",
+  149: "\u2022",
+  150: "\u2013",
+  151: "\u2014",
+  152: "\u02DC",
+  153: "\u2122",
+  154: "\u0161",
+  155: "\u203A",
+  156: "\u0153",
+  158: "\u017E",
+  159: "\u0178"
+};
+
+// ../../node_modules/.pnpm/is-decimal@2.0.1/node_modules/is-decimal/index.js
+function isDecimal(character) {
+  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
+  return code3 >= 48 && code3 <= 57;
+}
+
+// ../../node_modules/.pnpm/is-hexadecimal@2.0.1/node_modules/is-hexadecimal/index.js
+function isHexadecimal(character) {
+  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
+  return code3 >= 97 && code3 <= 102 || code3 >= 65 && code3 <= 70 || code3 >= 48 && code3 <= 57;
+}
+
+// ../../node_modules/.pnpm/is-alphabetical@2.0.1/node_modules/is-alphabetical/index.js
+function isAlphabetical(character) {
+  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
+  return code3 >= 97 && code3 <= 122 || code3 >= 65 && code3 <= 90;
+}
+
+// ../../node_modules/.pnpm/is-alphanumerical@2.0.1/node_modules/is-alphanumerical/index.js
+function isAlphanumerical(character) {
+  return isAlphabetical(character) || isDecimal(character);
+}
+
+// ../../node_modules/.pnpm/parse-entities@4.0.0/node_modules/parse-entities/lib/index.js
+var fromCharCode = String.fromCharCode;
+var messages = [
+  "",
+  "Named character references must be terminated by a semicolon",
+  "Numeric character references must be terminated by a semicolon",
+  "Named character references cannot be empty",
+  "Numeric character references cannot be empty",
+  "Named character references must be known",
+  "Numeric character references cannot be disallowed",
+  "Numeric character references cannot be outside the permissible Unicode range"
+];
+function parseEntities(value, options = {}) {
+  const additional = typeof options.additional === "string" ? options.additional.charCodeAt(0) : options.additional;
+  const result = [];
+  let index3 = 0;
+  let lines = -1;
+  let queue = "";
+  let point4;
+  let indent2;
+  if (options.position) {
+    if ("start" in options.position || "indent" in options.position) {
+      indent2 = options.position.indent;
+      point4 = options.position.start;
+    } else {
+      point4 = options.position;
+    }
+  }
+  let line = (point4 ? point4.line : 0) || 1;
+  let column = (point4 ? point4.column : 0) || 1;
+  let previous3 = now();
+  let character;
+  index3--;
+  while (++index3 <= value.length) {
+    if (character === 10) {
+      column = (indent2 ? indent2[lines] : 0) || 1;
+    }
+    character = value.charCodeAt(index3);
+    if (character === 38) {
+      const following = value.charCodeAt(index3 + 1);
+      if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
+        queue += fromCharCode(character);
+        column++;
+        continue;
+      }
+      const start3 = index3 + 1;
+      let begin = start3;
+      let end = start3;
+      let type2;
+      if (following === 35) {
+        end = ++begin;
+        const following2 = value.charCodeAt(end);
+        if (following2 === 88 || following2 === 120) {
+          type2 = "hexadecimal";
+          end = ++begin;
+        } else {
+          type2 = "decimal";
+        }
+      } else {
+        type2 = "named";
+      }
+      let characterReferenceCharacters = "";
+      let characterReference2 = "";
+      let characters = "";
+      const test = type2 === "named" ? isAlphanumerical : type2 === "decimal" ? isDecimal : isHexadecimal;
+      end--;
+      while (++end <= value.length) {
+        const following2 = value.charCodeAt(end);
+        if (!test(following2)) {
+          break;
+        }
+        characters += fromCharCode(following2);
+        if (type2 === "named" && characterEntitiesLegacy.includes(characters)) {
+          characterReferenceCharacters = characters;
+          characterReference2 = decodeNamedCharacterReference(characters);
+        }
+      }
+      let terminated = value.charCodeAt(end) === 59;
+      if (terminated) {
+        end++;
+        const namedReference = type2 === "named" ? decodeNamedCharacterReference(characters) : false;
+        if (namedReference) {
+          characterReferenceCharacters = characters;
+          characterReference2 = namedReference;
+        }
+      }
+      let diff = 1 + end - start3;
+      let reference = "";
+      if (!terminated && options.nonTerminated === false) {
+      } else if (!characters) {
+        if (type2 !== "named") {
+          warning(4, diff);
+        }
+      } else if (type2 === "named") {
+        if (terminated && !characterReference2) {
+          warning(5, 1);
+        } else {
+          if (characterReferenceCharacters !== characters) {
+            end = begin + characterReferenceCharacters.length;
+            diff = 1 + end - begin;
+            terminated = false;
+          }
+          if (!terminated) {
+            const reason = characterReferenceCharacters ? 1 : 3;
+            if (options.attribute) {
+              const following2 = value.charCodeAt(end);
+              if (following2 === 61) {
+                warning(reason, diff);
+                characterReference2 = "";
+              } else if (isAlphanumerical(following2)) {
+                characterReference2 = "";
+              } else {
+                warning(reason, diff);
+              }
+            } else {
+              warning(reason, diff);
+            }
+          }
+        }
+        reference = characterReference2;
+      } else {
+        if (!terminated) {
+          warning(2, diff);
+        }
+        let referenceCode = Number.parseInt(characters, type2 === "hexadecimal" ? 16 : 10);
+        if (prohibited(referenceCode)) {
+          warning(7, diff);
+          reference = fromCharCode(65533);
+        } else if (referenceCode in characterReferenceInvalid) {
+          warning(6, diff);
+          reference = characterReferenceInvalid[referenceCode];
+        } else {
+          let output = "";
+          if (disallowed(referenceCode)) {
+            warning(6, diff);
+          }
+          if (referenceCode > 65535) {
+            referenceCode -= 65536;
+            output += fromCharCode(referenceCode >>> (10 & 1023) | 55296);
+            referenceCode = 56320 | referenceCode & 1023;
+          }
+          reference = output + fromCharCode(referenceCode);
+        }
+      }
+      if (reference) {
+        flush();
+        previous3 = now();
+        index3 = end - 1;
+        column += end - start3 + 1;
+        result.push(reference);
+        const next = now();
+        next.offset++;
+        if (options.reference) {
+          options.reference.call(options.referenceContext, reference, { start: previous3, end: next }, value.slice(start3 - 1, end));
+        }
+        previous3 = next;
+      } else {
+        characters = value.slice(start3 - 1, end);
+        queue += characters;
+        column += characters.length;
+        index3 = end - 1;
+      }
+    } else {
+      if (character === 10) {
+        line++;
+        lines++;
+        column = 0;
+      }
+      if (Number.isNaN(character)) {
+        flush();
+      } else {
+        queue += fromCharCode(character);
+        column++;
+      }
+    }
+  }
+  return result.join("");
+  function now() {
+    return {
+      line,
+      column,
+      offset: index3 + ((point4 ? point4.offset : 0) || 0)
+    };
+  }
+  function warning(code3, offset2) {
+    let position4;
+    if (options.warning) {
+      position4 = now();
+      position4.column += offset2;
+      position4.offset += offset2;
+      options.warning.call(options.warningContext, messages[code3], position4, code3);
+    }
+  }
+  function flush() {
+    if (queue) {
+      result.push(queue);
+      if (options.text) {
+        options.text.call(options.textContext, queue, {
+          start: previous3,
+          end: now()
+        });
+      }
+      queue = "";
+    }
+  }
+}
+function prohibited(code3) {
+  return code3 >= 55296 && code3 <= 57343 || code3 > 1114111;
+}
+function disallowed(code3) {
+  return code3 >= 1 && code3 <= 8 || code3 === 11 || code3 >= 13 && code3 <= 31 || code3 >= 127 && code3 <= 159 || code3 >= 64976 && code3 <= 65007 || (code3 & 65535) === 65535 || (code3 & 65535) === 65534;
+}
+
+// ../../node_modules/.pnpm/stringify-entities@4.0.2/node_modules/stringify-entities/lib/core.js
+function core(value, options) {
+  value = value.replace(options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g, basic);
+  if (options.subset || options.escapeOnly) {
+    return value;
+  }
+  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, basic);
+  function surrogate(pair, index3, all4) {
+    return options.format((pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536, all4.charCodeAt(index3 + 2), options);
+  }
+  function basic(character, index3, all4) {
+    return options.format(character.charCodeAt(0), all4.charCodeAt(index3 + 1), options);
+  }
+}
+function charactersToExpression(subset) {
+  const groups = [];
+  let index3 = -1;
+  while (++index3 < subset.length) {
+    groups.push(subset[index3].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
+  }
+  return new RegExp("(?:" + groups.join("|") + ")", "g");
+}
+
+// ../../node_modules/.pnpm/stringify-entities@4.0.2/node_modules/stringify-entities/lib/util/format-basic.js
+function formatBasic(code3) {
+  return "&#x" + code3.toString(16).toUpperCase() + ";";
+}
+
+// ../../node_modules/.pnpm/stringify-entities@4.0.2/node_modules/stringify-entities/lib/index.js
+function stringifyEntitiesLight(value, options) {
+  return core(value, Object.assign({ format: formatBasic }, options));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.3.0/node_modules/mdast-util-to-markdown/lib/util/track.js
+function track(options_) {
+  const options = options_ || {};
+  const now = options.now || {};
+  let lineShift = options.lineShift || 0;
+  let line = now.line || 1;
+  let column = now.column || 1;
+  return { move, current: current2, shift };
+  function current2() {
+    return { now: { line, column }, lineShift };
+  }
+  function shift(value) {
+    lineShift += value;
+  }
+  function move(value = "") {
+    const chunks = value.split(/\r?\n|\r/g);
+    const tail = chunks[chunks.length - 1];
+    line += chunks.length - 1;
+    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
+    return value;
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.3.0/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
+function containerFlow(parent, context, safeOptions) {
+  const indexStack = context.indexStack;
+  const children = parent.children || [];
+  const tracker = track(safeOptions);
+  const results = [];
+  let index3 = -1;
+  indexStack.push(-1);
+  while (++index3 < children.length) {
+    const child = children[index3];
+    indexStack[indexStack.length - 1] = index3;
+    results.push(tracker.move(context.handle(child, parent, context, __spreadValues({
+      before: "\n",
+      after: "\n"
+    }, tracker.current()))));
+    if (child.type !== "list") {
+      context.bulletLastUsed = void 0;
+    }
+    if (index3 < children.length - 1) {
+      results.push(tracker.move(between(child, children[index3 + 1])));
+    }
+  }
+  indexStack.pop();
+  return results.join("");
+  function between(left, right) {
+    let index4 = context.join.length;
+    while (index4--) {
+      const result = context.join[index4](left, right, parent, context);
+      if (result === true || result === 1) {
+        break;
+      }
+      if (typeof result === "number") {
+        return "\n".repeat(1 + result);
+      }
+      if (result === false) {
+        return "\n\n<!---->\n\n";
+      }
+    }
+    return "\n\n";
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.3.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
+function containerPhrasing(parent, context, safeOptions) {
+  const indexStack = context.indexStack;
+  const children = parent.children || [];
+  const results = [];
+  let index3 = -1;
+  let before = safeOptions.before;
+  indexStack.push(-1);
+  let tracker = track(safeOptions);
+  while (++index3 < children.length) {
+    const child = children[index3];
+    let after;
+    indexStack[indexStack.length - 1] = index3;
+    if (index3 + 1 < children.length) {
+      let handle = context.handle.handlers[children[index3 + 1].type];
+      if (handle && handle.peek)
+        handle = handle.peek;
+      after = handle ? handle(children[index3 + 1], parent, context, __spreadValues({
+        before: "",
+        after: ""
+      }, tracker.current())).charAt(0) : "";
+    } else {
+      after = safeOptions.after;
+    }
+    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
+      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
+      before = " ";
+      tracker = track(safeOptions);
+      tracker.move(results.join(""));
+    }
+    results.push(tracker.move(context.handle(child, parent, context, __spreadProps(__spreadValues({}, tracker.current()), {
+      before,
+      after
+    }))));
+    before = results[results.length - 1].slice(-1);
+  }
+  indexStack.pop();
+  return results.join("");
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.3.0/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
+var eol = /\r?\n|\r/g;
+function indentLines(value, map2) {
+  const result = [];
+  let start3 = 0;
+  let line = 0;
+  let match;
+  while (match = eol.exec(value)) {
+    one3(value.slice(start3, match.index));
+    result.push(match[0]);
+    start3 = match.index + match[0].length;
+    line++;
+  }
+  one3(value.slice(start3));
+  return result.join("");
+  function one3(value2) {
+    result.push(map2(value2, line, !value2));
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-mdx-jsx@2.0.1/node_modules/mdast-util-mdx-jsx/lib/index.js
+function mdxJsxFromMarkdown() {
+  return {
+    canContainEols: ["mdxJsxTextElement"],
+    enter: {
+      mdxJsxFlowTag: enterMdxJsxTag,
+      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,
+      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,
+      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
+      mdxJsxFlowTagAttributeValueLiteral: buffer2,
+      mdxJsxFlowTagAttributeValueExpression: buffer2,
+      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,
+      mdxJsxTextTag: enterMdxJsxTag,
+      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,
+      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,
+      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
+      mdxJsxTextTagAttributeValueLiteral: buffer2,
+      mdxJsxTextTagAttributeValueExpression: buffer2,
+      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker
+    },
+    exit: {
+      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,
+      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,
+      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,
+      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,
+      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
+      mdxJsxFlowTagExpressionAttributeValue: data2,
+      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
+      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
+      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
+      mdxJsxFlowTagAttributeValueLiteralValue: data2,
+      mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
+      mdxJsxFlowTagAttributeValueExpressionValue: data2,
+      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
+      mdxJsxFlowTag: exitMdxJsxTag,
+      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,
+      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,
+      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,
+      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,
+      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
+      mdxJsxTextTagExpressionAttributeValue: data2,
+      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
+      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
+      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
+      mdxJsxTextTagAttributeValueLiteralValue: data2,
+      mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
+      mdxJsxTextTagAttributeValueExpressionValue: data2,
+      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
+      mdxJsxTextTag: exitMdxJsxTag
+    }
+  };
+  function buffer2() {
+    this.buffer();
+  }
+  function data2(token) {
+    this.config.enter.data.call(this, token);
+    this.config.exit.data.call(this, token);
+  }
+  function enterMdxJsxTag(token) {
+    const tag = { name: null, attributes: [], start: token.start, end: token.end };
+    if (!this.getData("mdxJsxTagStack"))
+      this.setData("mdxJsxTagStack", []);
+    this.setData("mdxJsxTag", tag);
+    this.buffer();
+  }
+  function enterMdxJsxTagClosingMarker(token) {
+    const stack = this.getData("mdxJsxTagStack");
+    if (stack.length === 0) {
+      throw new VFileMessage("Unexpected closing slash `/` in tag, expected an open tag first", { start: token.start, end: token.end }, "mdast-util-mdx-jsx:unexpected-closing-slash");
+    }
+  }
+  function enterMdxJsxTagAnyAttribute(token) {
+    const tag = this.getData("mdxJsxTag");
+    if (tag.close) {
+      throw new VFileMessage("Unexpected attribute in closing tag, expected the end of the tag", { start: token.start, end: token.end }, "mdast-util-mdx-jsx:unexpected-attribute");
+    }
+  }
+  function enterMdxJsxTagSelfClosingMarker(token) {
+    const tag = this.getData("mdxJsxTag");
+    if (tag.close) {
+      throw new VFileMessage("Unexpected self-closing slash `/` in closing tag, expected the end of the tag", { start: token.start, end: token.end }, "mdast-util-mdx-jsx:unexpected-self-closing-slash");
+    }
+  }
+  function exitMdxJsxTagClosingMarker() {
+    const tag = this.getData("mdxJsxTag");
+    tag.close = true;
+  }
+  function exitMdxJsxTagNamePrimary(token) {
+    const tag = this.getData("mdxJsxTag");
+    tag.name = this.sliceSerialize(token);
+  }
+  function exitMdxJsxTagNameMember(token) {
+    const tag = this.getData("mdxJsxTag");
+    tag.name += "." + this.sliceSerialize(token);
+  }
+  function exitMdxJsxTagNameLocal(token) {
+    const tag = this.getData("mdxJsxTag");
+    tag.name += ":" + this.sliceSerialize(token);
+  }
+  function enterMdxJsxTagAttribute(token) {
+    const tag = this.getData("mdxJsxTag");
+    enterMdxJsxTagAnyAttribute.call(this, token);
+    tag.attributes.push({ type: "mdxJsxAttribute", name: "", value: null });
+  }
+  function enterMdxJsxTagExpressionAttribute(token) {
+    const tag = this.getData("mdxJsxTag");
+    enterMdxJsxTagAnyAttribute.call(this, token);
+    tag.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" });
+    this.buffer();
+  }
+  function exitMdxJsxTagExpressionAttribute(token) {
+    const tag = this.getData("mdxJsxTag");
+    const tail = tag.attributes[tag.attributes.length - 1];
+    const estree = token.estree;
+    tail.value = this.resume();
+    if (estree) {
+      tail.data = { estree };
+    }
+  }
+  function exitMdxJsxTagAttributeNamePrimary(token) {
+    const tag = this.getData("mdxJsxTag");
+    const node = tag.attributes[tag.attributes.length - 1];
+    node.name = this.sliceSerialize(token);
+  }
+  function exitMdxJsxTagAttributeNameLocal(token) {
+    const tag = this.getData("mdxJsxTag");
+    const node = tag.attributes[tag.attributes.length - 1];
+    node.name += ":" + this.sliceSerialize(token);
+  }
+  function exitMdxJsxTagAttributeValueLiteral() {
+    const tag = this.getData("mdxJsxTag");
+    tag.attributes[tag.attributes.length - 1].value = parseEntities(this.resume(), { nonTerminated: false });
+  }
+  function exitMdxJsxTagAttributeValueExpression(token) {
+    const tag = this.getData("mdxJsxTag");
+    const tail = tag.attributes[tag.attributes.length - 1];
+    const node = { type: "mdxJsxAttributeValueExpression", value: this.resume() };
+    const estree = token.estree;
+    if (estree) {
+      node.data = { estree };
+    }
+    tail.value = node;
+  }
+  function exitMdxJsxTagSelfClosingMarker() {
+    const tag = this.getData("mdxJsxTag");
+    tag.selfClosing = true;
+  }
+  function exitMdxJsxTag(token) {
+    const tag = this.getData("mdxJsxTag");
+    const stack = this.getData("mdxJsxTagStack");
+    const tail = stack[stack.length - 1];
+    if (tag.close && tail.name !== tag.name) {
+      throw new VFileMessage("Unexpected closing tag `" + serializeAbbreviatedTag(tag) + "`, expected corresponding closing tag for `" + serializeAbbreviatedTag(tail) + "` (" + stringifyPosition(tail) + ")", { start: token.start, end: token.end }, "mdast-util-mdx-jsx:end-tag-mismatch");
+    }
+    this.resume();
+    if (tag.close) {
+      stack.pop();
+    } else {
+      this.enter({
+        type: token.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
+        name: tag.name,
+        attributes: tag.attributes,
+        children: []
+      }, token, onErrorRightIsTag);
+    }
+    if (tag.selfClosing || tag.close) {
+      this.exit(token, onErrorLeftIsTag);
+    } else {
+      stack.push(tag);
+    }
+  }
+  function onErrorRightIsTag(closing, open) {
+    const tag = this.getData("mdxJsxTag");
+    const place = closing ? " before the end of `" + closing.type + "`" : "";
+    const position4 = closing ? { start: closing.start, end: closing.end } : void 0;
+    throw new VFileMessage("Expected a closing tag for `" + serializeAbbreviatedTag(tag) + "` (" + stringifyPosition({ start: open.start, end: open.end }) + ")" + place, position4, "mdast-util-mdx-jsx:end-tag-mismatch");
+  }
+  function onErrorLeftIsTag(a, b) {
+    const tag = this.getData("mdxJsxTag");
+    throw new VFileMessage("Expected the closing tag `" + serializeAbbreviatedTag(tag) + "` either after the end of `" + b.type + "` (" + stringifyPosition(b.end) + ") or another opening tag after the start of `" + b.type + "` (" + stringifyPosition(b.start) + ")", { start: a.start, end: a.end }, "mdast-util-mdx-jsx:end-tag-mismatch");
+  }
+  function serializeAbbreviatedTag(tag) {
+    return "<" + (tag.close ? "/" : "") + (tag.name || "") + ">";
+  }
+}
+function mdxJsxToMarkdown(options = {}) {
+  const {
+    quote = '"',
+    quoteSmart,
+    tightSelfClosing,
+    printWidth = Number.POSITIVE_INFINITY
+  } = options;
+  const alternative = quote === '"' ? "'" : '"';
+  if (quote !== '"' && quote !== "'") {
+    throw new Error("Cannot serialize attribute values with `" + quote + "` for `options.quote`, expected `\"`, or `'`");
+  }
+  mdxElement.peek = peekElement;
+  return {
+    handlers: {
+      mdxJsxFlowElement: mdxElement,
+      mdxJsxTextElement: mdxElement
+    },
+    unsafe: [
+      { character: "<", inConstruct: ["phrasing"] },
+      { atBreak: true, character: "<" }
+    ],
+    fences: true,
+    resourceLink: true
+  };
+  function mdxElement(node, _, context, safeOptions) {
+    const tracker = track(safeOptions);
+    const selfClosing = node.name && (!node.children || node.children.length === 0);
+    const exit3 = context.enter(node.type);
+    let index3 = -1;
+    const serializedAttributes = [];
+    let value = tracker.move("<" + (node.name || ""));
+    if (node.attributes && node.attributes.length > 0) {
+      if (!node.name) {
+        throw new Error("Cannot serialize fragment w/ attributes");
+      }
+      while (++index3 < node.attributes.length) {
+        const attribute = node.attributes[index3];
+        let result;
+        if (attribute.type === "mdxJsxExpressionAttribute") {
+          result = "{" + (attribute.value || "") + "}";
+        } else {
+          if (!attribute.name) {
+            throw new Error("Cannot serialize attribute w/o name");
+          }
+          const value2 = attribute.value;
+          const left = attribute.name;
+          let right = "";
+          if (value2 === void 0 || value2 === null) {
+          } else if (typeof value2 === "object") {
+            right = "{" + (value2.value || "") + "}";
+          } else {
+            const appliedQuote = quoteSmart && ccount(value2, quote) > ccount(value2, alternative) ? alternative : quote;
+            right = appliedQuote + stringifyEntitiesLight(value2, { subset: [appliedQuote] }) + appliedQuote;
+          }
+          result = left + (right ? "=" : "") + right;
+        }
+        serializedAttributes.push(result);
+      }
+    }
+    let attributesOnTheirOwnLine = false;
+    const attributesOnOneLine = serializedAttributes.join(" ");
+    if (node.type === "mdxJsxFlowElement" && (/\r?\n|\r/.test(attributesOnOneLine) || tracker.current().now.column + attributesOnOneLine.length + (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)) {
+      attributesOnTheirOwnLine = true;
+    }
+    if (attributesOnTheirOwnLine) {
+      value += tracker.move("\n" + indentLines(serializedAttributes.join("\n"), map2));
+    } else if (attributesOnOneLine) {
+      value += tracker.move(" " + attributesOnOneLine);
+    }
+    if (attributesOnTheirOwnLine) {
+      value += tracker.move("\n");
+    }
+    if (selfClosing) {
+      value += tracker.move((tightSelfClosing || attributesOnTheirOwnLine ? "" : " ") + "/");
+    }
+    value += tracker.move(">");
+    if (node.children && node.children.length > 0) {
+      if (node.type === "mdxJsxFlowElement") {
+        tracker.shift(2);
+        value += tracker.move("\n");
+        value += tracker.move(indentLines(containerFlow(node, context, tracker.current()), map2));
+        value += tracker.move("\n");
+      } else {
+        value += tracker.move(containerPhrasing(node, context, __spreadProps(__spreadValues({}, tracker.current()), {
+          before: "<",
+          after: ">"
+        })));
+      }
+    }
+    if (!selfClosing) {
+      value += tracker.move("</" + (node.name || "") + ">");
+    }
+    exit3();
+    return value;
+  }
+  function map2(line, _, blank) {
+    return (blank ? "" : "  ") + line;
+  }
+  function peekElement() {
+    return "<";
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-mdxjs-esm@1.1.1/node_modules/mdast-util-mdxjs-esm/index.js
+var mdxjsEsmFromMarkdown = {
+  enter: { mdxjsEsm: enterMdxjsEsm },
+  exit: { mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData }
+};
+var mdxjsEsmToMarkdown = { handlers: { mdxjsEsm: handleMdxjsEsm } };
+function enterMdxjsEsm(token) {
+  this.enter({ type: "mdxjsEsm", value: "" }, token);
+  this.buffer();
+}
+function exitMdxjsEsm(token) {
+  const value = this.resume();
+  const node = this.exit(token);
+  const estree = token.estree;
+  node.value = value;
+  if (estree) {
+    node.data = { estree };
+  }
+}
+function exitMdxjsEsmData(token) {
+  this.config.enter.data.call(this, token);
+  this.config.exit.data.call(this, token);
+}
+function handleMdxjsEsm(node) {
+  return node.value || "";
+}
+
+// ../../node_modules/.pnpm/mdast-util-mdx@2.0.0/node_modules/mdast-util-mdx/index.js
+function mdxFromMarkdown() {
+  return [mdxExpressionFromMarkdown, mdxJsxFromMarkdown(), mdxjsEsmFromMarkdown];
+}
+function mdxToMarkdown(options) {
+  return {
+    extensions: [
+      mdxExpressionToMarkdown,
+      mdxJsxToMarkdown(options),
+      mdxjsEsmToMarkdown
+    ]
+  };
+}
+
+// ../../node_modules/.pnpm/remark-mdx@2.0.0/node_modules/remark-mdx/index.js
+function remarkMdx(options = {}) {
+  const data2 = this.data();
+  add("micromarkExtensions", mdxjs(options));
+  add("fromMarkdownExtensions", mdxFromMarkdown());
+  add("toMarkdownExtensions", mdxToMarkdown(options));
+  function add(field, value) {
+    const list3 = data2[field] ? data2[field] : data2[field] = [];
+    list3.push(value);
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-string@3.1.0/node_modules/mdast-util-to-string/index.js
+function toString2(node, options) {
+  var { includeImageAlt = true } = options || {};
+  return one(node, includeImageAlt);
+}
+function one(node, includeImageAlt) {
+  return node && typeof node === "object" && (node.value || (includeImageAlt ? node.alt : "") || "children" in node && all(node.children, includeImageAlt) || Array.isArray(node) && all(node, includeImageAlt)) || "";
+}
+function all(values, includeImageAlt) {
+  var result = [];
+  var index3 = -1;
+  while (++index3 < values.length) {
+    result[index3] = one(values[index3], includeImageAlt);
+  }
+  return result.join("");
+}
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/initialize/content.js
+var content2 = {
+  tokenize: initializeContent
+};
+function initializeContent(effects) {
+  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
+  let previous3;
+  return contentStart;
+  function afterContentStartConstruct(code3) {
+    if (code3 === null) {
+      effects.consume(code3);
+      return;
+    }
+    effects.enter("lineEnding");
+    effects.consume(code3);
+    effects.exit("lineEnding");
+    return factorySpace(effects, contentStart, "linePrefix");
+  }
+  function paragraphInitial(code3) {
+    effects.enter("paragraph");
+    return lineStart(code3);
+  }
+  function lineStart(code3) {
+    const token = effects.enter("chunkText", {
+      contentType: "text",
+      previous: previous3
+    });
+    if (previous3) {
+      previous3.next = token;
+    }
+    previous3 = token;
+    return data2(code3);
+  }
+  function data2(code3) {
+    if (code3 === null) {
+      effects.exit("chunkText");
+      effects.exit("paragraph");
+      effects.consume(code3);
+      return;
+    }
+    if (markdownLineEnding(code3)) {
+      effects.consume(code3);
+      effects.exit("chunkText");
+      return lineStart;
+    }
+    effects.consume(code3);
+    return data2;
+  }
+}
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/initialize/document.js
+var document2 = {
+  tokenize: initializeDocument
+};
+var containerConstruct = {
+  tokenize: tokenizeContainer
+};
+function initializeDocument(effects) {
+  const self2 = this;
+  const stack = [];
+  let continued = 0;
+  let childFlow;
+  let childToken;
+  let lineStartOffset;
+  return start3;
+  function start3(code3) {
+    if (continued < stack.length) {
+      const item = stack[continued];
+      self2.containerState = item[1];
+      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code3);
+    }
+    return checkNewContainers(code3);
+  }
+  function documentContinue(code3) {
+    continued++;
+    if (self2.containerState._closeFlow) {
+      self2.containerState._closeFlow = void 0;
+      if (childFlow) {
+        closeFlow();
+      }
+      const indexBeforeExits = self2.events.length;
+      let indexBeforeFlow = indexBeforeExits;
+      let point4;
+      while (indexBeforeFlow--) {
+        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
+          point4 = self2.events[indexBeforeFlow][1].end;
+          break;
+        }
+      }
+      exitContainers(continued);
+      let index3 = indexBeforeExits;
+      while (index3 < self2.events.length) {
+        self2.events[index3][1].end = Object.assign({}, point4);
+        index3++;
+      }
+      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
+      self2.events.length = index3;
+      return checkNewContainers(code3);
+    }
+    return start3(code3);
+  }
+  function checkNewContainers(code3) {
+    if (continued === stack.length) {
+      if (!childFlow) {
+        return documentContinued(code3);
+      }
+      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
+        return flowStart(code3);
+      }
+      self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
+    }
+    self2.containerState = {};
+    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code3);
+  }
+  function thereIsANewContainer(code3) {
+    if (childFlow)
+      closeFlow();
+    exitContainers(continued);
+    return documentContinued(code3);
+  }
+  function thereIsNoNewContainer(code3) {
+    self2.parser.lazy[self2.now().line] = continued !== stack.length;
+    lineStartOffset = self2.now().offset;
+    return flowStart(code3);
+  }
+  function documentContinued(code3) {
+    self2.containerState = {};
+    return effects.attempt(containerConstruct, containerContinue, flowStart)(code3);
+  }
+  function containerContinue(code3) {
+    continued++;
+    stack.push([self2.currentConstruct, self2.containerState]);
+    return documentContinued(code3);
+  }
+  function flowStart(code3) {
+    if (code3 === null) {
+      if (childFlow)
+        closeFlow();
+      exitContainers(0);
+      effects.consume(code3);
+      return;
+    }
+    childFlow = childFlow || self2.parser.flow(self2.now());
+    effects.enter("chunkFlow", {
+      contentType: "flow",
+      previous: childToken,
+      _tokenizer: childFlow
+    });
+    return flowContinue(code3);
+  }
+  function flowContinue(code3) {
+    if (code3 === null) {
+      writeToChild(effects.exit("chunkFlow"), true);
+      exitContainers(0);
+      effects.consume(code3);
+      return;
+    }
+    if (markdownLineEnding(code3)) {
+      effects.consume(code3);
+      writeToChild(effects.exit("chunkFlow"));
+      continued = 0;
+      self2.interrupt = void 0;
+      return start3;
+    }
+    effects.consume(code3);
+    return flowContinue;
+  }
+  function writeToChild(token, eof) {
+    const stream = self2.sliceStream(token);
+    if (eof)
+      stream.push(null);
+    token.previous = childToken;
+    if (childToken)
+      childToken.next = token;
+    childToken = token;
+    childFlow.defineSkip(token.start);
+    childFlow.write(stream);
+    if (self2.parser.lazy[token.start.line]) {
+      let index3 = childFlow.events.length;
+      while (index3--) {
+        if (childFlow.events[index3][1].start.offset < lineStartOffset && (!childFlow.events[index3][1].end || childFlow.events[index3][1].end.offset > lineStartOffset)) {
+          return;
+        }
+      }
+      const indexBeforeExits = self2.events.length;
+      let indexBeforeFlow = indexBeforeExits;
+      let seen;
+      let point4;
+      while (indexBeforeFlow--) {
+        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
+          if (seen) {
+            point4 = self2.events[indexBeforeFlow][1].end;
+            break;
+          }
+          seen = true;
+        }
+      }
+      exitContainers(continued);
+      index3 = indexBeforeExits;
+      while (index3 < self2.events.length) {
+        self2.events[index3][1].end = Object.assign({}, point4);
+        index3++;
+      }
+      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
+      self2.events.length = index3;
+    }
+  }
+  function exitContainers(size) {
+    let index3 = stack.length;
+    while (index3-- > size) {
+      const entry = stack[index3];
+      self2.containerState = entry[1];
+      entry[0].exit.call(self2, effects);
+    }
+    stack.length = size;
+  }
+  function closeFlow() {
+    childFlow.write([null]);
+    childToken = void 0;
+    childFlow = void 0;
+    self2.containerState._closeFlow = void 0;
+  }
+}
+function tokenizeContainer(effects, ok3, nok) {
+  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok3, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
+}
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/initialize/flow.js
+var flow = {
+  tokenize: initializeFlow
+};
+function initializeFlow(effects) {
+  const self2 = this;
+  const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content, afterConstruct)), "linePrefix")));
+  return initial;
+  function atBlankEnding(code3) {
+    if (code3 === null) {
+      effects.consume(code3);
+      return;
+    }
+    effects.enter("lineEndingBlank");
+    effects.consume(code3);
+    effects.exit("lineEndingBlank");
+    self2.currentConstruct = void 0;
+    return initial;
+  }
+  function afterConstruct(code3) {
+    if (code3 === null) {
+      effects.consume(code3);
+      return;
+    }
+    effects.enter("lineEnding");
+    effects.consume(code3);
+    effects.exit("lineEnding");
+    self2.currentConstruct = void 0;
+    return initial;
+  }
+}
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/initialize/text.js
+var resolver = {
+  resolveAll: createResolver()
+};
+var string = initializeFactory("string");
+var text = initializeFactory("text");
+function initializeFactory(field) {
+  return {
+    tokenize: initializeText,
+    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
+  };
+  function initializeText(effects) {
+    const self2 = this;
+    const constructs2 = this.parser.constructs[field];
+    const text7 = effects.attempt(constructs2, start3, notText);
+    return start3;
+    function start3(code3) {
+      return atBreak(code3) ? text7(code3) : notText(code3);
+    }
+    function notText(code3) {
+      if (code3 === null) {
+        effects.consume(code3);
+        return;
+      }
+      effects.enter("data");
+      effects.consume(code3);
+      return data2;
+    }
+    function data2(code3) {
+      if (atBreak(code3)) {
+        effects.exit("data");
+        return text7(code3);
+      }
+      effects.consume(code3);
+      return data2;
+    }
+    function atBreak(code3) {
+      if (code3 === null) {
+        return true;
+      }
+      const list3 = constructs2[code3];
+      let index3 = -1;
+      if (list3) {
+        while (++index3 < list3.length) {
+          const item = list3[index3];
+          if (!item.previous || item.previous.call(self2, self2.previous)) {
+            return true;
+          }
+        }
+      }
+      return false;
+    }
+  }
+}
+function createResolver(extraResolver) {
+  return resolveAllText;
+  function resolveAllText(events, context) {
+    let index3 = -1;
+    let enter;
+    while (++index3 <= events.length) {
+      if (enter === void 0) {
+        if (events[index3] && events[index3][1].type === "data") {
+          enter = index3;
+          index3++;
+        }
+      } else if (!events[index3] || events[index3][1].type !== "data") {
+        if (index3 !== enter + 2) {
+          events[enter][1].end = events[index3 - 1][1].end;
+          events.splice(enter + 2, index3 - enter - 2);
+          index3 = enter + 2;
+        }
+        enter = void 0;
+      }
+    }
+    return extraResolver ? extraResolver(events, context) : events;
+  }
+}
+function resolveAllLineSuffixes(events, context) {
+  let eventIndex = 0;
+  while (++eventIndex <= events.length) {
+    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
+      const data2 = events[eventIndex - 1][1];
+      const chunks = context.sliceStream(data2);
+      let index3 = chunks.length;
+      let bufferIndex = -1;
+      let size = 0;
+      let tabs;
+      while (index3--) {
+        const chunk = chunks[index3];
+        if (typeof chunk === "string") {
+          bufferIndex = chunk.length;
+          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
+            size++;
+            bufferIndex--;
+          }
+          if (bufferIndex)
+            break;
+          bufferIndex = -1;
+        } else if (chunk === -2) {
+          tabs = true;
+          size++;
+        } else if (chunk === -1) {
+        } else {
+          index3++;
+          break;
+        }
+      }
+      if (size) {
+        const token = {
+          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
+          start: {
+            line: data2.end.line,
+            column: data2.end.column - size,
+            offset: data2.end.offset - size,
+            _index: data2.start._index + index3,
+            _bufferIndex: index3 ? bufferIndex : data2.start._bufferIndex + bufferIndex
+          },
+          end: Object.assign({}, data2.end)
+        };
+        data2.end = Object.assign({}, token.start);
+        if (data2.start.offset === data2.end.offset) {
+          Object.assign(data2, token);
+        } else {
+          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
+          eventIndex += 2;
+        }
+      }
+      eventIndex++;
+    }
+  }
+  return events;
+}
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/create-tokenizer.js
+function createTokenizer(parser2, initialize, from) {
+  let point4 = Object.assign(from ? Object.assign({}, from) : {
+    line: 1,
+    column: 1,
+    offset: 0
+  }, {
+    _index: 0,
+    _bufferIndex: -1
+  });
+  const columnStart = {};
+  const resolveAllConstructs = [];
+  let chunks = [];
+  let stack = [];
+  let consumed = true;
+  const effects = {
+    consume,
+    enter,
+    exit: exit3,
+    attempt: constructFactory(onsuccessfulconstruct),
+    check: constructFactory(onsuccessfulcheck),
+    interrupt: constructFactory(onsuccessfulcheck, {
+      interrupt: true
+    })
+  };
+  const context = {
+    previous: null,
+    code: null,
+    containerState: {},
+    events: [],
+    parser: parser2,
+    sliceStream,
+    sliceSerialize,
+    now,
+    defineSkip,
+    write
+  };
+  let state = initialize.tokenize.call(context, effects);
+  let expectedCode;
+  if (initialize.resolveAll) {
+    resolveAllConstructs.push(initialize);
+  }
+  return context;
+  function write(slice2) {
+    chunks = push(chunks, slice2);
+    main();
+    if (chunks[chunks.length - 1] !== null) {
+      return [];
+    }
+    addResult(initialize, 0);
+    context.events = resolveAll(resolveAllConstructs, context.events, context);
+    return context.events;
+  }
+  function sliceSerialize(token, expandTabs) {
+    return serializeChunks(sliceStream(token), expandTabs);
+  }
+  function sliceStream(token) {
+    return sliceChunks(chunks, token);
+  }
+  function now() {
+    return Object.assign({}, point4);
+  }
+  function defineSkip(value) {
+    columnStart[value.line] = value.column;
+    accountForPotentialSkip();
+  }
+  function main() {
+    let chunkIndex;
+    while (point4._index < chunks.length) {
+      const chunk = chunks[point4._index];
+      if (typeof chunk === "string") {
+        chunkIndex = point4._index;
+        if (point4._bufferIndex < 0) {
+          point4._bufferIndex = 0;
+        }
+        while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
+          go(chunk.charCodeAt(point4._bufferIndex));
+        }
+      } else {
+        go(chunk);
+      }
+    }
+  }
+  function go(code3) {
+    consumed = void 0;
+    expectedCode = code3;
+    state = state(code3);
+  }
+  function consume(code3) {
+    if (markdownLineEnding(code3)) {
+      point4.line++;
+      point4.column = 1;
+      point4.offset += code3 === -3 ? 2 : 1;
+      accountForPotentialSkip();
+    } else if (code3 !== -1) {
+      point4.column++;
+      point4.offset++;
+    }
+    if (point4._bufferIndex < 0) {
+      point4._index++;
+    } else {
+      point4._bufferIndex++;
+      if (point4._bufferIndex === chunks[point4._index].length) {
+        point4._bufferIndex = -1;
+        point4._index++;
+      }
+    }
+    context.previous = code3;
+    consumed = true;
+  }
+  function enter(type2, fields) {
+    const token = fields || {};
+    token.type = type2;
+    token.start = now();
+    context.events.push(["enter", token, context]);
+    stack.push(token);
+    return token;
+  }
+  function exit3(type2) {
+    const token = stack.pop();
+    token.end = now();
+    context.events.push(["exit", token, context]);
+    return token;
+  }
+  function onsuccessfulconstruct(construct, info) {
+    addResult(construct, info.from);
+  }
+  function onsuccessfulcheck(_, info) {
+    info.restore();
+  }
+  function constructFactory(onreturn, fields) {
+    return hook;
+    function hook(constructs2, returnState, bogusState) {
+      let listOfConstructs;
+      let constructIndex;
+      let currentConstruct;
+      let info;
+      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
+      function handleMapOfConstructs(map2) {
+        return start3;
+        function start3(code3) {
+          const def = code3 !== null && map2[code3];
+          const all4 = code3 !== null && map2.null;
+          const list3 = [
+            ...Array.isArray(def) ? def : def ? [def] : [],
+            ...Array.isArray(all4) ? all4 : all4 ? [all4] : []
+          ];
+          return handleListOfConstructs(list3)(code3);
+        }
+      }
+      function handleListOfConstructs(list3) {
+        listOfConstructs = list3;
+        constructIndex = 0;
+        if (list3.length === 0) {
+          return bogusState;
+        }
+        return handleConstruct(list3[constructIndex]);
+      }
+      function handleConstruct(construct) {
+        return start3;
+        function start3(code3) {
+          info = store();
+          currentConstruct = construct;
+          if (!construct.partial) {
+            context.currentConstruct = construct;
+          }
+          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
+            return nok(code3);
+          }
+          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok3, nok)(code3);
+        }
+      }
+      function ok3(code3) {
+        consumed = true;
+        onreturn(currentConstruct, info);
+        return returnState;
+      }
+      function nok(code3) {
+        consumed = true;
+        info.restore();
+        if (++constructIndex < listOfConstructs.length) {
+          return handleConstruct(listOfConstructs[constructIndex]);
+        }
+        return bogusState;
+      }
+    }
+  }
+  function addResult(construct, from2) {
+    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
+      resolveAllConstructs.push(construct);
+    }
+    if (construct.resolve) {
+      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
+    }
+    if (construct.resolveTo) {
+      context.events = construct.resolveTo(context.events, context);
+    }
+  }
+  function store() {
+    const startPoint = now();
+    const startPrevious = context.previous;
+    const startCurrentConstruct = context.currentConstruct;
+    const startEventsIndex = context.events.length;
+    const startStack = Array.from(stack);
+    return {
+      restore,
+      from: startEventsIndex
+    };
+    function restore() {
+      point4 = startPoint;
+      context.previous = startPrevious;
+      context.currentConstruct = startCurrentConstruct;
+      context.events.length = startEventsIndex;
+      stack = startStack;
+      accountForPotentialSkip();
+    }
+  }
+  function accountForPotentialSkip() {
+    if (point4.line in columnStart && point4.column < 2) {
+      point4.column = columnStart[point4.line];
+      point4.offset += columnStart[point4.line] - 1;
+    }
+  }
+}
+function sliceChunks(chunks, token) {
+  const startIndex = token.start._index;
+  const startBufferIndex = token.start._bufferIndex;
+  const endIndex = token.end._index;
+  const endBufferIndex = token.end._bufferIndex;
+  let view;
+  if (startIndex === endIndex) {
+    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
+  } else {
+    view = chunks.slice(startIndex, endIndex);
+    if (startBufferIndex > -1) {
+      view[0] = view[0].slice(startBufferIndex);
+    }
+    if (endBufferIndex > 0) {
+      view.push(chunks[endIndex].slice(0, endBufferIndex));
+    }
+  }
+  return view;
+}
+function serializeChunks(chunks, expandTabs) {
+  let index3 = -1;
+  const result = [];
+  let atTab;
+  while (++index3 < chunks.length) {
+    const chunk = chunks[index3];
+    let value;
+    if (typeof chunk === "string") {
+      value = chunk;
+    } else
+      switch (chunk) {
+        case -5: {
+          value = "\r";
+          break;
+        }
+        case -4: {
+          value = "\n";
+          break;
+        }
+        case -3: {
+          value = "\r\n";
+          break;
+        }
+        case -2: {
+          value = expandTabs ? " " : "	";
+          break;
+        }
+        case -1: {
+          if (!expandTabs && atTab)
+            continue;
+          value = " ";
+          break;
+        }
+        default: {
+          value = String.fromCharCode(chunk);
+        }
+      }
+    atTab = chunk === -2;
+    result.push(value);
+  }
+  return result.join("");
+}
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/constructs.js
+var constructs_exports = {};
+__export(constructs_exports, {
+  attentionMarkers: () => attentionMarkers,
+  contentInitial: () => contentInitial,
+  disable: () => disable,
+  document: () => document3,
+  flow: () => flow2,
+  flowInitial: () => flowInitial,
+  insideSpan: () => insideSpan,
+  string: () => string2,
+  text: () => text2
+});
+var document3 = {
+  [42]: list,
+  [43]: list,
+  [45]: list,
+  [48]: list,
+  [49]: list,
+  [50]: list,
+  [51]: list,
+  [52]: list,
+  [53]: list,
+  [54]: list,
+  [55]: list,
+  [56]: list,
+  [57]: list,
+  [62]: blockQuote
+};
+var contentInitial = {
+  [91]: definition
+};
+var flowInitial = {
+  [-2]: codeIndented,
+  [-1]: codeIndented,
+  [32]: codeIndented
+};
+var flow2 = {
+  [35]: headingAtx,
+  [42]: thematicBreak,
+  [45]: [setextUnderline, thematicBreak],
+  [60]: htmlFlow,
+  [61]: setextUnderline,
+  [95]: thematicBreak,
+  [96]: codeFenced,
+  [126]: codeFenced
+};
+var string2 = {
+  [38]: characterReference,
+  [92]: characterEscape
+};
+var text2 = {
+  [-5]: lineEnding,
+  [-4]: lineEnding,
+  [-3]: lineEnding,
+  [33]: labelStartImage,
+  [38]: characterReference,
+  [42]: attention,
+  [60]: [autolink, htmlText],
+  [91]: labelStartLink,
+  [92]: [hardBreakEscape, characterEscape],
+  [93]: labelEnd,
+  [95]: attention,
+  [96]: codeText
+};
+var insideSpan = {
+  null: [attention, resolver]
+};
+var attentionMarkers = {
+  null: [42, 95]
+};
+var disable = {
+  null: []
+};
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/parse.js
+function parse3(options = {}) {
+  const constructs2 = combineExtensions([constructs_exports].concat(options.extensions || []));
+  const parser2 = {
+    defined: [],
+    lazy: {},
+    constructs: constructs2,
+    content: create6(content2),
+    document: create6(document2),
+    flow: create6(flow),
+    string: create6(string),
+    text: create6(text)
+  };
+  return parser2;
+  function create6(initial) {
+    return creator;
+    function creator(from) {
+      return createTokenizer(parser2, initial, from);
+    }
+  }
+}
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/preprocess.js
+var search = /[\0\t\n\r]/g;
+function preprocess() {
+  let column = 1;
+  let buffer2 = "";
+  let start3 = true;
+  let atCarriageReturn;
+  return preprocessor2;
+  function preprocessor2(value, encoding, end) {
+    const chunks = [];
+    let match;
+    let next;
+    let startPosition;
+    let endPosition;
+    let code3;
+    value = buffer2 + value.toString(encoding);
+    startPosition = 0;
+    buffer2 = "";
+    if (start3) {
+      if (value.charCodeAt(0) === 65279) {
+        startPosition++;
+      }
+      start3 = void 0;
+    }
+    while (startPosition < value.length) {
+      search.lastIndex = startPosition;
+      match = search.exec(value);
+      endPosition = match && match.index !== void 0 ? match.index : value.length;
+      code3 = value.charCodeAt(endPosition);
+      if (!match) {
+        buffer2 = value.slice(startPosition);
+        break;
+      }
+      if (code3 === 10 && startPosition === endPosition && atCarriageReturn) {
+        chunks.push(-3);
+        atCarriageReturn = void 0;
+      } else {
+        if (atCarriageReturn) {
+          chunks.push(-5);
+          atCarriageReturn = void 0;
+        }
+        if (startPosition < endPosition) {
+          chunks.push(value.slice(startPosition, endPosition));
+          column += endPosition - startPosition;
+        }
+        switch (code3) {
+          case 0: {
+            chunks.push(65533);
+            column++;
+            break;
+          }
+          case 9: {
+            next = Math.ceil(column / 4) * 4;
+            chunks.push(-2);
+            while (column++ < next)
+              chunks.push(-1);
+            break;
+          }
+          case 10: {
+            chunks.push(-4);
+            column = 1;
+            break;
+          }
+          default: {
+            atCarriageReturn = true;
+            column = 1;
+          }
+        }
+      }
+      startPosition = endPosition + 1;
+    }
+    if (end) {
+      if (atCarriageReturn)
+        chunks.push(-5);
+      if (buffer2)
+        chunks.push(buffer2);
+      chunks.push(null);
+    }
+    return chunks;
+  }
+}
+
+// ../../node_modules/.pnpm/micromark@3.0.10/node_modules/micromark/lib/postprocess.js
+function postprocess(events) {
+  while (!subtokenize(events)) {
+  }
+  return events;
+}
+
+// ../../node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.0.0/node_modules/micromark-util-decode-numeric-character-reference/index.js
+function decodeNumericCharacterReference(value, base3) {
+  const code3 = Number.parseInt(value, base3);
+  if (code3 < 9 || code3 === 11 || code3 > 13 && code3 < 32 || code3 > 126 && code3 < 160 || code3 > 55295 && code3 < 57344 || code3 > 64975 && code3 < 65008 || (code3 & 65535) === 65535 || (code3 & 65535) === 65534 || code3 > 1114111) {
+    return "\uFFFD";
+  }
+  return String.fromCharCode(code3);
+}
+
+// ../../node_modules/.pnpm/micromark-util-decode-string@1.0.2/node_modules/micromark-util-decode-string/index.js
+var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
+function decodeString(value) {
+  return value.replace(characterEscapeOrReference, decode);
+}
+function decode($0, $1, $2) {
+  if ($1) {
+    return $1;
+  }
+  const head = $2.charCodeAt(0);
+  if (head === 35) {
+    const head2 = $2.charCodeAt(1);
+    const hex = head2 === 120 || head2 === 88;
+    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
+  }
+  return decodeNamedCharacterReference($2) || $0;
+}
+
+// ../../node_modules/.pnpm/mdast-util-from-markdown@1.2.0/node_modules/mdast-util-from-markdown/lib/index.js
+var own6 = {}.hasOwnProperty;
+var fromMarkdown = function(value, encoding, options) {
+  if (typeof encoding !== "string") {
+    options = encoding;
+    encoding = void 0;
+  }
+  return compiler(options)(postprocess(parse3(options).document().write(preprocess()(value, encoding, true))));
+};
+function compiler(options = {}) {
+  const config = configure({
+    transforms: [],
+    canContainEols: [
+      "emphasis",
+      "fragment",
+      "heading",
+      "paragraph",
+      "strong"
+    ],
+    enter: {
+      autolink: opener(link2),
+      autolinkProtocol: onenterdata,
+      autolinkEmail: onenterdata,
+      atxHeading: opener(heading2),
+      blockQuote: opener(blockQuote2),
+      characterEscape: onenterdata,
+      characterReference: onenterdata,
+      codeFenced: opener(codeFlow),
+      codeFencedFenceInfo: buffer2,
+      codeFencedFenceMeta: buffer2,
+      codeIndented: opener(codeFlow, buffer2),
+      codeText: opener(codeText2, buffer2),
+      codeTextData: onenterdata,
+      data: onenterdata,
+      codeFlowValue: onenterdata,
+      definition: opener(definition2),
+      definitionDestinationString: buffer2,
+      definitionLabelString: buffer2,
+      definitionTitleString: buffer2,
+      emphasis: opener(emphasis2),
+      hardBreakEscape: opener(hardBreak2),
+      hardBreakTrailing: opener(hardBreak2),
+      htmlFlow: opener(html5, buffer2),
+      htmlFlowData: onenterdata,
+      htmlText: opener(html5, buffer2),
+      htmlTextData: onenterdata,
+      image: opener(image2),
+      label: buffer2,
+      link: opener(link2),
+      listItem: opener(listItem3),
+      listItemValue: onenterlistitemvalue,
+      listOrdered: opener(list3, onenterlistordered),
+      listUnordered: opener(list3),
+      paragraph: opener(paragraph2),
+      reference: onenterreference,
+      referenceString: buffer2,
+      resourceDestinationString: buffer2,
+      resourceTitleString: buffer2,
+      setextHeading: opener(heading2),
+      strong: opener(strong2),
+      thematicBreak: opener(thematicBreak3)
+    },
+    exit: {
+      atxHeading: closer(),
+      atxHeadingSequence: onexitatxheadingsequence,
+      autolink: closer(),
+      autolinkEmail: onexitautolinkemail,
+      autolinkProtocol: onexitautolinkprotocol,
+      blockQuote: closer(),
+      characterEscapeValue: onexitdata,
+      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
+      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
+      characterReferenceValue: onexitcharacterreferencevalue,
+      codeFenced: closer(onexitcodefenced),
+      codeFencedFence: onexitcodefencedfence,
+      codeFencedFenceInfo: onexitcodefencedfenceinfo,
+      codeFencedFenceMeta: onexitcodefencedfencemeta,
+      codeFlowValue: onexitdata,
+      codeIndented: closer(onexitcodeindented),
+      codeText: closer(onexitcodetext),
+      codeTextData: onexitdata,
+      data: onexitdata,
+      definition: closer(),
+      definitionDestinationString: onexitdefinitiondestinationstring,
+      definitionLabelString: onexitdefinitionlabelstring,
+      definitionTitleString: onexitdefinitiontitlestring,
+      emphasis: closer(),
+      hardBreakEscape: closer(onexithardbreak),
+      hardBreakTrailing: closer(onexithardbreak),
+      htmlFlow: closer(onexithtmlflow),
+      htmlFlowData: onexitdata,
+      htmlText: closer(onexithtmltext),
+      htmlTextData: onexitdata,
+      image: closer(onexitimage),
+      label: onexitlabel,
+      labelText: onexitlabeltext,
+      lineEnding: onexitlineending,
+      link: closer(onexitlink),
+      listItem: closer(),
+      listOrdered: closer(),
+      listUnordered: closer(),
+      paragraph: closer(),
+      referenceString: onexitreferencestring,
+      resourceDestinationString: onexitresourcedestinationstring,
+      resourceTitleString: onexitresourcetitlestring,
+      resource: onexitresource,
+      setextHeading: closer(onexitsetextheading),
+      setextHeadingLineSequence: onexitsetextheadinglinesequence,
+      setextHeadingText: onexitsetextheadingtext,
+      strong: closer(),
+      thematicBreak: closer()
+    }
+  }, options.mdastExtensions || []);
+  const data2 = {};
+  return compile;
+  function compile(events) {
+    let tree = {
+      type: "root",
+      children: []
+    };
+    const stack = [tree];
+    const tokenStack = [];
+    const listStack = [];
+    const context = {
+      stack,
+      tokenStack,
+      config,
+      enter,
+      exit: exit3,
+      buffer: buffer2,
+      resume,
+      setData,
+      getData
+    };
+    let index3 = -1;
+    while (++index3 < events.length) {
+      if (events[index3][1].type === "listOrdered" || events[index3][1].type === "listUnordered") {
+        if (events[index3][0] === "enter") {
+          listStack.push(index3);
+        } else {
+          const tail = listStack.pop();
+          index3 = prepareList(events, tail, index3);
+        }
+      }
+    }
+    index3 = -1;
+    while (++index3 < events.length) {
+      const handler = config[events[index3][0]];
+      if (own6.call(handler, events[index3][1].type)) {
+        handler[events[index3][1].type].call(Object.assign({
+          sliceSerialize: events[index3][2].sliceSerialize
+        }, context), events[index3][1]);
+      }
+    }
+    if (tokenStack.length > 0) {
+      const tail = tokenStack[tokenStack.length - 1];
+      const handler = tail[1] || defaultOnError;
+      handler.call(context, void 0, tail[0]);
+    }
+    tree.position = {
+      start: point4(events.length > 0 ? events[0][1].start : {
+        line: 1,
+        column: 1,
+        offset: 0
+      }),
+      end: point4(events.length > 0 ? events[events.length - 2][1].end : {
+        line: 1,
+        column: 1,
+        offset: 0
+      })
+    };
+    index3 = -1;
+    while (++index3 < config.transforms.length) {
+      tree = config.transforms[index3](tree) || tree;
+    }
+    return tree;
+  }
+  function prepareList(events, start3, length) {
+    let index3 = start3 - 1;
+    let containerBalance = -1;
+    let listSpread = false;
+    let listItem4;
+    let lineIndex;
+    let firstBlankLineIndex;
+    let atMarker;
+    while (++index3 <= length) {
+      const event = events[index3];
+      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
+        if (event[0] === "enter") {
+          containerBalance++;
+        } else {
+          containerBalance--;
+        }
+        atMarker = void 0;
+      } else if (event[1].type === "lineEndingBlank") {
+        if (event[0] === "enter") {
+          if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
+            firstBlankLineIndex = index3;
+          }
+          atMarker = void 0;
+        }
+      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
+      } else {
+        atMarker = void 0;
+      }
+      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
+        if (listItem4) {
+          let tailIndex = index3;
+          lineIndex = void 0;
+          while (tailIndex--) {
+            const tailEvent = events[tailIndex];
+            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
+              if (tailEvent[0] === "exit")
+                continue;
+              if (lineIndex) {
+                events[lineIndex][1].type = "lineEndingBlank";
+                listSpread = true;
+              }
+              tailEvent[1].type = "lineEnding";
+              lineIndex = tailIndex;
+            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
+            } else {
+              break;
+            }
+          }
+          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
+            listItem4._spread = true;
+          }
+          listItem4.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
+          events.splice(lineIndex || index3, 0, ["exit", listItem4, event[2]]);
+          index3++;
+          length++;
+        }
+        if (event[1].type === "listItemPrefix") {
+          listItem4 = {
+            type: "listItem",
+            _spread: false,
+            start: Object.assign({}, event[1].start)
+          };
+          events.splice(index3, 0, ["enter", listItem4, event[2]]);
+          index3++;
+          length++;
+          firstBlankLineIndex = void 0;
+          atMarker = true;
+        }
+      }
+    }
+    events[start3][1]._spread = listSpread;
+    return length;
+  }
+  function setData(key, value) {
+    data2[key] = value;
+  }
+  function getData(key) {
+    return data2[key];
+  }
+  function point4(d) {
+    return {
+      line: d.line,
+      column: d.column,
+      offset: d.offset
+    };
+  }
+  function opener(create6, and) {
+    return open;
+    function open(token) {
+      enter.call(this, create6(token), token);
+      if (and)
+        and.call(this, token);
+    }
+  }
+  function buffer2() {
+    this.stack.push({
+      type: "fragment",
+      children: []
+    });
+  }
+  function enter(node, token, errorHandler) {
+    const parent = this.stack[this.stack.length - 1];
+    parent.children.push(node);
+    this.stack.push(node);
+    this.tokenStack.push([token, errorHandler]);
+    node.position = {
+      start: point4(token.start)
+    };
+    return node;
+  }
+  function closer(and) {
+    return close;
+    function close(token) {
+      if (and)
+        and.call(this, token);
+      exit3.call(this, token);
+    }
+  }
+  function exit3(token, onExitError) {
+    const node = this.stack.pop();
+    const open = this.tokenStack.pop();
+    if (!open) {
+      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
+        start: token.start,
+        end: token.end
+      }) + "): it\u2019s not open");
+    } else if (open[0].type !== token.type) {
+      if (onExitError) {
+        onExitError.call(this, token, open[0]);
+      } else {
+        const handler = open[1] || defaultOnError;
+        handler.call(this, token, open[0]);
+      }
+    }
+    node.position.end = point4(token.end);
+    return node;
+  }
+  function resume() {
+    return toString2(this.stack.pop());
+  }
+  function onenterlistordered() {
+    setData("expectingFirstListItemValue", true);
+  }
+  function onenterlistitemvalue(token) {
+    if (getData("expectingFirstListItemValue")) {
+      const ancestor = this.stack[this.stack.length - 2];
+      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
+      setData("expectingFirstListItemValue");
+    }
+  }
+  function onexitcodefencedfenceinfo() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.lang = data3;
+  }
+  function onexitcodefencedfencemeta() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.meta = data3;
+  }
+  function onexitcodefencedfence() {
+    if (getData("flowCodeInside"))
+      return;
+    this.buffer();
+    setData("flowCodeInside", true);
+  }
+  function onexitcodefenced() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
+    setData("flowCodeInside");
+  }
+  function onexitcodeindented() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.value = data3.replace(/(\r?\n|\r)$/g, "");
+  }
+  function onexitdefinitionlabelstring(token) {
+    const label = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.label = label;
+    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
+  }
+  function onexitdefinitiontitlestring() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.title = data3;
+  }
+  function onexitdefinitiondestinationstring() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.url = data3;
+  }
+  function onexitatxheadingsequence(token) {
+    const node = this.stack[this.stack.length - 1];
+    if (!node.depth) {
+      const depth = this.sliceSerialize(token).length;
+      node.depth = depth;
+    }
+  }
+  function onexitsetextheadingtext() {
+    setData("setextHeadingSlurpLineEnding", true);
+  }
+  function onexitsetextheadinglinesequence(token) {
+    const node = this.stack[this.stack.length - 1];
+    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
+  }
+  function onexitsetextheading() {
+    setData("setextHeadingSlurpLineEnding");
+  }
+  function onenterdata(token) {
+    const parent = this.stack[this.stack.length - 1];
+    let tail = parent.children[parent.children.length - 1];
+    if (!tail || tail.type !== "text") {
+      tail = text7();
+      tail.position = {
+        start: point4(token.start)
+      };
+      parent.children.push(tail);
+    }
+    this.stack.push(tail);
+  }
+  function onexitdata(token) {
+    const tail = this.stack.pop();
+    tail.value += this.sliceSerialize(token);
+    tail.position.end = point4(token.end);
+  }
+  function onexitlineending(token) {
+    const context = this.stack[this.stack.length - 1];
+    if (getData("atHardBreak")) {
+      const tail = context.children[context.children.length - 1];
+      tail.position.end = point4(token.end);
+      setData("atHardBreak");
+      return;
+    }
+    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
+      onenterdata.call(this, token);
+      onexitdata.call(this, token);
+    }
+  }
+  function onexithardbreak() {
+    setData("atHardBreak", true);
+  }
+  function onexithtmlflow() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.value = data3;
+  }
+  function onexithtmltext() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.value = data3;
+  }
+  function onexitcodetext() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.value = data3;
+  }
+  function onexitlink() {
+    const context = this.stack[this.stack.length - 1];
+    if (getData("inReference")) {
+      context.type += "Reference";
+      context.referenceType = getData("referenceType") || "shortcut";
+      delete context.url;
+      delete context.title;
+    } else {
+      delete context.identifier;
+      delete context.label;
+    }
+    setData("referenceType");
+  }
+  function onexitimage() {
+    const context = this.stack[this.stack.length - 1];
+    if (getData("inReference")) {
+      context.type += "Reference";
+      context.referenceType = getData("referenceType") || "shortcut";
+      delete context.url;
+      delete context.title;
+    } else {
+      delete context.identifier;
+      delete context.label;
+    }
+    setData("referenceType");
+  }
+  function onexitlabeltext(token) {
+    const ancestor = this.stack[this.stack.length - 2];
+    const string3 = this.sliceSerialize(token);
+    ancestor.label = decodeString(string3);
+    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
+  }
+  function onexitlabel() {
+    const fragment = this.stack[this.stack.length - 1];
+    const value = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    setData("inReference", true);
+    if (node.type === "link") {
+      node.children = fragment.children;
+    } else {
+      node.alt = value;
+    }
+  }
+  function onexitresourcedestinationstring() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.url = data3;
+  }
+  function onexitresourcetitlestring() {
+    const data3 = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.title = data3;
+  }
+  function onexitresource() {
+    setData("inReference");
+  }
+  function onenterreference() {
+    setData("referenceType", "collapsed");
+  }
+  function onexitreferencestring(token) {
+    const label = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.label = label;
+    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
+    setData("referenceType", "full");
+  }
+  function onexitcharacterreferencemarker(token) {
+    setData("characterReferenceType", token.type);
+  }
+  function onexitcharacterreferencevalue(token) {
+    const data3 = this.sliceSerialize(token);
+    const type2 = getData("characterReferenceType");
+    let value;
+    if (type2) {
+      value = decodeNumericCharacterReference(data3, type2 === "characterReferenceMarkerNumeric" ? 10 : 16);
+      setData("characterReferenceType");
+    } else {
+      value = decodeNamedCharacterReference(data3);
+    }
+    const tail = this.stack.pop();
+    tail.value += value;
+    tail.position.end = point4(token.end);
+  }
+  function onexitautolinkprotocol(token) {
+    onexitdata.call(this, token);
+    const node = this.stack[this.stack.length - 1];
+    node.url = this.sliceSerialize(token);
+  }
+  function onexitautolinkemail(token) {
+    onexitdata.call(this, token);
+    const node = this.stack[this.stack.length - 1];
+    node.url = "mailto:" + this.sliceSerialize(token);
+  }
+  function blockQuote2() {
+    return {
+      type: "blockquote",
+      children: []
+    };
+  }
+  function codeFlow() {
+    return {
+      type: "code",
+      lang: null,
+      meta: null,
+      value: ""
+    };
+  }
+  function codeText2() {
+    return {
+      type: "inlineCode",
+      value: ""
+    };
+  }
+  function definition2() {
+    return {
+      type: "definition",
+      identifier: "",
+      label: null,
+      title: null,
+      url: ""
+    };
+  }
+  function emphasis2() {
+    return {
+      type: "emphasis",
+      children: []
+    };
+  }
+  function heading2() {
+    return {
+      type: "heading",
+      depth: void 0,
+      children: []
+    };
+  }
+  function hardBreak2() {
+    return {
+      type: "break"
+    };
+  }
+  function html5() {
+    return {
+      type: "html",
+      value: ""
+    };
+  }
+  function image2() {
+    return {
+      type: "image",
+      title: null,
+      url: "",
+      alt: null
+    };
+  }
+  function link2() {
+    return {
+      type: "link",
+      title: null,
+      url: "",
+      children: []
+    };
+  }
+  function list3(token) {
+    return {
+      type: "list",
+      ordered: token.type === "listOrdered",
+      start: null,
+      spread: token._spread,
+      children: []
+    };
+  }
+  function listItem3(token) {
+    return {
+      type: "listItem",
+      spread: token._spread,
+      checked: null,
+      children: []
+    };
+  }
+  function paragraph2() {
+    return {
+      type: "paragraph",
+      children: []
+    };
+  }
+  function strong2() {
+    return {
+      type: "strong",
+      children: []
+    };
+  }
+  function text7() {
+    return {
+      type: "text",
+      value: ""
+    };
+  }
+  function thematicBreak3() {
+    return {
+      type: "thematicBreak"
+    };
+  }
+}
+function configure(combined, extensions) {
+  let index3 = -1;
+  while (++index3 < extensions.length) {
+    const value = extensions[index3];
+    if (Array.isArray(value)) {
+      configure(combined, value);
+    } else {
+      extension(combined, value);
+    }
+  }
+  return combined;
+}
+function extension(combined, extension2) {
+  let key;
+  for (key in extension2) {
+    if (own6.call(extension2, key)) {
+      const list3 = key === "canContainEols" || key === "transforms";
+      const maybe = own6.call(combined, key) ? combined[key] : void 0;
+      const left = maybe || (combined[key] = list3 ? [] : {});
+      const right = extension2[key];
+      if (right) {
+        if (list3) {
+          combined[key] = [...left, ...right];
+        } else {
+          Object.assign(left, right);
+        }
+      }
+    }
+  }
+}
+function defaultOnError(left, right) {
+  if (left) {
+    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
+      start: left.start,
+      end: left.end
+    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
+      start: right.start,
+      end: right.end
+    }) + ") is open");
+  } else {
+    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
+      start: right.start,
+      end: right.end
+    }) + ") is still open");
+  }
+}
+
+// ../../node_modules/.pnpm/remark-parse@10.0.1/node_modules/remark-parse/lib/index.js
+function remarkParse(options) {
+  const parser2 = (doc) => {
+    const settings = this.data("settings");
+    return fromMarkdown(doc, Object.assign({}, settings, options, {
+      extensions: this.data("micromarkExtensions") || [],
+      mdastExtensions: this.data("fromMarkdownExtensions") || []
+    }));
+  };
+  Object.assign(this, { Parser: parser2 });
+}
+
+// ../../node_modules/.pnpm/remark-parse@10.0.1/node_modules/remark-parse/index.js
+var remark_parse_default = remarkParse;
+
+// ../../node_modules/.pnpm/unist-builder@3.0.0/node_modules/unist-builder/index.js
+var u = function(type2, props, value) {
+  var node = { type: String(type2) };
+  if ((value === void 0 || value === null) && (typeof props === "string" || Array.isArray(props))) {
+    value = props;
+  } else {
+    Object.assign(node, props);
+  }
+  if (Array.isArray(value)) {
+    node.children = value;
+  } else if (value !== void 0 && value !== null) {
+    node.value = String(value);
+  }
+  return node;
+};
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/traverse.js
+var own7 = {}.hasOwnProperty;
+function unknown(h2, node) {
+  const data2 = node.data || {};
+  if ("value" in node && !(own7.call(data2, "hName") || own7.call(data2, "hProperties") || own7.call(data2, "hChildren"))) {
+    return h2.augment(node, u("text", node.value));
+  }
+  return h2(node, "div", all2(h2, node));
+}
+function one2(h2, node, parent) {
+  const type2 = node && node.type;
+  let fn;
+  if (!type2) {
+    throw new Error("Expected node, got `" + node + "`");
+  }
+  if (own7.call(h2.handlers, type2)) {
+    fn = h2.handlers[type2];
+  } else if (h2.passThrough && h2.passThrough.includes(type2)) {
+    fn = returnNode;
+  } else {
+    fn = h2.unknownHandler;
+  }
+  return (typeof fn === "function" ? fn : unknown)(h2, node, parent);
+}
+function returnNode(h2, node) {
+  return "children" in node ? __spreadProps(__spreadValues({}, node), { children: all2(h2, node) }) : node;
+}
+function all2(h2, parent) {
+  const values = [];
+  if ("children" in parent) {
+    const nodes2 = parent.children;
+    let index3 = -1;
+    while (++index3 < nodes2.length) {
+      const result = one2(h2, nodes2[index3], parent);
+      if (result) {
+        if (index3 && nodes2[index3 - 1].type === "break") {
+          if (!Array.isArray(result) && result.type === "text") {
+            result.value = result.value.replace(/^\s+/, "");
+          }
+          if (!Array.isArray(result) && result.type === "element") {
+            const head = result.children[0];
+            if (head && head.type === "text") {
+              head.value = head.value.replace(/^\s+/, "");
+            }
+          }
+        }
+        if (Array.isArray(result)) {
+          values.push(...result);
+        } else {
+          values.push(result);
+        }
+      }
+    }
+  }
+  return values;
+}
+
+// ../../node_modules/.pnpm/unist-util-is@5.1.1/node_modules/unist-util-is/index.js
+var convert = function(test) {
+  if (test === void 0 || test === null) {
+    return ok;
+  }
+  if (typeof test === "string") {
+    return typeFactory(test);
+  }
+  if (typeof test === "object") {
+    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
+  }
+  if (typeof test === "function") {
+    return castFactory(test);
+  }
+  throw new Error("Expected function, string, or object as test");
+};
+function anyFactory(tests) {
+  const checks3 = [];
+  let index3 = -1;
+  while (++index3 < tests.length) {
+    checks3[index3] = convert(tests[index3]);
+  }
+  return castFactory(any);
+  function any(...parameters) {
+    let index4 = -1;
+    while (++index4 < checks3.length) {
+      if (checks3[index4].call(this, ...parameters))
+        return true;
+    }
+    return false;
+  }
+}
+function propsFactory(check) {
+  return castFactory(all4);
+  function all4(node) {
+    let key;
+    for (key in check) {
+      if (node[key] !== check[key])
+        return false;
+    }
+    return true;
+  }
+}
+function typeFactory(check) {
+  return castFactory(type2);
+  function type2(node) {
+    return node && node.type === check;
+  }
+}
+function castFactory(check) {
+  return assertion;
+  function assertion(...parameters) {
+    return Boolean(check.call(this, ...parameters));
+  }
+}
+function ok() {
+  return true;
+}
+
+// ../../node_modules/.pnpm/unist-util-visit-parents@5.1.0/node_modules/unist-util-visit-parents/color.js
+function color2(d) {
+  return "\x1B[33m" + d + "\x1B[39m";
+}
+
+// ../../node_modules/.pnpm/unist-util-visit-parents@5.1.0/node_modules/unist-util-visit-parents/index.js
+var CONTINUE2 = true;
+var SKIP2 = "skip";
+var EXIT2 = false;
+var visitParents = function(tree, test, visitor, reverse) {
+  if (typeof test === "function" && typeof visitor !== "function") {
+    reverse = visitor;
+    visitor = test;
+    test = null;
+  }
+  const is = convert(test);
+  const step = reverse ? -1 : 1;
+  factory2(tree, null, [])();
+  function factory2(node, index3, parents) {
+    const value = typeof node === "object" && node !== null ? node : {};
+    let name3;
+    if (typeof value.type === "string") {
+      name3 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
+      Object.defineProperty(visit8, "name", {
+        value: "node (" + color2(value.type + (name3 ? "<" + name3 + ">" : "")) + ")"
+      });
+    }
+    return visit8;
+    function visit8() {
+      let result = [];
+      let subresult;
+      let offset2;
+      let grandparents;
+      if (!test || is(node, index3, parents[parents.length - 1] || null)) {
+        result = toResult2(visitor(node, parents));
+        if (result[0] === EXIT2) {
+          return result;
+        }
+      }
+      if (node.children && result[0] !== SKIP2) {
+        offset2 = (reverse ? node.children.length : -1) + step;
+        grandparents = parents.concat(node);
+        while (offset2 > -1 && offset2 < node.children.length) {
+          subresult = factory2(node.children[offset2], offset2, grandparents)();
+          if (subresult[0] === EXIT2) {
+            return subresult;
+          }
+          offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
+        }
+      }
+      return result;
+    }
+  }
+};
+function toResult2(value) {
+  if (Array.isArray(value)) {
+    return value;
+  }
+  if (typeof value === "number") {
+    return [CONTINUE2, value];
+  }
+  return [value];
+}
+
+// ../../node_modules/.pnpm/unist-util-visit@4.1.0/node_modules/unist-util-visit/index.js
+var visit2 = function(tree, test, visitor, reverse) {
+  if (typeof test === "function" && typeof visitor !== "function") {
+    reverse = visitor;
+    visitor = test;
+    test = null;
+  }
+  visitParents(tree, test, overload, reverse);
+  function overload(node, parents) {
+    const parent = parents[parents.length - 1];
+    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
+  }
+};
+
+// ../../node_modules/.pnpm/unist-util-position@4.0.1/node_modules/unist-util-position/index.js
+var pointStart = point2("start");
+var pointEnd = point2("end");
+function position2(node) {
+  return { start: pointStart(node), end: pointEnd(node) };
+}
+function point2(type2) {
+  return point4;
+  function point4(node) {
+    var point5 = node && node.position && node.position[type2] || {};
+    return {
+      line: point5.line || null,
+      column: point5.column || null,
+      offset: point5.offset > -1 ? point5.offset : null
+    };
+  }
+}
+
+// ../../node_modules/.pnpm/unist-util-generated@2.0.0/node_modules/unist-util-generated/index.js
+function generated(node) {
+  return !node || !node.position || !node.position.start || !node.position.start.line || !node.position.start.column || !node.position.end || !node.position.end.line || !node.position.end.column;
+}
+
+// ../../node_modules/.pnpm/unist-util-visit-parents@4.1.1/node_modules/unist-util-visit-parents/color.js
+function color3(d) {
+  return "\x1B[33m" + d + "\x1B[39m";
+}
+
+// ../../node_modules/.pnpm/unist-util-visit-parents@4.1.1/node_modules/unist-util-visit-parents/index.js
+var CONTINUE3 = true;
+var SKIP3 = "skip";
+var EXIT3 = false;
+var visitParents2 = function(tree, test, visitor, reverse) {
+  if (typeof test === "function" && typeof visitor !== "function") {
+    reverse = visitor;
+    visitor = test;
+    test = null;
+  }
+  var is = convert(test);
+  var step = reverse ? -1 : 1;
+  factory2(tree, null, [])();
+  function factory2(node, index3, parents) {
+    var value = typeof node === "object" && node !== null ? node : {};
+    var name3;
+    if (typeof value.type === "string") {
+      name3 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
+      Object.defineProperty(visit8, "name", {
+        value: "node (" + color3(value.type + (name3 ? "<" + name3 + ">" : "")) + ")"
+      });
+    }
+    return visit8;
+    function visit8() {
+      var result = [];
+      var subresult;
+      var offset2;
+      var grandparents;
+      if (!test || is(node, index3, parents[parents.length - 1] || null)) {
+        result = toResult3(visitor(node, parents));
+        if (result[0] === EXIT3) {
+          return result;
+        }
+      }
+      if (node.children && result[0] !== SKIP3) {
+        offset2 = (reverse ? node.children.length : -1) + step;
+        grandparents = parents.concat(node);
+        while (offset2 > -1 && offset2 < node.children.length) {
+          subresult = factory2(node.children[offset2], offset2, grandparents)();
+          if (subresult[0] === EXIT3) {
+            return subresult;
+          }
+          offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
+        }
+      }
+      return result;
+    }
+  }
+};
+function toResult3(value) {
+  if (Array.isArray(value)) {
+    return value;
+  }
+  if (typeof value === "number") {
+    return [CONTINUE3, value];
+  }
+  return [value];
+}
+
+// ../../node_modules/.pnpm/unist-util-visit@3.1.0/node_modules/unist-util-visit/index.js
+var visit3 = function(tree, test, visitor, reverse) {
+  if (typeof test === "function" && typeof visitor !== "function") {
+    reverse = visitor;
+    visitor = test;
+    test = null;
+  }
+  visitParents2(tree, test, overload, reverse);
+  function overload(node, parents) {
+    var parent = parents[parents.length - 1];
+    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
+  }
+};
+
+// ../../node_modules/.pnpm/mdast-util-definitions@5.1.0/node_modules/mdast-util-definitions/index.js
+var own8 = {}.hasOwnProperty;
+function definitions(node) {
+  const cache = /* @__PURE__ */ Object.create(null);
+  if (!node || !node.type) {
+    throw new Error("mdast-util-definitions expected node");
+  }
+  visit3(node, "definition", ondefinition);
+  return getDefinition;
+  function ondefinition(definition2) {
+    const id = clean(definition2.identifier);
+    if (id && !own8.call(cache, id)) {
+      cache[id] = definition2;
+    }
+  }
+  function getDefinition(identifier) {
+    const id = clean(identifier);
+    return id && own8.call(cache, id) ? cache[id] : null;
+  }
+}
+function clean(value) {
+  return String(value || "").toUpperCase();
+}
+
+// ../../node_modules/.pnpm/micromark-util-encode@1.0.1/node_modules/micromark-util-encode/index.js
+var characterReferences = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
+function encode(value) {
+  return value.replace(/["&<>]/g, replace2);
+  function replace2(value2) {
+    return "&" + characterReferences[value2] + ";";
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-util-sanitize-uri@1.0.0/node_modules/micromark-util-sanitize-uri/index.js
+function sanitizeUri(url, protocol) {
+  const value = encode(normalizeUri(url || ""));
+  if (!protocol) {
+    return value;
+  }
+  const colon = value.indexOf(":");
+  const questionMark = value.indexOf("?");
+  const numberSign = value.indexOf("#");
+  const slash = value.indexOf("/");
+  if (colon < 0 || slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || protocol.test(value.slice(0, colon))) {
+    return value;
+  }
+  return "";
+}
+function normalizeUri(value) {
+  const result = [];
+  let index3 = -1;
+  let start3 = 0;
+  let skip = 0;
+  while (++index3 < value.length) {
+    const code3 = value.charCodeAt(index3);
+    let replace2 = "";
+    if (code3 === 37 && asciiAlphanumeric(value.charCodeAt(index3 + 1)) && asciiAlphanumeric(value.charCodeAt(index3 + 2))) {
+      skip = 2;
+    } else if (code3 < 128) {
+      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code3))) {
+        replace2 = String.fromCharCode(code3);
+      }
+    } else if (code3 > 55295 && code3 < 57344) {
+      const next = value.charCodeAt(index3 + 1);
+      if (code3 < 56320 && next > 56319 && next < 57344) {
+        replace2 = String.fromCharCode(code3, next);
+        skip = 1;
+      } else {
+        replace2 = "\uFFFD";
+      }
+    } else {
+      replace2 = String.fromCharCode(code3);
+    }
+    if (replace2) {
+      result.push(value.slice(start3, index3), encodeURIComponent(replace2));
+      start3 = index3 + skip + 1;
+      replace2 = "";
+    }
+    if (skip) {
+      index3 += skip;
+      skip = 0;
+    }
+  }
+  return result.join("") + value.slice(start3);
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/wrap.js
+function wrap2(nodes2, loose) {
+  const result = [];
+  let index3 = -1;
+  if (loose) {
+    result.push(u("text", "\n"));
+  }
+  while (++index3 < nodes2.length) {
+    if (index3)
+      result.push(u("text", "\n"));
+    result.push(nodes2[index3]);
+  }
+  if (loose && nodes2.length > 0) {
+    result.push(u("text", "\n"));
+  }
+  return result;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/footer.js
+function footer(h2) {
+  let index3 = -1;
+  const listItems = [];
+  while (++index3 < h2.footnoteOrder.length) {
+    const def = h2.footnoteById[h2.footnoteOrder[index3].toUpperCase()];
+    if (!def) {
+      continue;
+    }
+    const content3 = all2(h2, def);
+    const id = String(def.identifier);
+    const safeId = sanitizeUri(id.toLowerCase());
+    let referenceIndex = 0;
+    const backReferences = [];
+    while (++referenceIndex <= h2.footnoteCounts[id]) {
+      const backReference = {
+        type: "element",
+        tagName: "a",
+        properties: {
+          href: "#" + h2.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
+          dataFootnoteBackref: true,
+          className: ["data-footnote-backref"],
+          ariaLabel: h2.footnoteBackLabel
+        },
+        children: [{ type: "text", value: "\u21A9" }]
+      };
+      if (referenceIndex > 1) {
+        backReference.children.push({
+          type: "element",
+          tagName: "sup",
+          children: [{ type: "text", value: String(referenceIndex) }]
+        });
+      }
+      if (backReferences.length > 0) {
+        backReferences.push({ type: "text", value: " " });
+      }
+      backReferences.push(backReference);
+    }
+    const tail = content3[content3.length - 1];
+    if (tail && tail.type === "element" && tail.tagName === "p") {
+      const tailTail = tail.children[tail.children.length - 1];
+      if (tailTail && tailTail.type === "text") {
+        tailTail.value += " ";
+      } else {
+        tail.children.push({ type: "text", value: " " });
+      }
+      tail.children.push(...backReferences);
+    } else {
+      content3.push(...backReferences);
+    }
+    const listItem3 = {
+      type: "element",
+      tagName: "li",
+      properties: { id: h2.clobberPrefix + "fn-" + safeId },
+      children: wrap2(content3, true)
+    };
+    if (def.position) {
+      listItem3.position = def.position;
+    }
+    listItems.push(listItem3);
+  }
+  if (listItems.length === 0) {
+    return null;
+  }
+  return {
+    type: "element",
+    tagName: "section",
+    properties: { dataFootnotes: true, className: ["footnotes"] },
+    children: [
+      {
+        type: "element",
+        tagName: "h2",
+        properties: { id: "footnote-label", className: ["sr-only"] },
+        children: [u("text", h2.footnoteLabel)]
+      },
+      { type: "text", value: "\n" },
+      {
+        type: "element",
+        tagName: "ol",
+        properties: {},
+        children: wrap2(listItems, true)
+      },
+      { type: "text", value: "\n" }
+    ]
+  };
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
+function blockquote(h2, node) {
+  return h2(node, "blockquote", wrap2(all2(h2, node), true));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/break.js
+function hardBreak(h2, node) {
+  return [h2(node, "br"), u("text", "\n")];
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/code.js
+function code(h2, node) {
+  const value = node.value ? node.value + "\n" : "";
+  const lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
+  const props = {};
+  if (lang) {
+    props.className = ["language-" + lang];
+  }
+  const code3 = h2(node, "code", props, [u("text", value)]);
+  if (node.meta) {
+    code3.data = { meta: node.meta };
+  }
+  return h2(node.position, "pre", [code3]);
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/delete.js
+function strikethrough(h2, node) {
+  return h2(node, "del", all2(h2, node));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
+function emphasis(h2, node) {
+  return h2(node, "em", all2(h2, node));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
+function footnoteReference(h2, node) {
+  const id = String(node.identifier);
+  const safeId = sanitizeUri(id.toLowerCase());
+  const index3 = h2.footnoteOrder.indexOf(id);
+  let counter;
+  if (index3 === -1) {
+    h2.footnoteOrder.push(id);
+    h2.footnoteCounts[id] = 1;
+    counter = h2.footnoteOrder.length;
+  } else {
+    h2.footnoteCounts[id]++;
+    counter = index3 + 1;
+  }
+  const reuseCounter = h2.footnoteCounts[id];
+  return h2(node, "sup", [
+    h2(node.position, "a", {
+      href: "#" + h2.clobberPrefix + "fn-" + safeId,
+      id: h2.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
+      dataFootnoteRef: true,
+      ariaDescribedBy: "footnote-label"
+    }, [u("text", String(counter))])
+  ]);
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/footnote.js
+function footnote(h2, node) {
+  const footnoteById = h2.footnoteById;
+  let no = 1;
+  while (no in footnoteById)
+    no++;
+  const identifier = String(no);
+  footnoteById[identifier] = {
+    type: "footnoteDefinition",
+    identifier,
+    children: [{ type: "paragraph", children: node.children }],
+    position: node.position
+  };
+  return footnoteReference(h2, {
+    type: "footnoteReference",
+    identifier,
+    position: node.position
+  });
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/heading.js
+function heading(h2, node) {
+  return h2(node, "h" + node.depth, all2(h2, node));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/html.js
+function html(h2, node) {
+  return h2.dangerous ? h2.augment(node, u("raw", node.value)) : null;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
+var import_encode = __toESM(require_encode(), 1);
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/revert.js
+function revert(h2, node) {
+  const subtype = node.referenceType;
+  let suffix = "]";
+  if (subtype === "collapsed") {
+    suffix += "[]";
+  } else if (subtype === "full") {
+    suffix += "[" + (node.label || node.identifier) + "]";
+  }
+  if (node.type === "imageReference") {
+    return u("text", "![" + node.alt + suffix);
+  }
+  const contents = all2(h2, node);
+  const head = contents[0];
+  if (head && head.type === "text") {
+    head.value = "[" + head.value;
+  } else {
+    contents.unshift(u("text", "["));
+  }
+  const tail = contents[contents.length - 1];
+  if (tail && tail.type === "text") {
+    tail.value += suffix;
+  } else {
+    contents.push(u("text", suffix));
+  }
+  return contents;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
+function imageReference(h2, node) {
+  const def = h2.definition(node.identifier);
+  if (!def) {
+    return revert(h2, node);
+  }
+  const props = { src: (0, import_encode.default)(def.url || ""), alt: node.alt };
+  if (def.title !== null && def.title !== void 0) {
+    props.title = def.title;
+  }
+  return h2(node, "img", props);
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/image.js
+var import_encode2 = __toESM(require_encode(), 1);
+function image(h2, node) {
+  const props = { src: (0, import_encode2.default)(node.url), alt: node.alt };
+  if (node.title !== null && node.title !== void 0) {
+    props.title = node.title;
+  }
+  return h2(node, "img", props);
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
+function inlineCode(h2, node) {
+  return h2(node, "code", [u("text", node.value.replace(/\r?\n|\r/g, " "))]);
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
+var import_encode3 = __toESM(require_encode(), 1);
+function linkReference(h2, node) {
+  const def = h2.definition(node.identifier);
+  if (!def) {
+    return revert(h2, node);
+  }
+  const props = { href: (0, import_encode3.default)(def.url || "") };
+  if (def.title !== null && def.title !== void 0) {
+    props.title = def.title;
+  }
+  return h2(node, "a", props, all2(h2, node));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/link.js
+var import_encode4 = __toESM(require_encode(), 1);
+function link(h2, node) {
+  const props = { href: (0, import_encode4.default)(node.url) };
+  if (node.title !== null && node.title !== void 0) {
+    props.title = node.title;
+  }
+  return h2(node, "a", props, all2(h2, node));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/list-item.js
+function listItem(h2, node, parent) {
+  const result = all2(h2, node);
+  const loose = parent ? listLoose(parent) : listItemLoose(node);
+  const props = {};
+  const wrapped = [];
+  if (typeof node.checked === "boolean") {
+    let paragraph2;
+    if (result[0] && result[0].type === "element" && result[0].tagName === "p") {
+      paragraph2 = result[0];
+    } else {
+      paragraph2 = h2(null, "p", []);
+      result.unshift(paragraph2);
+    }
+    if (paragraph2.children.length > 0) {
+      paragraph2.children.unshift(u("text", " "));
+    }
+    paragraph2.children.unshift(h2(null, "input", {
+      type: "checkbox",
+      checked: node.checked,
+      disabled: true
+    }));
+    props.className = ["task-list-item"];
+  }
+  let index3 = -1;
+  while (++index3 < result.length) {
+    const child = result[index3];
+    if (loose || index3 !== 0 || child.type !== "element" || child.tagName !== "p") {
+      wrapped.push(u("text", "\n"));
+    }
+    if (child.type === "element" && child.tagName === "p" && !loose) {
+      wrapped.push(...child.children);
+    } else {
+      wrapped.push(child);
+    }
+  }
+  const tail = result[result.length - 1];
+  if (tail && (loose || !("tagName" in tail) || tail.tagName !== "p")) {
+    wrapped.push(u("text", "\n"));
+  }
+  return h2(node, "li", props, wrapped);
+}
+function listLoose(node) {
+  let loose = node.spread;
+  const children = node.children;
+  let index3 = -1;
+  while (!loose && ++index3 < children.length) {
+    loose = listItemLoose(children[index3]);
+  }
+  return Boolean(loose);
+}
+function listItemLoose(node) {
+  const spread = node.spread;
+  return spread === void 0 || spread === null ? node.children.length > 1 : spread;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/list.js
+function list2(h2, node) {
+  const props = {};
+  const name3 = node.ordered ? "ol" : "ul";
+  const items = all2(h2, node);
+  let index3 = -1;
+  if (typeof node.start === "number" && node.start !== 1) {
+    props.start = node.start;
+  }
+  while (++index3 < items.length) {
+    const item = items[index3];
+    if (item.type === "element" && item.tagName === "li" && item.properties && Array.isArray(item.properties.className) && item.properties.className.includes("task-list-item")) {
+      props.className = ["contains-task-list"];
+      break;
+    }
+  }
+  return h2(node, name3, props, wrap2(items, true));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
+function paragraph(h2, node) {
+  return h2(node, "p", all2(h2, node));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/root.js
+function root(h2, node) {
+  return h2.augment(node, u("root", wrap2(all2(h2, node))));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/strong.js
+function strong(h2, node) {
+  return h2(node, "strong", all2(h2, node));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/table.js
+function table(h2, node) {
+  const rows = node.children;
+  let index3 = -1;
+  const align = node.align || [];
+  const result = [];
+  while (++index3 < rows.length) {
+    const row = rows[index3].children;
+    const name3 = index3 === 0 ? "th" : "td";
+    let pos = node.align ? align.length : row.length;
+    const out = [];
+    while (pos--) {
+      const cell = row[pos];
+      out[pos] = h2(cell, name3, { align: align[pos] }, cell ? all2(h2, cell) : []);
+    }
+    result[index3] = h2(rows[index3], "tr", wrap2(out, true));
+  }
+  return h2(node, "table", wrap2([h2(result[0].position, "thead", wrap2([result[0]], true))].concat(result[1] ? h2({
+    start: pointStart(result[1]),
+    end: pointEnd(result[result.length - 1])
+  }, "tbody", wrap2(result.slice(1), true)) : []), true));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/text.js
+function text3(h2, node) {
+  return h2.augment(node, u("text", String(node.value).replace(/[ \t]*(\r?\n|\r)[ \t]*/g, "$1")));
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
+function thematicBreak2(h2, node) {
+  return h2(node, "hr");
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/handlers/index.js
+var handlers = {
+  blockquote,
+  break: hardBreak,
+  code,
+  delete: strikethrough,
+  emphasis,
+  footnoteReference,
+  footnote,
+  heading,
+  html,
+  imageReference,
+  image,
+  inlineCode,
+  linkReference,
+  link,
+  listItem,
+  list: list2,
+  paragraph,
+  root,
+  strong,
+  table,
+  text: text3,
+  thematicBreak: thematicBreak2,
+  toml: ignore,
+  yaml: ignore,
+  definition: ignore,
+  footnoteDefinition: ignore
+};
+function ignore() {
+  return null;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-hast@12.1.0/node_modules/mdast-util-to-hast/lib/index.js
+var own9 = {}.hasOwnProperty;
+function factory(tree, options) {
+  const settings = options || {};
+  const dangerous = settings.allowDangerousHtml || false;
+  const footnoteById = {};
+  h2.dangerous = dangerous;
+  h2.clobberPrefix = settings.clobberPrefix === void 0 || settings.clobberPrefix === null ? "user-content-" : settings.clobberPrefix;
+  h2.footnoteLabel = settings.footnoteLabel || "Footnotes";
+  h2.footnoteBackLabel = settings.footnoteBackLabel || "Back to content";
+  h2.definition = definitions(tree);
+  h2.footnoteById = footnoteById;
+  h2.footnoteOrder = [];
+  h2.footnoteCounts = {};
+  h2.augment = augment;
+  h2.handlers = __spreadValues(__spreadValues({}, handlers), settings.handlers);
+  h2.unknownHandler = settings.unknownHandler;
+  h2.passThrough = settings.passThrough;
+  visit2(tree, "footnoteDefinition", (definition2) => {
+    const id = String(definition2.identifier).toUpperCase();
+    if (!own9.call(footnoteById, id)) {
+      footnoteById[id] = definition2;
+    }
+  });
+  return h2;
+  function augment(left, right) {
+    if (left && "data" in left && left.data) {
+      const data2 = left.data;
+      if (data2.hName) {
+        if (right.type !== "element") {
+          right = {
+            type: "element",
+            tagName: "",
+            properties: {},
+            children: []
+          };
+        }
+        right.tagName = data2.hName;
+      }
+      if (right.type === "element" && data2.hProperties) {
+        right.properties = __spreadValues(__spreadValues({}, right.properties), data2.hProperties);
+      }
+      if ("children" in right && right.children && data2.hChildren) {
+        right.children = data2.hChildren;
+      }
+    }
+    if (left) {
+      const ctx = "type" in left ? left : { position: left };
+      if (!generated(ctx)) {
+        right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
+      }
+    }
+    return right;
+  }
+  function h2(node, tagName, props, children) {
+    if (Array.isArray(props)) {
+      children = props;
+      props = {};
+    }
+    return augment(node, {
+      type: "element",
+      tagName,
+      properties: props || {},
+      children: children || []
+    });
+  }
+}
+function toHast(tree, options) {
+  const h2 = factory(tree, options);
+  const node = one2(h2, tree, null);
+  const foot = footer(h2);
+  if (foot) {
+    node.children.push(u("text", "\n"), foot);
+  }
+  return Array.isArray(node) ? { type: "root", children: node } : node;
+}
+
+// ../../node_modules/.pnpm/remark-rehype@10.1.0/node_modules/remark-rehype/lib/index.js
+var remarkRehype = function(destination, options) {
+  return destination && "run" in destination ? bridge(destination, options) : mutate(destination || options);
+};
+var lib_default = remarkRehype;
+function bridge(destination, options) {
+  return (node, file, next) => {
+    destination.run(toHast(node, options), file, (error) => {
+      next(error);
+    });
+  };
+}
+function mutate(options) {
+  return (node) => toHast(node, options);
+}
+
+// ../../node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/walker.js
+var WalkerBase = class {
+  constructor() {
+    this.should_skip = false;
+    this.should_remove = false;
+    this.replacement = null;
+    this.context = {
+      skip: () => this.should_skip = true,
+      remove: () => this.should_remove = true,
+      replace: (node) => this.replacement = node
+    };
+  }
+  replace(parent, prop, index3, node) {
+    if (parent) {
+      if (index3 !== null) {
+        parent[prop][index3] = node;
+      } else {
+        parent[prop] = node;
+      }
+    }
+  }
+  remove(parent, prop, index3) {
+    if (parent) {
+      if (index3 !== null) {
+        parent[prop].splice(index3, 1);
+      } else {
+        delete parent[prop];
+      }
+    }
+  }
+};
+
+// ../../node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/sync.js
+var SyncWalker = class extends WalkerBase {
+  constructor(enter, leave) {
+    super();
+    this.enter = enter;
+    this.leave = leave;
+  }
+  visit(node, parent, prop, index3) {
+    if (node) {
+      if (this.enter) {
+        const _should_skip = this.should_skip;
+        const _should_remove = this.should_remove;
+        const _replacement = this.replacement;
+        this.should_skip = false;
+        this.should_remove = false;
+        this.replacement = null;
+        this.enter.call(this.context, node, parent, prop, index3);
+        if (this.replacement) {
+          node = this.replacement;
+          this.replace(parent, prop, index3, node);
+        }
+        if (this.should_remove) {
+          this.remove(parent, prop, index3);
+        }
+        const skipped = this.should_skip;
+        const removed = this.should_remove;
+        this.should_skip = _should_skip;
+        this.should_remove = _should_remove;
+        this.replacement = _replacement;
+        if (skipped)
+          return node;
+        if (removed)
+          return null;
+      }
+      for (const key in node) {
+        const value = node[key];
+        if (typeof value !== "object") {
+          continue;
+        } else if (Array.isArray(value)) {
+          for (let i = 0; i < value.length; i += 1) {
+            if (value[i] !== null && typeof value[i].type === "string") {
+              if (!this.visit(value[i], node, key, i)) {
+                i--;
+              }
+            }
+          }
+        } else if (value !== null && typeof value.type === "string") {
+          this.visit(value, node, key, null);
+        }
+      }
+      if (this.leave) {
+        const _replacement = this.replacement;
+        const _should_remove = this.should_remove;
+        this.replacement = null;
+        this.should_remove = false;
+        this.leave.call(this.context, node, parent, prop, index3);
+        if (this.replacement) {
+          node = this.replacement;
+          this.replace(parent, prop, index3, node);
+        }
+        if (this.should_remove) {
+          this.remove(parent, prop, index3);
+        }
+        const removed = this.should_remove;
+        this.replacement = _replacement;
+        this.should_remove = _should_remove;
+        if (removed)
+          return null;
+      }
+    }
+    return node;
+  }
+};
+
+// ../../node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/index.js
+function walk(ast, { enter, leave }) {
+  const instance = new SyncWalker(enter, leave);
+  return instance.visit(ast, null);
+}
+
+// ../../node_modules/.pnpm/estree-util-build-jsx@2.0.0/node_modules/estree-util-build-jsx/index.js
+var regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g;
+function buildJsx(tree, options = {}) {
+  var automatic = options.runtime === "automatic";
+  var annotations = {};
+  var imports = {};
+  walk(tree, { enter, leave });
+  return tree;
+  function enter(node) {
+    var comments;
+    var index3;
+    var match;
+    if (node.type === "Program") {
+      comments = node.comments || [];
+      index3 = -1;
+      while (++index3 < comments.length) {
+        regex.lastIndex = 0;
+        while (match = regex.exec(comments[index3].value)) {
+          annotations[match[1]] = match[2];
+        }
+      }
+      if (annotations.jsxRuntime) {
+        if (annotations.jsxRuntime === "automatic") {
+          automatic = true;
+          if (annotations.jsx) {
+            throw new Error("Unexpected `@jsx` pragma w/ automatic runtime");
+          }
+          if (annotations.jsxFrag) {
+            throw new Error("Unexpected `@jsxFrag` pragma w/ automatic runtime");
+          }
+        } else if (annotations.jsxRuntime === "classic") {
+          automatic = false;
+          if (annotations.jsxImportSource) {
+            throw new Error("Unexpected `@jsxImportSource` w/ classic runtime");
+          }
+        } else {
+          throw new Error("Unexpected `jsxRuntime` `" + annotations.jsxRuntime + "`, expected `automatic` or `classic`");
+        }
+      }
+    }
+  }
+  function leave(node) {
+    var parameters = [];
+    var children = [];
+    var objects = [];
+    var fields = [];
+    var index3 = -1;
+    var child;
+    var name3;
+    var props;
+    var attributes;
+    var attribute;
+    var spread;
+    var key;
+    var callee;
+    var specifiers;
+    var prop;
+    var value;
+    if (node.type === "Program") {
+      specifiers = [];
+      if (imports.fragment) {
+        specifiers.push({
+          type: "ImportSpecifier",
+          imported: { type: "Identifier", name: "Fragment" },
+          local: { type: "Identifier", name: "_Fragment" }
+        });
+      }
+      if (imports.jsx) {
+        specifiers.push({
+          type: "ImportSpecifier",
+          imported: { type: "Identifier", name: "jsx" },
+          local: { type: "Identifier", name: "_jsx" }
+        });
+      }
+      if (imports.jsxs) {
+        specifiers.push({
+          type: "ImportSpecifier",
+          imported: { type: "Identifier", name: "jsxs" },
+          local: { type: "Identifier", name: "_jsxs" }
+        });
+      }
+      if (specifiers.length > 0) {
+        node.body.unshift({
+          type: "ImportDeclaration",
+          specifiers,
+          source: {
+            type: "Literal",
+            value: (annotations.jsxImportSource || options.importSource || "react") + "/jsx-runtime"
+          }
+        });
+      }
+    }
+    if (node.type !== "JSXElement" && node.type !== "JSXFragment") {
+      return;
+    }
+    while (++index3 < node.children.length) {
+      child = node.children[index3];
+      if (child.type === "JSXExpressionContainer") {
+        if (child.expression.type !== "JSXEmptyExpression") {
+          children.push(child.expression);
+        }
+      } else if (child.type === "JSXText") {
+        value = child.value.replace(/\t/g, " ").replace(/ *(\r?\n|\r) */g, "\n").replace(/\n+/g, "\n").replace(/\n+$/, "").replace(/\n/g, " ");
+        if (value) {
+          children.push(create(child, { type: "Literal", value }));
+        }
+      } else {
+        children.push(child);
+      }
+    }
+    if (node.type === "JSXElement") {
+      name3 = toIdentifier(node.openingElement.name);
+      if (name3.type === "Identifier" && /^[a-z]/.test(name3.name)) {
+        name3 = create(name3, { type: "Literal", value: name3.name });
+      }
+      attributes = node.openingElement.attributes;
+      index3 = -1;
+      while (++index3 < attributes.length) {
+        attribute = attributes[index3];
+        if (attribute.type === "JSXSpreadAttribute") {
+          if (fields.length > 0) {
+            objects.push({ type: "ObjectExpression", properties: fields });
+            fields = [];
+          }
+          objects.push(attribute.argument);
+          spread = true;
+        } else {
+          prop = toProperty(attribute);
+          if (automatic && prop.key.type === "Identifier" && prop.key.name === "key") {
+            if (spread) {
+              throw new Error("Expected `key` to come before any spread expressions");
+            }
+            key = prop.value;
+          } else {
+            fields.push(prop);
+          }
+        }
+      }
+    } else if (automatic) {
+      imports.fragment = true;
+      name3 = { type: "Identifier", name: "_Fragment" };
+    } else {
+      name3 = toMemberExpression(annotations.jsxFrag || options.pragmaFrag || "React.Fragment");
+    }
+    if (automatic && children.length > 0) {
+      fields.push({
+        type: "Property",
+        key: { type: "Identifier", name: "children" },
+        value: children.length > 1 ? { type: "ArrayExpression", elements: children } : children[0],
+        kind: "init",
+        method: false,
+        shorthand: false,
+        computed: false
+      });
+    } else {
+      parameters = children;
+    }
+    if (fields.length > 0) {
+      objects.push({ type: "ObjectExpression", properties: fields });
+    }
+    if (objects.length > 1) {
+      if (objects[0].type !== "ObjectExpression") {
+        objects.unshift({ type: "ObjectExpression", properties: [] });
+      }
+      props = {
+        type: "CallExpression",
+        callee: toMemberExpression("Object.assign"),
+        arguments: objects,
+        optional: false
+      };
+    } else if (objects.length > 0) {
+      props = objects[0];
+    }
+    if (automatic) {
+      if (children.length > 1) {
+        imports.jsxs = true;
+        callee = { type: "Identifier", name: "_jsxs" };
+      } else {
+        imports.jsx = true;
+        callee = { type: "Identifier", name: "_jsx" };
+      }
+      parameters.push(props || { type: "ObjectExpression", properties: [] });
+      if (key) {
+        parameters.push(key);
+      }
+    } else {
+      if (props || parameters.length > 0) {
+        parameters.unshift(props || { type: "Literal", value: null });
+      }
+      callee = toMemberExpression(annotations.jsx || options.pragma || "React.createElement");
+    }
+    parameters.unshift(name3);
+    this.replace(create(node, {
+      type: "CallExpression",
+      callee,
+      arguments: parameters,
+      optional: false
+    }));
+  }
+}
+function toProperty(node) {
+  var value;
+  if (node.value) {
+    if (node.value.type === "JSXExpressionContainer") {
+      value = node.value.expression;
+    } else {
+      value = node.value;
+      delete value.raw;
+    }
+  } else {
+    value = { type: "Literal", value: true };
+  }
+  return create(node, {
+    type: "Property",
+    key: toIdentifier(node.name),
+    value,
+    kind: "init",
+    method: false,
+    shorthand: false,
+    computed: false
+  });
+}
+function toIdentifier(node) {
+  var replace2;
+  var id;
+  if (node.type === "JSXMemberExpression") {
+    id = toIdentifier(node.property);
+    replace2 = {
+      type: "MemberExpression",
+      object: toIdentifier(node.object),
+      property: id,
+      computed: id.type === "Literal",
+      optional: false
+    };
+  } else if (node.type === "JSXNamespacedName") {
+    replace2 = {
+      type: "Literal",
+      value: node.namespace.name + ":" + node.name.name
+    };
+  } else {
+    replace2 = name(node.name) ? { type: "Identifier", name: node.name } : { type: "Literal", value: node.name };
+  }
+  return create(node, replace2);
+}
+function toMemberExpression(id) {
+  var identifiers = id.split(".");
+  var index3 = -1;
+  var result;
+  var prop;
+  while (++index3 < identifiers.length) {
+    prop = name(identifiers[index3]) ? { type: "Identifier", name: identifiers[index3] } : { type: "Literal", value: identifiers[index3] };
+    result = index3 ? {
+      type: "MemberExpression",
+      object: result,
+      property: prop,
+      computed: index3 && prop.type === "Literal",
+      optional: false
+    } : prop;
+  }
+  return result;
+}
+function create(from, node) {
+  var fields = ["start", "end", "loc", "range", "comments"];
+  var index3 = -1;
+  var field;
+  while (++index3 < fields.length) {
+    field = fields[index3];
+    if (field in from) {
+      node[field] = from[field];
+    }
+  }
+  return node;
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/util/estree-util-create.js
+function create2(template, node) {
+  const fields = ["start", "end", "loc", "range", "comments"];
+  let index3 = -1;
+  while (++index3 < fields.length) {
+    const field = fields[index3];
+    if (field in template) {
+      node[field] = template[field];
+    }
+  }
+  return node;
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/util/estree-util-specifiers-to-declarations.js
+function specifiersToDeclarations(specifiers, init) {
+  let index3 = -1;
+  const declarations = [];
+  const otherSpecifiers = [];
+  let importNamespaceSpecifier;
+  while (++index3 < specifiers.length) {
+    const specifier = specifiers[index3];
+    if (specifier.type === "ImportNamespaceSpecifier") {
+      importNamespaceSpecifier = specifier;
+    } else {
+      otherSpecifiers.push(specifier);
+    }
+  }
+  if (importNamespaceSpecifier) {
+    declarations.push(create2(importNamespaceSpecifier, {
+      type: "VariableDeclarator",
+      id: importNamespaceSpecifier.local,
+      init
+    }));
+  }
+  declarations.push({
+    type: "VariableDeclarator",
+    id: {
+      type: "ObjectPattern",
+      properties: otherSpecifiers.map((specifier) => {
+        let key = specifier.type === "ImportSpecifier" ? specifier.imported : specifier.type === "ExportSpecifier" ? specifier.exported : { type: "Identifier", name: "default" };
+        let value = specifier.local;
+        if (specifier.type === "ExportSpecifier") {
+          value = key;
+          key = specifier.local;
+        }
+        return create2(specifier, {
+          type: "Property",
+          kind: "init",
+          shorthand: key.name === value.name,
+          method: false,
+          computed: false,
+          key,
+          value
+        });
+      })
+    },
+    init: importNamespaceSpecifier ? { type: "Identifier", name: importNamespaceSpecifier.local.name } : init
+  });
+  return declarations;
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/util/estree-util-to-id-or-member-expression.js
+var toIdOrMemberExpression = toIdOrMemberExpressionFactory("Identifier", "MemberExpression", name);
+var toJsxIdOrMemberExpression = toIdOrMemberExpressionFactory("JSXIdentifier", "JSXMemberExpression", isJsxIdentifierName);
+function toIdOrMemberExpressionFactory(idType, memberType, isIdentifier) {
+  return toIdOrMemberExpression2;
+  function toIdOrMemberExpression2(ids) {
+    let index3 = -1;
+    let object;
+    while (++index3 < ids.length) {
+      const name3 = ids[index3];
+      const valid3 = typeof name3 === "string" && isIdentifier(name3);
+      if (idType === "JSXIdentifier" && !valid3) {
+        throw new Error("Cannot turn `" + name3 + "` into a JSX identifier");
+      }
+      const id = valid3 ? { type: idType, name: name3 } : { type: "Literal", value: name3 };
+      object = object ? {
+        type: memberType,
+        object,
+        property: id,
+        computed: id.type === "Literal",
+        optional: false
+      } : id;
+    }
+    if (!object)
+      throw new Error("Expected non-empty `ids` to be passed");
+    if (object.type === "Literal")
+      throw new Error("Expected identifier as left-most value");
+    return object;
+  }
+}
+function isJsxIdentifierName(name3) {
+  let index3 = -1;
+  while (++index3 < name3.length) {
+    if (!(index3 ? jsxCont : start2)(name3.charCodeAt(index3)))
+      return false;
+  }
+  return index3 > 0;
+}
+function jsxCont(code3) {
+  return code3 === 45 || cont2(code3);
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/plugin/recma-jsx-build.js
+function recmaJsxBuild(options = {}) {
+  const { outputFormat } = options;
+  return (tree) => {
+    buildJsx(tree);
+    if (outputFormat === "function-body" && tree.body[0] && tree.body[0].type === "ImportDeclaration" && typeof tree.body[0].source.value === "string" && /\/jsx-runtime$/.test(tree.body[0].source.value)) {
+      tree.body[0] = {
+        type: "VariableDeclaration",
+        kind: "const",
+        declarations: specifiersToDeclarations(tree.body[0].specifiers, toIdOrMemberExpression(["arguments", 0]))
+      };
+    }
+  };
+}
+
+// ../../node_modules/.pnpm/is-reference@3.0.0/node_modules/is-reference/src/index.js
+function is_reference(node, parent) {
+  if (node.type === "MemberExpression") {
+    return !node.computed && is_reference(node.object, node);
+  }
+  if (node.type === "Identifier") {
+    if (!parent)
+      return true;
+    switch (parent.type) {
+      case "MemberExpression":
+        return parent.computed || node === parent.object;
+      case "MethodDefinition":
+        return parent.computed;
+      case "PropertyDefinition":
+        return parent.computed || node === parent.value;
+      case "Property":
+        return parent.computed || node === parent.value;
+      case "ExportSpecifier":
+      case "ImportSpecifier":
+        return node === parent.local;
+      case "LabeledStatement":
+      case "BreakStatement":
+      case "ContinueStatement":
+        return false;
+      default:
+        return true;
+    }
+  }
+  return false;
+}
+
+// ../../node_modules/.pnpm/periscopic@3.0.4/node_modules/periscopic/src/index.js
+function analyze(expression) {
+  const map2 = /* @__PURE__ */ new WeakMap();
+  const globals = /* @__PURE__ */ new Map();
+  const scope = new Scope3(null, false);
+  const references = [];
+  let current_scope = scope;
+  walk(expression, {
+    enter(node, parent) {
+      switch (node.type) {
+        case "Identifier":
+          if (is_reference(node, parent)) {
+            references.push([current_scope, node]);
+          }
+          break;
+        case "ImportDeclaration":
+          node.specifiers.forEach((specifier) => {
+            current_scope.declarations.set(specifier.local.name, specifier);
+          });
+          break;
+        case "FunctionExpression":
+        case "FunctionDeclaration":
+        case "ArrowFunctionExpression":
+          if (node.type === "FunctionDeclaration") {
+            if (node.id) {
+              current_scope.declarations.set(node.id.name, node);
+            }
+            map2.set(node, current_scope = new Scope3(current_scope, false));
+          } else {
+            map2.set(node, current_scope = new Scope3(current_scope, false));
+            if (node.type === "FunctionExpression" && node.id) {
+              current_scope.declarations.set(node.id.name, node);
+            }
+          }
+          node.params.forEach((param) => {
+            extract_names(param).forEach((name3) => {
+              current_scope.declarations.set(name3, node);
+            });
+          });
+          break;
+        case "ForStatement":
+        case "ForInStatement":
+        case "ForOfStatement":
+          map2.set(node, current_scope = new Scope3(current_scope, true));
+          break;
+        case "BlockStatement":
+          map2.set(node, current_scope = new Scope3(current_scope, true));
+          break;
+        case "ClassDeclaration":
+        case "VariableDeclaration":
+          current_scope.add_declaration(node);
+          break;
+        case "CatchClause":
+          map2.set(node, current_scope = new Scope3(current_scope, true));
+          if (node.param) {
+            extract_names(node.param).forEach((name3) => {
+              current_scope.declarations.set(name3, node.param);
+            });
+          }
+          break;
+      }
+    },
+    leave(node) {
+      if (map2.has(node)) {
+        current_scope = current_scope.parent;
+      }
+    }
+  });
+  for (let i = references.length - 1; i >= 0; --i) {
+    const [scope2, reference] = references[i];
+    if (!scope2.references.has(reference.name)) {
+      add_reference(scope2, reference.name);
+    }
+    if (!scope2.find_owner(reference.name)) {
+      globals.set(reference.name, reference);
+    }
+  }
+  return { map: map2, scope, globals };
+}
+function add_reference(scope, name3) {
+  scope.references.add(name3);
+  if (scope.parent)
+    add_reference(scope.parent, name3);
+}
+var Scope3 = class {
+  constructor(parent, block) {
+    this.parent = parent;
+    this.block = block;
+    this.declarations = /* @__PURE__ */ new Map();
+    this.initialised_declarations = /* @__PURE__ */ new Set();
+    this.references = /* @__PURE__ */ new Set();
+  }
+  add_declaration(node) {
+    if (node.type === "VariableDeclaration") {
+      if (node.kind === "var" && this.block && this.parent) {
+        this.parent.add_declaration(node);
+      } else {
+        const handle_declarator = (declarator) => {
+          extract_names(declarator.id).forEach((name3) => {
+            this.declarations.set(name3, node);
+            if (declarator.init)
+              this.initialised_declarations.add(name3);
+          });
+          ;
+        };
+        node.declarations.forEach(handle_declarator);
+      }
+    } else if (node.id) {
+      this.declarations.set(node.id.name, node);
+    }
+  }
+  find_owner(name3) {
+    if (this.declarations.has(name3))
+      return this;
+    return this.parent && this.parent.find_owner(name3);
+  }
+  has(name3) {
+    return this.declarations.has(name3) || !!this.parent && this.parent.has(name3);
+  }
+};
+function extract_names(param) {
+  return extract_identifiers(param).map((node) => node.name);
+}
+function extract_identifiers(param, nodes2 = []) {
+  switch (param.type) {
+    case "Identifier":
+      nodes2.push(param);
+      break;
+    case "MemberExpression":
+      let object = param;
+      while (object.type === "MemberExpression") {
+        object = object.object;
+      }
+      nodes2.push(object);
+      break;
+    case "ObjectPattern":
+      const handle_prop = (prop) => {
+        if (prop.type === "RestElement") {
+          extract_identifiers(prop.argument, nodes2);
+        } else {
+          extract_identifiers(prop.value, nodes2);
+        }
+      };
+      param.properties.forEach(handle_prop);
+      break;
+    case "ArrayPattern":
+      const handle_element = (element3) => {
+        if (element3)
+          extract_identifiers(element3, nodes2);
+      };
+      param.elements.forEach(handle_element);
+      break;
+    case "RestElement":
+      extract_identifiers(param.argument, nodes2);
+      break;
+    case "AssignmentPattern":
+      extract_identifiers(param.left, nodes2);
+      break;
+  }
+  return nodes2;
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/util/estree-util-declaration-to-expression.js
+function declarationToExpression(declaration) {
+  if (declaration.type === "FunctionDeclaration") {
+    return __spreadProps(__spreadValues({}, declaration), { type: "FunctionExpression" });
+  }
+  if (declaration.type === "ClassDeclaration") {
+    return __spreadProps(__spreadValues({}, declaration), { type: "ClassExpression" });
+  }
+  throw new Error("Cannot turn `" + declaration.type + "` into an expression");
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/util/estree-util-is-declaration.js
+function isDeclaration(node) {
+  const type2 = node && typeof node === "object" && node.type;
+  return Boolean(type2 === "FunctionDeclaration" || type2 === "ClassDeclaration" || type2 === "VariableDeclaration");
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/plugin/recma-document.js
+function recmaDocument(options = {}) {
+  const {
+    baseUrl,
+    useDynamicImport,
+    outputFormat = "program",
+    pragma = "React.createElement",
+    pragmaFrag = "React.Fragment",
+    pragmaImportSource = "react",
+    jsxImportSource = "react",
+    jsxRuntime = "automatic"
+  } = options;
+  return (tree, file) => {
+    const exportedIdentifiers = [];
+    const replacement = [];
+    const pragmas = [];
+    let exportAllCount = 0;
+    let layout;
+    let content3;
+    let child;
+    if (!tree.comments)
+      tree.comments = [];
+    if (jsxRuntime) {
+      pragmas.push("@jsxRuntime " + jsxRuntime);
+    }
+    if (jsxRuntime === "automatic" && jsxImportSource) {
+      pragmas.push("@jsxImportSource " + jsxImportSource);
+    }
+    if (jsxRuntime === "classic" && pragma) {
+      pragmas.push("@jsx " + pragma);
+    }
+    if (jsxRuntime === "classic" && pragmaFrag) {
+      pragmas.push("@jsxFrag " + pragmaFrag);
+    }
+    if (pragmas.length > 0) {
+      tree.comments.unshift({ type: "Block", value: pragmas.join(" ") });
+    }
+    if (jsxRuntime === "classic" && pragmaImportSource) {
+      if (!pragma) {
+        throw new Error("Missing `pragma` in classic runtime with `pragmaImportSource`");
+      }
+      handleEsm({
+        type: "ImportDeclaration",
+        specifiers: [
+          {
+            type: "ImportDefaultSpecifier",
+            local: { type: "Identifier", name: pragma.split(".")[0] }
+          }
+        ],
+        source: { type: "Literal", value: pragmaImportSource }
+      });
+    }
+    for (child of tree.body) {
+      if (child.type === "ExportDefaultDeclaration") {
+        if (layout) {
+          file.fail("Cannot specify multiple layouts (previous: " + stringifyPosition(positionFromEstree(layout)) + ")", positionFromEstree(child), "recma-document:duplicate-layout");
+        }
+        layout = child;
+        replacement.push({
+          type: "VariableDeclaration",
+          kind: "const",
+          declarations: [
+            {
+              type: "VariableDeclarator",
+              id: { type: "Identifier", name: "MDXLayout" },
+              init: isDeclaration(child.declaration) ? declarationToExpression(child.declaration) : child.declaration
+            }
+          ]
+        });
+      } else if (child.type === "ExportNamedDeclaration" && child.source) {
+        const source = child.source;
+        child.specifiers = child.specifiers.filter((specifier) => {
+          if (specifier.exported.name === "default") {
+            if (layout) {
+              file.fail("Cannot specify multiple layouts (previous: " + stringifyPosition(positionFromEstree(layout)) + ")", positionFromEstree(child), "recma-document:duplicate-layout");
+            }
+            layout = specifier;
+            handleEsm(create2(specifier, {
+              type: "ImportDeclaration",
+              specifiers: [
+                specifier.local.name === "default" ? {
+                  type: "ImportDefaultSpecifier",
+                  local: { type: "Identifier", name: "MDXLayout" }
+                } : create2(specifier.local, {
+                  type: "ImportSpecifier",
+                  imported: specifier.local,
+                  local: { type: "Identifier", name: "MDXLayout" }
+                })
+              ],
+              source: create2(source, { type: "Literal", value: source.value })
+            }));
+            return false;
+          }
+          return true;
+        });
+        if (child.specifiers.length > 0) {
+          handleExport(child);
+        }
+      } else if (child.type === "ExportNamedDeclaration" || child.type === "ExportAllDeclaration") {
+        handleExport(child);
+      } else if (child.type === "ImportDeclaration") {
+        handleEsm(child);
+      } else if (child.type === "ExpressionStatement" && (child.expression.type === "JSXFragment" || child.expression.type === "JSXElement")) {
+        content3 = true;
+        replacement.push(createMdxContent(child.expression));
+      } else {
+        replacement.push(child);
+      }
+    }
+    if (!content3) {
+      replacement.push(createMdxContent());
+    }
+    exportedIdentifiers.push(["MDXContent", "default"]);
+    if (outputFormat === "function-body") {
+      replacement.push({
+        type: "ReturnStatement",
+        argument: {
+          type: "ObjectExpression",
+          properties: [
+            ...Array.from({ length: exportAllCount }).map((_, index3) => ({
+              type: "SpreadElement",
+              argument: { type: "Identifier", name: "_exportAll" + (index3 + 1) }
+            })),
+            ...exportedIdentifiers.map((d) => {
+              const prop = {
+                type: "Property",
+                kind: "init",
+                method: false,
+                computed: false,
+                shorthand: typeof d === "string",
+                key: {
+                  type: "Identifier",
+                  name: typeof d === "string" ? d : d[1]
+                },
+                value: {
+                  type: "Identifier",
+                  name: typeof d === "string" ? d : d[0]
+                }
+              };
+              return prop;
+            })
+          ]
+        }
+      });
+    } else {
+      replacement.push({
+        type: "ExportDefaultDeclaration",
+        declaration: { type: "Identifier", name: "MDXContent" }
+      });
+    }
+    tree.body = replacement;
+    function handleExport(node) {
+      if (node.type === "ExportNamedDeclaration") {
+        if (node.declaration) {
+          exportedIdentifiers.push(...analyze(node.declaration).scope.declarations.keys());
+        }
+        for (child of node.specifiers) {
+          exportedIdentifiers.push(child.exported.name);
+        }
+      }
+      handleEsm(node);
+    }
+    function handleEsm(node) {
+      if (baseUrl && node.source) {
+        let value = String(node.source.value);
+        try {
+          value = String(new URL(value));
+        } catch (e) {
+          if (/^\.{0,2}\//.test(value)) {
+            value = String(new URL(value, baseUrl));
+          }
+        }
+        node.source = create2(node.source, { type: "Literal", value });
+      }
+      let replace2;
+      let init;
+      if (outputFormat === "function-body") {
+        if (node.type === "ImportDeclaration" || node.type === "ExportAllDeclaration" || node.type === "ExportNamedDeclaration" && node.source) {
+          if (!useDynamicImport) {
+            file.fail("Cannot use `import` or `export \u2026 from` in `evaluate` (outputting a function body) by default: please set `useDynamicImport: true` (and probably specify a `baseUrl`)", positionFromEstree(node), "recma-document:invalid-esm-statement");
+          }
+          if (!node.source) {
+            throw new Error("Expected `node.source` to be defined");
+          }
+          init = {
+            type: "AwaitExpression",
+            argument: create2(node, {
+              type: "ImportExpression",
+              source: node.source
+            })
+          };
+          if ((node.type === "ImportDeclaration" || node.type === "ExportNamedDeclaration") && node.specifiers.length === 0) {
+            replace2 = { type: "ExpressionStatement", expression: init };
+          } else {
+            replace2 = {
+              type: "VariableDeclaration",
+              kind: "const",
+              declarations: node.type === "ExportAllDeclaration" ? [
+                {
+                  type: "VariableDeclarator",
+                  id: {
+                    type: "Identifier",
+                    name: "_exportAll" + ++exportAllCount
+                  },
+                  init
+                }
+              ] : specifiersToDeclarations(node.specifiers, init)
+            };
+          }
+        } else if (node.declaration) {
+          replace2 = node.declaration;
+        } else {
+          const declarators = node.specifiers.filter((specifier) => specifier.local.name !== specifier.exported.name).map((specifier) => ({
+            type: "VariableDeclarator",
+            id: specifier.exported,
+            init: specifier.local
+          }));
+          if (declarators.length > 0) {
+            replace2 = {
+              type: "VariableDeclaration",
+              kind: "const",
+              declarations: declarators
+            };
+          }
+        }
+      } else {
+        replace2 = node;
+      }
+      if (replace2) {
+        replacement.push(replace2);
+      }
+    }
+  };
+  function createMdxContent(content3) {
+    const element3 = {
+      type: "JSXElement",
+      openingElement: {
+        type: "JSXOpeningElement",
+        name: { type: "JSXIdentifier", name: "MDXLayout" },
+        attributes: [
+          {
+            type: "JSXSpreadAttribute",
+            argument: { type: "Identifier", name: "props" }
+          }
+        ],
+        selfClosing: false
+      },
+      closingElement: {
+        type: "JSXClosingElement",
+        name: { type: "JSXIdentifier", name: "MDXLayout" }
+      },
+      children: [
+        {
+          type: "JSXElement",
+          openingElement: {
+            type: "JSXOpeningElement",
+            name: { type: "JSXIdentifier", name: "_createMdxContent" },
+            attributes: [],
+            selfClosing: true
+          },
+          closingElement: null,
+          children: []
+        }
+      ]
+    };
+    const consequent = element3;
+    let argument = content3 || { type: "Literal", value: null };
+    if (argument && argument.type === "JSXFragment" && argument.children.length === 1 && argument.children[0].type === "JSXElement") {
+      argument = argument.children[0];
+    }
+    return {
+      type: "FunctionDeclaration",
+      id: { type: "Identifier", name: "MDXContent" },
+      params: [
+        {
+          type: "AssignmentPattern",
+          left: { type: "Identifier", name: "props" },
+          right: { type: "ObjectExpression", properties: [] }
+        }
+      ],
+      body: {
+        type: "BlockStatement",
+        body: [
+          {
+            type: "ReturnStatement",
+            argument: {
+              type: "ConditionalExpression",
+              test: { type: "Identifier", name: "MDXLayout" },
+              consequent,
+              alternate: {
+                type: "CallExpression",
+                callee: { type: "Identifier", name: "_createMdxContent" },
+                arguments: [],
+                optional: false
+              }
+            }
+          },
+          {
+            type: "FunctionDeclaration",
+            id: { type: "Identifier", name: "_createMdxContent" },
+            params: [],
+            body: {
+              type: "BlockStatement",
+              body: [{ type: "ReturnStatement", argument }]
+            }
+          }
+        ]
+      }
+    };
+  }
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/util/estree-util-to-binary-addition.js
+function toBinaryAddition(expressions) {
+  let index3 = -1;
+  let left;
+  while (++index3 < expressions.length) {
+    const right = expressions[index3];
+    left = left ? { type: "BinaryExpression", left, operator: "+", right } : right;
+  }
+  if (!left)
+    throw new Error("Expected non-empty `expressions` to be passed");
+  return left;
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/plugin/recma-jsx-rewrite.js
+var own10 = {}.hasOwnProperty;
+function recmaJsxRewrite(options = {}) {
+  const { development: development2, providerImportSource, outputFormat } = options;
+  return (tree, file) => {
+    const scopeInfo = analyze(tree);
+    const fnStack = [];
+    let importProvider;
+    let createErrorHelper;
+    let currentScope;
+    walk(tree, {
+      enter(_node) {
+        const node = _node;
+        if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") {
+          fnStack.push({
+            objects: [],
+            components: [],
+            tags: [],
+            references: {},
+            node
+          });
+        }
+        let fnScope = fnStack[0];
+        if (!fnScope || !isNamedFunction(fnScope.node, "MDXContent") && !providerImportSource) {
+          return;
+        }
+        if (fnStack[1] && isNamedFunction(fnStack[1].node, "_createMdxContent")) {
+          fnScope = fnStack[1];
+        }
+        const newScope = scopeInfo.map.get(node);
+        if (newScope) {
+          newScope.node = node;
+          currentScope = newScope;
+        }
+        if (currentScope && node.type === "JSXElement") {
+          let name3 = node.openingElement.name;
+          if (name3.type === "JSXMemberExpression") {
+            const ids = [];
+            while (name3.type === "JSXMemberExpression") {
+              ids.unshift(name3.property.name);
+              name3 = name3.object;
+            }
+            ids.unshift(name3.name);
+            const fullId = ids.join(".");
+            const id = name3.name;
+            if (!own10.call(fnScope.references, fullId)) {
+              fnScope.references[fullId] = { node, component: true };
+            }
+            if (!fnScope.objects.includes(id) && !inScope(currentScope, id)) {
+              fnScope.objects.push(id);
+            }
+          } else if (name3.type === "JSXNamespacedName") {
+          } else if (name(name3.name) && !/^[a-z]/.test(name3.name)) {
+            const id = name3.name;
+            if (!inScope(currentScope, id)) {
+              if (id !== "MDXLayout" && !own10.call(fnScope.references, id)) {
+                fnScope.references[id] = { node, component: true };
+              }
+              if (!fnScope.components.includes(id)) {
+                fnScope.components.push(id);
+              }
+            }
+          } else if (node.data && node.data._mdxExplicitJsx) {
+          } else {
+            const id = name3.name;
+            if (!fnScope.tags.includes(id)) {
+              fnScope.tags.push(id);
+            }
+            node.openingElement.name = toJsxIdOrMemberExpression([
+              "_components",
+              id
+            ]);
+            if (node.closingElement) {
+              node.closingElement.name = toJsxIdOrMemberExpression([
+                "_components",
+                id
+              ]);
+            }
+          }
+        }
+      },
+      leave(node) {
+        const defaults = [];
+        const actual = [];
+        const parameters = [];
+        const declarations = [];
+        if (currentScope && currentScope.node === node) {
+          currentScope = currentScope.parent;
+        }
+        if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") {
+          const fn = node;
+          const scope = fnStack[fnStack.length - 1];
+          let name3;
+          for (name3 of scope.tags) {
+            defaults.push({
+              type: "Property",
+              kind: "init",
+              key: name(name3) ? { type: "Identifier", name: name3 } : { type: "Literal", value: name3 },
+              value: { type: "Literal", value: name3 },
+              method: false,
+              shorthand: false,
+              computed: false
+            });
+          }
+          actual.push(...scope.components);
+          for (name3 of scope.objects) {
+            if (!actual.includes(name3)) {
+              actual.push(name3);
+            }
+          }
+          let key;
+          for (key in scope.references) {
+            if (own10.call(scope.references, key)) {
+              const parts = key.split(".");
+              let index3 = 0;
+              while (++index3 < parts.length) {
+                const partial = parts.slice(0, index3).join(".");
+                if (!own10.call(scope.references, partial)) {
+                  scope.references[partial] = {
+                    node: scope.references[key].node,
+                    component: false
+                  };
+                }
+              }
+            }
+          }
+          if (defaults.length > 0 || actual.length > 0) {
+            if (providerImportSource) {
+              importProvider = true;
+              parameters.push({
+                type: "CallExpression",
+                callee: { type: "Identifier", name: "_provideComponents" },
+                arguments: [],
+                optional: false
+              });
+            }
+            if (isNamedFunction(scope.node, "MDXContent") || isNamedFunction(scope.node, "_createMdxContent")) {
+              parameters.push(toIdOrMemberExpression(["props", "components"]));
+            }
+            if (defaults.length > 0 || parameters.length > 1) {
+              parameters.unshift({
+                type: "ObjectExpression",
+                properties: defaults
+              });
+            }
+            let componentsInit = parameters.length > 1 ? {
+              type: "CallExpression",
+              callee: toIdOrMemberExpression(["Object", "assign"]),
+              arguments: parameters,
+              optional: false
+            } : parameters[0].type === "MemberExpression" ? {
+              type: "LogicalExpression",
+              operator: "||",
+              left: parameters[0],
+              right: { type: "ObjectExpression", properties: [] }
+            } : parameters[0];
+            let componentsPattern;
+            if (actual.length > 0) {
+              componentsPattern = {
+                type: "ObjectPattern",
+                properties: actual.map((name4) => ({
+                  type: "Property",
+                  kind: "init",
+                  key: {
+                    type: "Identifier",
+                    name: name4 === "MDXLayout" ? "wrapper" : name4
+                  },
+                  value: { type: "Identifier", name: name4 },
+                  method: false,
+                  shorthand: name4 !== "MDXLayout",
+                  computed: false
+                }))
+              };
+            }
+            if (scope.tags.length > 0) {
+              declarations.push({
+                type: "VariableDeclarator",
+                id: { type: "Identifier", name: "_components" },
+                init: componentsInit
+              });
+              componentsInit = { type: "Identifier", name: "_components" };
+            }
+            if (componentsPattern) {
+              declarations.push({
+                type: "VariableDeclarator",
+                id: componentsPattern,
+                init: componentsInit
+              });
+            }
+            if (fn.body.type !== "BlockStatement") {
+              fn.body = {
+                type: "BlockStatement",
+                body: [{ type: "ReturnStatement", argument: fn.body }]
+              };
+            }
+            const statements = [
+              {
+                type: "VariableDeclaration",
+                kind: "const",
+                declarations
+              }
+            ];
+            const references = Object.keys(scope.references).sort();
+            let index3 = -1;
+            while (++index3 < references.length) {
+              const id = references[index3];
+              const info = scope.references[id];
+              const place = stringifyPosition(positionFromEstree(info.node));
+              const parameters2 = [
+                { type: "Literal", value: id },
+                { type: "Literal", value: info.component }
+              ];
+              createErrorHelper = true;
+              if (development2 && place !== "1:1-1:1") {
+                parameters2.push({ type: "Literal", value: place });
+              }
+              statements.push({
+                type: "IfStatement",
+                test: {
+                  type: "UnaryExpression",
+                  operator: "!",
+                  prefix: true,
+                  argument: toIdOrMemberExpression(id.split("."))
+                },
+                consequent: {
+                  type: "ExpressionStatement",
+                  expression: {
+                    type: "CallExpression",
+                    callee: { type: "Identifier", name: "_missingMdxReference" },
+                    arguments: parameters2,
+                    optional: false
+                  }
+                },
+                alternate: null
+              });
+            }
+            fn.body.body.unshift(...statements);
+          }
+          fnStack.pop();
+        }
+      }
+    });
+    if (importProvider && providerImportSource) {
+      tree.body.unshift(createImportProvider(providerImportSource, outputFormat));
+    }
+    if (createErrorHelper) {
+      const message = [
+        { type: "Literal", value: "Expected " },
+        {
+          type: "ConditionalExpression",
+          test: { type: "Identifier", name: "component" },
+          consequent: { type: "Literal", value: "component" },
+          alternate: { type: "Literal", value: "object" }
+        },
+        { type: "Literal", value: " `" },
+        { type: "Identifier", name: "id" },
+        {
+          type: "Literal",
+          value: "` to be defined: you likely forgot to import, pass, or provide it."
+        }
+      ];
+      const parameters = [
+        { type: "Identifier", name: "id" },
+        { type: "Identifier", name: "component" }
+      ];
+      if (development2) {
+        message.push({
+          type: "ConditionalExpression",
+          test: { type: "Identifier", name: "place" },
+          consequent: toBinaryAddition([
+            { type: "Literal", value: "\nIt\u2019s referenced in your code at `" },
+            { type: "Identifier", name: "place" },
+            {
+              type: "Literal",
+              value: (file.path ? "` in `" + file.path : "") + "`"
+            }
+          ]),
+          alternate: { type: "Literal", value: "" }
+        });
+        parameters.push({ type: "Identifier", name: "place" });
+      }
+      tree.body.push({
+        type: "FunctionDeclaration",
+        id: { type: "Identifier", name: "_missingMdxReference" },
+        generator: false,
+        async: false,
+        params: parameters,
+        body: {
+          type: "BlockStatement",
+          body: [
+            {
+              type: "ThrowStatement",
+              argument: {
+                type: "NewExpression",
+                callee: { type: "Identifier", name: "Error" },
+                arguments: [toBinaryAddition(message)]
+              }
+            }
+          ]
+        }
+      });
+    }
+  };
+}
+function createImportProvider(providerImportSource, outputFormat) {
+  const specifiers = [
+    {
+      type: "ImportSpecifier",
+      imported: { type: "Identifier", name: "useMDXComponents" },
+      local: { type: "Identifier", name: "_provideComponents" }
+    }
+  ];
+  return outputFormat === "function-body" ? {
+    type: "VariableDeclaration",
+    kind: "const",
+    declarations: specifiersToDeclarations(specifiers, toIdOrMemberExpression(["arguments", 0]))
+  } : {
+    type: "ImportDeclaration",
+    specifiers,
+    source: { type: "Literal", value: providerImportSource }
+  };
+}
+function isNamedFunction(node, name3) {
+  return Boolean(node && "id" in node && node.id && node.id.name === name3);
+}
+function inScope(scope, id) {
+  let currentScope = scope;
+  while (currentScope) {
+    if (currentScope.declarations.has(id)) {
+      return true;
+    }
+    currentScope = currentScope.parent;
+  }
+  return false;
+}
+
+// ../../node_modules/.pnpm/astring@1.8.1/node_modules/astring/dist/astring.mjs
+var { stringify } = JSON;
+if (!String.prototype.repeat) {
+  throw new Error("String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation");
+}
+if (!String.prototype.endsWith) {
+  throw new Error("String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation");
+}
+var OPERATOR_PRECEDENCE = {
+  "||": 3,
+  "&&": 4,
+  "|": 5,
+  "??": 5,
+  "^": 6,
+  "&": 7,
+  "==": 8,
+  "!=": 8,
+  "===": 8,
+  "!==": 8,
+  "<": 9,
+  ">": 9,
+  "<=": 9,
+  ">=": 9,
+  in: 9,
+  instanceof: 9,
+  "<<": 10,
+  ">>": 10,
+  ">>>": 10,
+  "+": 11,
+  "-": 11,
+  "*": 12,
+  "%": 12,
+  "/": 12,
+  "**": 13
+};
+var NEEDS_PARENTHESES = 17;
+var EXPRESSIONS_PRECEDENCE = {
+  ArrayExpression: 20,
+  TaggedTemplateExpression: 20,
+  ThisExpression: 20,
+  Identifier: 20,
+  PrivateIdentifier: 20,
+  Literal: 18,
+  TemplateLiteral: 20,
+  Super: 20,
+  SequenceExpression: 20,
+  MemberExpression: 19,
+  ChainExpression: 19,
+  CallExpression: 19,
+  NewExpression: 19,
+  ArrowFunctionExpression: NEEDS_PARENTHESES,
+  ClassExpression: NEEDS_PARENTHESES,
+  FunctionExpression: NEEDS_PARENTHESES,
+  ObjectExpression: NEEDS_PARENTHESES,
+  UpdateExpression: 16,
+  UnaryExpression: 15,
+  AwaitExpression: 15,
+  BinaryExpression: 14,
+  LogicalExpression: 13,
+  ConditionalExpression: 4,
+  AssignmentExpression: 3,
+  YieldExpression: 2,
+  RestElement: 1
+};
+function formatSequence(state, nodes2) {
+  const { generator } = state;
+  state.write("(");
+  if (nodes2 != null && nodes2.length > 0) {
+    generator[nodes2[0].type](nodes2[0], state);
+    const { length } = nodes2;
+    for (let i = 1; i < length; i++) {
+      const param = nodes2[i];
+      state.write(", ");
+      generator[param.type](param, state);
+    }
+  }
+  state.write(")");
+}
+function expressionNeedsParenthesis(state, node, parentNode, isRightHand) {
+  const nodePrecedence = state.expressionsPrecedence[node.type];
+  if (nodePrecedence === NEEDS_PARENTHESES) {
+    return true;
+  }
+  const parentNodePrecedence = state.expressionsPrecedence[parentNode.type];
+  if (nodePrecedence !== parentNodePrecedence) {
+    return !isRightHand && nodePrecedence === 15 && parentNodePrecedence === 14 && parentNode.operator === "**" || nodePrecedence < parentNodePrecedence;
+  }
+  if (nodePrecedence !== 13 && nodePrecedence !== 14) {
+    return false;
+  }
+  if (node.operator === "**" && parentNode.operator === "**") {
+    return !isRightHand;
+  }
+  if (isRightHand) {
+    return OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parentNode.operator];
+  }
+  return OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parentNode.operator];
+}
+function formatExpression(state, node, parentNode, isRightHand) {
+  const { generator } = state;
+  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {
+    state.write("(");
+    generator[node.type](node, state);
+    state.write(")");
+  } else {
+    generator[node.type](node, state);
+  }
+}
+function reindent(state, text7, indent2, lineEnd) {
+  const lines = text7.split("\n");
+  const end = lines.length - 1;
+  state.write(lines[0].trim());
+  if (end > 0) {
+    state.write(lineEnd);
+    for (let i = 1; i < end; i++) {
+      state.write(indent2 + lines[i].trim() + lineEnd);
+    }
+    state.write(indent2 + lines[end].trim());
+  }
+}
+function formatComments(state, comments, indent2, lineEnd) {
+  const { length } = comments;
+  for (let i = 0; i < length; i++) {
+    const comment3 = comments[i];
+    state.write(indent2);
+    if (comment3.type[0] === "L") {
+      state.write("// " + comment3.value.trim() + "\n", comment3);
+    } else {
+      state.write("/*");
+      reindent(state, comment3.value, indent2, lineEnd);
+      state.write("*/" + lineEnd);
+    }
+  }
+}
+function hasCallExpression(node) {
+  let currentNode = node;
+  while (currentNode != null) {
+    const { type: type2 } = currentNode;
+    if (type2[0] === "C" && type2[1] === "a") {
+      return true;
+    } else if (type2[0] === "M" && type2[1] === "e" && type2[2] === "m") {
+      currentNode = currentNode.object;
+    } else {
+      return false;
+    }
+  }
+}
+function formatVariableDeclaration(state, node) {
+  const { generator } = state;
+  const { declarations } = node;
+  state.write(node.kind + " ");
+  const { length } = declarations;
+  if (length > 0) {
+    generator.VariableDeclarator(declarations[0], state);
+    for (let i = 1; i < length; i++) {
+      state.write(", ");
+      generator.VariableDeclarator(declarations[i], state);
+    }
+  }
+}
+var ForInStatement;
+var FunctionDeclaration;
+var RestElement;
+var BinaryExpression;
+var ArrayExpression;
+var BlockStatement;
+var GENERATOR = {
+  Program(node, state) {
+    const indent2 = state.indent.repeat(state.indentLevel);
+    const { lineEnd, writeComments } = state;
+    if (writeComments && node.comments != null) {
+      formatComments(state, node.comments, indent2, lineEnd);
+    }
+    const statements = node.body;
+    const { length } = statements;
+    for (let i = 0; i < length; i++) {
+      const statement = statements[i];
+      if (writeComments && statement.comments != null) {
+        formatComments(state, statement.comments, indent2, lineEnd);
+      }
+      state.write(indent2);
+      this[statement.type](statement, state);
+      state.write(lineEnd);
+    }
+    if (writeComments && node.trailingComments != null) {
+      formatComments(state, node.trailingComments, indent2, lineEnd);
+    }
+  },
+  BlockStatement: BlockStatement = function(node, state) {
+    const indent2 = state.indent.repeat(state.indentLevel++);
+    const { lineEnd, writeComments } = state;
+    const statementIndent = indent2 + state.indent;
+    state.write("{");
+    const statements = node.body;
+    if (statements != null && statements.length > 0) {
+      state.write(lineEnd);
+      if (writeComments && node.comments != null) {
+        formatComments(state, node.comments, statementIndent, lineEnd);
+      }
+      const { length } = statements;
+      for (let i = 0; i < length; i++) {
+        const statement = statements[i];
+        if (writeComments && statement.comments != null) {
+          formatComments(state, statement.comments, statementIndent, lineEnd);
+        }
+        state.write(statementIndent);
+        this[statement.type](statement, state);
+        state.write(lineEnd);
+      }
+      state.write(indent2);
+    } else {
+      if (writeComments && node.comments != null) {
+        state.write(lineEnd);
+        formatComments(state, node.comments, statementIndent, lineEnd);
+        state.write(indent2);
+      }
+    }
+    if (writeComments && node.trailingComments != null) {
+      formatComments(state, node.trailingComments, statementIndent, lineEnd);
+    }
+    state.write("}");
+    state.indentLevel--;
+  },
+  ClassBody: BlockStatement,
+  StaticBlock(node, state) {
+    state.write("static ");
+    this.BlockStatement(node, state);
+  },
+  EmptyStatement(node, state) {
+    state.write(";");
+  },
+  ExpressionStatement(node, state) {
+    const precedence = state.expressionsPrecedence[node.expression.type];
+    if (precedence === NEEDS_PARENTHESES || precedence === 3 && node.expression.left.type[0] === "O") {
+      state.write("(");
+      this[node.expression.type](node.expression, state);
+      state.write(")");
+    } else {
+      this[node.expression.type](node.expression, state);
+    }
+    state.write(";");
+  },
+  IfStatement(node, state) {
+    state.write("if (");
+    this[node.test.type](node.test, state);
+    state.write(") ");
+    this[node.consequent.type](node.consequent, state);
+    if (node.alternate != null) {
+      state.write(" else ");
+      this[node.alternate.type](node.alternate, state);
+    }
+  },
+  LabeledStatement(node, state) {
+    this[node.label.type](node.label, state);
+    state.write(": ");
+    this[node.body.type](node.body, state);
+  },
+  BreakStatement(node, state) {
+    state.write("break");
+    if (node.label != null) {
+      state.write(" ");
+      this[node.label.type](node.label, state);
+    }
+    state.write(";");
+  },
+  ContinueStatement(node, state) {
+    state.write("continue");
+    if (node.label != null) {
+      state.write(" ");
+      this[node.label.type](node.label, state);
+    }
+    state.write(";");
+  },
+  WithStatement(node, state) {
+    state.write("with (");
+    this[node.object.type](node.object, state);
+    state.write(") ");
+    this[node.body.type](node.body, state);
+  },
+  SwitchStatement(node, state) {
+    const indent2 = state.indent.repeat(state.indentLevel++);
+    const { lineEnd, writeComments } = state;
+    state.indentLevel++;
+    const caseIndent = indent2 + state.indent;
+    const statementIndent = caseIndent + state.indent;
+    state.write("switch (");
+    this[node.discriminant.type](node.discriminant, state);
+    state.write(") {" + lineEnd);
+    const { cases: occurences } = node;
+    const { length: occurencesCount } = occurences;
+    for (let i = 0; i < occurencesCount; i++) {
+      const occurence = occurences[i];
+      if (writeComments && occurence.comments != null) {
+        formatComments(state, occurence.comments, caseIndent, lineEnd);
+      }
+      if (occurence.test) {
+        state.write(caseIndent + "case ");
+        this[occurence.test.type](occurence.test, state);
+        state.write(":" + lineEnd);
+      } else {
+        state.write(caseIndent + "default:" + lineEnd);
+      }
+      const { consequent } = occurence;
+      const { length: consequentCount } = consequent;
+      for (let i2 = 0; i2 < consequentCount; i2++) {
+        const statement = consequent[i2];
+        if (writeComments && statement.comments != null) {
+          formatComments(state, statement.comments, statementIndent, lineEnd);
+        }
+        state.write(statementIndent);
+        this[statement.type](statement, state);
+        state.write(lineEnd);
+      }
+    }
+    state.indentLevel -= 2;
+    state.write(indent2 + "}");
+  },
+  ReturnStatement(node, state) {
+    state.write("return");
+    if (node.argument) {
+      state.write(" ");
+      this[node.argument.type](node.argument, state);
+    }
+    state.write(";");
+  },
+  ThrowStatement(node, state) {
+    state.write("throw ");
+    this[node.argument.type](node.argument, state);
+    state.write(";");
+  },
+  TryStatement(node, state) {
+    state.write("try ");
+    this[node.block.type](node.block, state);
+    if (node.handler) {
+      const { handler } = node;
+      if (handler.param == null) {
+        state.write(" catch ");
+      } else {
+        state.write(" catch (");
+        this[handler.param.type](handler.param, state);
+        state.write(") ");
+      }
+      this[handler.body.type](handler.body, state);
+    }
+    if (node.finalizer) {
+      state.write(" finally ");
+      this[node.finalizer.type](node.finalizer, state);
+    }
+  },
+  WhileStatement(node, state) {
+    state.write("while (");
+    this[node.test.type](node.test, state);
+    state.write(") ");
+    this[node.body.type](node.body, state);
+  },
+  DoWhileStatement(node, state) {
+    state.write("do ");
+    this[node.body.type](node.body, state);
+    state.write(" while (");
+    this[node.test.type](node.test, state);
+    state.write(");");
+  },
+  ForStatement(node, state) {
+    state.write("for (");
+    if (node.init != null) {
+      const { init } = node;
+      if (init.type[0] === "V") {
+        formatVariableDeclaration(state, init);
+      } else {
+        this[init.type](init, state);
+      }
+    }
+    state.write("; ");
+    if (node.test) {
+      this[node.test.type](node.test, state);
+    }
+    state.write("; ");
+    if (node.update) {
+      this[node.update.type](node.update, state);
+    }
+    state.write(") ");
+    this[node.body.type](node.body, state);
+  },
+  ForInStatement: ForInStatement = function(node, state) {
+    state.write(`for ${node.await ? "await " : ""}(`);
+    const { left } = node;
+    if (left.type[0] === "V") {
+      formatVariableDeclaration(state, left);
+    } else {
+      this[left.type](left, state);
+    }
+    state.write(node.type[3] === "I" ? " in " : " of ");
+    this[node.right.type](node.right, state);
+    state.write(") ");
+    this[node.body.type](node.body, state);
+  },
+  ForOfStatement: ForInStatement,
+  DebuggerStatement(node, state) {
+    state.write("debugger;", node);
+  },
+  FunctionDeclaration: FunctionDeclaration = function(node, state) {
+    state.write((node.async ? "async " : "") + (node.generator ? "function* " : "function ") + (node.id ? node.id.name : ""), node);
+    formatSequence(state, node.params);
+    state.write(" ");
+    this[node.body.type](node.body, state);
+  },
+  FunctionExpression: FunctionDeclaration,
+  VariableDeclaration(node, state) {
+    formatVariableDeclaration(state, node);
+    state.write(";");
+  },
+  VariableDeclarator(node, state) {
+    this[node.id.type](node.id, state);
+    if (node.init != null) {
+      state.write(" = ");
+      this[node.init.type](node.init, state);
+    }
+  },
+  ClassDeclaration(node, state) {
+    state.write("class " + (node.id ? `${node.id.name} ` : ""), node);
+    if (node.superClass) {
+      state.write("extends ");
+      const { superClass } = node;
+      const { type: type2 } = superClass;
+      const precedence = state.expressionsPrecedence[type2];
+      if ((type2[0] !== "C" || type2[1] !== "l" || type2[5] !== "E") && (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.ClassExpression)) {
+        state.write("(");
+        this[node.superClass.type](superClass, state);
+        state.write(")");
+      } else {
+        this[superClass.type](superClass, state);
+      }
+      state.write(" ");
+    }
+    this.ClassBody(node.body, state);
+  },
+  ImportDeclaration(node, state) {
+    state.write("import ");
+    const { specifiers } = node;
+    const { length } = specifiers;
+    let i = 0;
+    if (length > 0) {
+      for (; i < length; ) {
+        if (i > 0) {
+          state.write(", ");
+        }
+        const specifier = specifiers[i];
+        const type2 = specifier.type[6];
+        if (type2 === "D") {
+          state.write(specifier.local.name, specifier);
+          i++;
+        } else if (type2 === "N") {
+          state.write("* as " + specifier.local.name, specifier);
+          i++;
+        } else {
+          break;
+        }
+      }
+      if (i < length) {
+        state.write("{");
+        for (; ; ) {
+          const specifier = specifiers[i];
+          const { name: name3 } = specifier.imported;
+          state.write(name3, specifier);
+          if (name3 !== specifier.local.name) {
+            state.write(" as " + specifier.local.name);
+          }
+          if (++i < length) {
+            state.write(", ");
+          } else {
+            break;
+          }
+        }
+        state.write("}");
+      }
+      state.write(" from ");
+    }
+    this.Literal(node.source, state);
+    state.write(";");
+  },
+  ImportExpression(node, state) {
+    state.write("import(");
+    this[node.source.type](node.source, state);
+    state.write(")");
+  },
+  ExportDefaultDeclaration(node, state) {
+    state.write("export default ");
+    this[node.declaration.type](node.declaration, state);
+    if (state.expressionsPrecedence[node.declaration.type] != null && node.declaration.type[0] !== "F") {
+      state.write(";");
+    }
+  },
+  ExportNamedDeclaration(node, state) {
+    state.write("export ");
+    if (node.declaration) {
+      this[node.declaration.type](node.declaration, state);
+    } else {
+      state.write("{");
+      const { specifiers } = node, { length } = specifiers;
+      if (length > 0) {
+        for (let i = 0; ; ) {
+          const specifier = specifiers[i];
+          const { name: name3 } = specifier.local;
+          state.write(name3, specifier);
+          if (name3 !== specifier.exported.name) {
+            state.write(" as " + specifier.exported.name);
+          }
+          if (++i < length) {
+            state.write(", ");
+          } else {
+            break;
+          }
+        }
+      }
+      state.write("}");
+      if (node.source) {
+        state.write(" from ");
+        this.Literal(node.source, state);
+      }
+      state.write(";");
+    }
+  },
+  ExportAllDeclaration(node, state) {
+    if (node.exported != null) {
+      state.write("export * as " + node.exported.name + " from ");
+    } else {
+      state.write("export * from ");
+    }
+    this.Literal(node.source, state);
+    state.write(";");
+  },
+  MethodDefinition(node, state) {
+    if (node.static) {
+      state.write("static ");
+    }
+    const kind = node.kind[0];
+    if (kind === "g" || kind === "s") {
+      state.write(node.kind + " ");
+    }
+    if (node.value.async) {
+      state.write("async ");
+    }
+    if (node.value.generator) {
+      state.write("*");
+    }
+    if (node.computed) {
+      state.write("[");
+      this[node.key.type](node.key, state);
+      state.write("]");
+    } else {
+      this[node.key.type](node.key, state);
+    }
+    formatSequence(state, node.value.params);
+    state.write(" ");
+    this[node.value.body.type](node.value.body, state);
+  },
+  ClassExpression(node, state) {
+    this.ClassDeclaration(node, state);
+  },
+  ArrowFunctionExpression(node, state) {
+    state.write(node.async ? "async " : "", node);
+    const { params } = node;
+    if (params != null) {
+      if (params.length === 1 && params[0].type[0] === "I") {
+        state.write(params[0].name, params[0]);
+      } else {
+        formatSequence(state, node.params);
+      }
+    }
+    state.write(" => ");
+    if (node.body.type[0] === "O") {
+      state.write("(");
+      this.ObjectExpression(node.body, state);
+      state.write(")");
+    } else {
+      this[node.body.type](node.body, state);
+    }
+  },
+  ThisExpression(node, state) {
+    state.write("this", node);
+  },
+  Super(node, state) {
+    state.write("super", node);
+  },
+  RestElement: RestElement = function(node, state) {
+    state.write("...");
+    this[node.argument.type](node.argument, state);
+  },
+  SpreadElement: RestElement,
+  YieldExpression(node, state) {
+    state.write(node.delegate ? "yield*" : "yield");
+    if (node.argument) {
+      state.write(" ");
+      this[node.argument.type](node.argument, state);
+    }
+  },
+  AwaitExpression(node, state) {
+    state.write("await ", node);
+    formatExpression(state, node.argument, node);
+  },
+  TemplateLiteral(node, state) {
+    const { quasis, expressions } = node;
+    state.write("`");
+    const { length } = expressions;
+    for (let i = 0; i < length; i++) {
+      const expression = expressions[i];
+      const quasi2 = quasis[i];
+      state.write(quasi2.value.raw, quasi2);
+      state.write("${");
+      this[expression.type](expression, state);
+      state.write("}");
+    }
+    const quasi = quasis[quasis.length - 1];
+    state.write(quasi.value.raw, quasi);
+    state.write("`");
+  },
+  TemplateElement(node, state) {
+    state.write(node.value.raw, node);
+  },
+  TaggedTemplateExpression(node, state) {
+    formatExpression(state, node.tag, node);
+    this[node.quasi.type](node.quasi, state);
+  },
+  ArrayExpression: ArrayExpression = function(node, state) {
+    state.write("[");
+    if (node.elements.length > 0) {
+      const { elements } = node, { length } = elements;
+      for (let i = 0; ; ) {
+        const element3 = elements[i];
+        if (element3 != null) {
+          this[element3.type](element3, state);
+        }
+        if (++i < length) {
+          state.write(", ");
+        } else {
+          if (element3 == null) {
+            state.write(", ");
+          }
+          break;
+        }
+      }
+    }
+    state.write("]");
+  },
+  ArrayPattern: ArrayExpression,
+  ObjectExpression(node, state) {
+    const indent2 = state.indent.repeat(state.indentLevel++);
+    const { lineEnd, writeComments } = state;
+    const propertyIndent = indent2 + state.indent;
+    state.write("{");
+    if (node.properties.length > 0) {
+      state.write(lineEnd);
+      if (writeComments && node.comments != null) {
+        formatComments(state, node.comments, propertyIndent, lineEnd);
+      }
+      const comma = "," + lineEnd;
+      const { properties } = node, { length } = properties;
+      for (let i = 0; ; ) {
+        const property = properties[i];
+        if (writeComments && property.comments != null) {
+          formatComments(state, property.comments, propertyIndent, lineEnd);
+        }
+        state.write(propertyIndent);
+        this[property.type](property, state);
+        if (++i < length) {
+          state.write(comma);
+        } else {
+          break;
+        }
+      }
+      state.write(lineEnd);
+      if (writeComments && node.trailingComments != null) {
+        formatComments(state, node.trailingComments, propertyIndent, lineEnd);
+      }
+      state.write(indent2 + "}");
+    } else if (writeComments) {
+      if (node.comments != null) {
+        state.write(lineEnd);
+        formatComments(state, node.comments, propertyIndent, lineEnd);
+        if (node.trailingComments != null) {
+          formatComments(state, node.trailingComments, propertyIndent, lineEnd);
+        }
+        state.write(indent2 + "}");
+      } else if (node.trailingComments != null) {
+        state.write(lineEnd);
+        formatComments(state, node.trailingComments, propertyIndent, lineEnd);
+        state.write(indent2 + "}");
+      } else {
+        state.write("}");
+      }
+    } else {
+      state.write("}");
+    }
+    state.indentLevel--;
+  },
+  Property(node, state) {
+    if (node.method || node.kind[0] !== "i") {
+      this.MethodDefinition(node, state);
+    } else {
+      if (!node.shorthand) {
+        if (node.computed) {
+          state.write("[");
+          this[node.key.type](node.key, state);
+          state.write("]");
+        } else {
+          this[node.key.type](node.key, state);
+        }
+        state.write(": ");
+      }
+      this[node.value.type](node.value, state);
+    }
+  },
+  PropertyDefinition(node, state) {
+    if (node.static) {
+      state.write("static ");
+    }
+    this[node.key.type](node.key, state);
+    state.write(" = ");
+    this[node.value.type](node.value, state);
+  },
+  ObjectPattern(node, state) {
+    state.write("{");
+    if (node.properties.length > 0) {
+      const { properties } = node, { length } = properties;
+      for (let i = 0; ; ) {
+        this[properties[i].type](properties[i], state);
+        if (++i < length) {
+          state.write(", ");
+        } else {
+          break;
+        }
+      }
+    }
+    state.write("}");
+  },
+  SequenceExpression(node, state) {
+    formatSequence(state, node.expressions);
+  },
+  UnaryExpression(node, state) {
+    if (node.prefix) {
+      const {
+        operator,
+        argument,
+        argument: { type: type2 }
+      } = node;
+      state.write(operator);
+      const needsParentheses = expressionNeedsParenthesis(state, argument, node);
+      if (!needsParentheses && (operator.length > 1 || type2[0] === "U" && (type2[1] === "n" || type2[1] === "p") && argument.prefix && argument.operator[0] === operator && (operator === "+" || operator === "-"))) {
+        state.write(" ");
+      }
+      if (needsParentheses) {
+        state.write(operator.length > 1 ? " (" : "(");
+        this[type2](argument, state);
+        state.write(")");
+      } else {
+        this[type2](argument, state);
+      }
+    } else {
+      this[node.argument.type](node.argument, state);
+      state.write(node.operator);
+    }
+  },
+  UpdateExpression(node, state) {
+    if (node.prefix) {
+      state.write(node.operator);
+      this[node.argument.type](node.argument, state);
+    } else {
+      this[node.argument.type](node.argument, state);
+      state.write(node.operator);
+    }
+  },
+  AssignmentExpression(node, state) {
+    this[node.left.type](node.left, state);
+    state.write(" " + node.operator + " ");
+    this[node.right.type](node.right, state);
+  },
+  AssignmentPattern(node, state) {
+    this[node.left.type](node.left, state);
+    state.write(" = ");
+    this[node.right.type](node.right, state);
+  },
+  BinaryExpression: BinaryExpression = function(node, state) {
+    const isIn = node.operator === "in";
+    if (isIn) {
+      state.write("(");
+    }
+    formatExpression(state, node.left, node, false);
+    state.write(" " + node.operator + " ");
+    formatExpression(state, node.right, node, true);
+    if (isIn) {
+      state.write(")");
+    }
+  },
+  LogicalExpression: BinaryExpression,
+  ConditionalExpression(node, state) {
+    const { test } = node;
+    const precedence = state.expressionsPrecedence[test.type];
+    if (precedence === NEEDS_PARENTHESES || precedence <= state.expressionsPrecedence.ConditionalExpression) {
+      state.write("(");
+      this[test.type](test, state);
+      state.write(")");
+    } else {
+      this[test.type](test, state);
+    }
+    state.write(" ? ");
+    this[node.consequent.type](node.consequent, state);
+    state.write(" : ");
+    this[node.alternate.type](node.alternate, state);
+  },
+  NewExpression(node, state) {
+    state.write("new ");
+    const precedence = state.expressionsPrecedence[node.callee.type];
+    if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.CallExpression || hasCallExpression(node.callee)) {
+      state.write("(");
+      this[node.callee.type](node.callee, state);
+      state.write(")");
+    } else {
+      this[node.callee.type](node.callee, state);
+    }
+    formatSequence(state, node["arguments"]);
+  },
+  CallExpression(node, state) {
+    const precedence = state.expressionsPrecedence[node.callee.type];
+    if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.CallExpression) {
+      state.write("(");
+      this[node.callee.type](node.callee, state);
+      state.write(")");
+    } else {
+      this[node.callee.type](node.callee, state);
+    }
+    if (node.optional) {
+      state.write("?.");
+    }
+    formatSequence(state, node["arguments"]);
+  },
+  ChainExpression(node, state) {
+    this[node.expression.type](node.expression, state);
+  },
+  MemberExpression(node, state) {
+    const precedence = state.expressionsPrecedence[node.object.type];
+    if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.MemberExpression) {
+      state.write("(");
+      this[node.object.type](node.object, state);
+      state.write(")");
+    } else {
+      this[node.object.type](node.object, state);
+    }
+    if (node.computed) {
+      if (node.optional) {
+        state.write("?.");
+      }
+      state.write("[");
+      this[node.property.type](node.property, state);
+      state.write("]");
+    } else {
+      if (node.optional) {
+        state.write("?.");
+      } else {
+        state.write(".");
+      }
+      this[node.property.type](node.property, state);
+    }
+  },
+  MetaProperty(node, state) {
+    state.write(node.meta.name + "." + node.property.name, node);
+  },
+  Identifier(node, state) {
+    state.write(node.name, node);
+  },
+  PrivateIdentifier(node, state) {
+    state.write(`#${node.name}`, node);
+  },
+  Literal(node, state) {
+    if (node.raw != null) {
+      state.write(node.raw, node);
+    } else if (node.regex != null) {
+      this.RegExpLiteral(node, state);
+    } else if (node.bigint != null) {
+      state.write(node.bigint + "n", node);
+    } else {
+      state.write(stringify(node.value), node);
+    }
+  },
+  RegExpLiteral(node, state) {
+    const { regex: regex2 } = node;
+    state.write(`/${regex2.pattern}/${regex2.flags}`, node);
+  }
+};
+var EMPTY_OBJECT = {};
+var State = class {
+  constructor(options) {
+    const setup = options == null ? EMPTY_OBJECT : options;
+    this.output = "";
+    if (setup.output != null) {
+      this.output = setup.output;
+      this.write = this.writeToStream;
+    } else {
+      this.output = "";
+    }
+    this.generator = setup.generator != null ? setup.generator : GENERATOR;
+    this.expressionsPrecedence = setup.expressionsPrecedence != null ? setup.expressionsPrecedence : EXPRESSIONS_PRECEDENCE;
+    this.indent = setup.indent != null ? setup.indent : "  ";
+    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : "\n";
+    this.indentLevel = setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
+    this.writeComments = setup.comments ? setup.comments : false;
+    if (setup.sourceMap != null) {
+      this.write = setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
+      this.sourceMap = setup.sourceMap;
+      this.line = 1;
+      this.column = 0;
+      this.lineEndSize = this.lineEnd.split("\n").length - 1;
+      this.mapping = {
+        original: null,
+        generated: this,
+        name: void 0,
+        source: setup.sourceMap.file || setup.sourceMap._file
+      };
+    }
+  }
+  write(code3) {
+    this.output += code3;
+  }
+  writeToStream(code3) {
+    this.output.write(code3);
+  }
+  writeAndMap(code3, node) {
+    this.output += code3;
+    this.map(code3, node);
+  }
+  writeToStreamAndMap(code3, node) {
+    this.output.write(code3);
+    this.map(code3, node);
+  }
+  map(code3, node) {
+    if (node != null) {
+      const { type: type2 } = node;
+      if (type2[0] === "L" && type2[2] === "n") {
+        this.column = 0;
+        this.line++;
+        return;
+      }
+      if (node.loc != null) {
+        const { mapping } = this;
+        mapping.original = node.loc.start;
+        mapping.name = node.name;
+        this.sourceMap.addMapping(mapping);
+      }
+      if (type2[0] === "T" && type2[8] === "E" || type2[0] === "L" && type2[1] === "i" && typeof node.value === "string") {
+        const { length: length2 } = code3;
+        let { column, line } = this;
+        for (let i = 0; i < length2; i++) {
+          if (code3[i] === "\n") {
+            column = 0;
+            line++;
+          } else {
+            column++;
+          }
+        }
+        this.column = column;
+        this.line = line;
+        return;
+      }
+    }
+    const { length } = code3;
+    const { lineEnd } = this;
+    if (length > 0) {
+      if (this.lineEndSize > 0 && (lineEnd.length === 1 ? code3[length - 1] === lineEnd : code3.endsWith(lineEnd))) {
+        this.line += this.lineEndSize;
+        this.column = 0;
+      } else {
+        this.column += length;
+      }
+    }
+  }
+  toString() {
+    return this.output;
+  }
+};
+function generate(node, options) {
+  const state = new State(options);
+  state.generator[node.type](node, state);
+  return state.output;
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/plugin/recma-stringify.js
+function recmaStringify(options = {}) {
+  const { SourceMapGenerator } = options;
+  Object.assign(this, { Compiler: compiler2 });
+  function compiler2(tree, file) {
+    let sourceMap;
+    if (SourceMapGenerator) {
+      sourceMap = new SourceMapGenerator({ file: file.path || "unknown.mdx" });
+    }
+    const generator = __spreadProps(__spreadValues({}, GENERATOR), {
+      JSXAttribute,
+      JSXClosingElement,
+      JSXClosingFragment,
+      JSXElement,
+      JSXEmptyExpression,
+      JSXExpressionContainer,
+      JSXFragment,
+      JSXIdentifier,
+      JSXMemberExpression,
+      JSXNamespacedName,
+      JSXOpeningElement,
+      JSXOpeningFragment,
+      JSXSpreadAttribute,
+      JSXText
+    });
+    const result = generate(tree, {
+      generator,
+      comments: true,
+      sourceMap
+    });
+    if (sourceMap) {
+      file.map = sourceMap.toJSON();
+    }
+    return result;
+  }
+}
+function JSXAttribute(node, state) {
+  this[node.name.type](node.name, state);
+  if (node.value !== void 0 && node.value !== null) {
+    state.write("=");
+    if (node.value.type === "Literal") {
+      state.write('"' + encodeJsx(String(node.value.value)).replace(/"/g, "&quot;") + '"', node);
+    } else {
+      this[node.value.type](node.value, state);
+    }
+  }
+}
+function JSXClosingElement(node, state) {
+  state.write("</");
+  this[node.name.type](node.name, state);
+  state.write(">");
+}
+function JSXClosingFragment(node, state) {
+  state.write("</>", node);
+}
+function JSXElement(node, state) {
+  let index3 = -1;
+  this[node.openingElement.type](node.openingElement, state);
+  if (node.children) {
+    while (++index3 < node.children.length) {
+      const child = node.children[index3];
+      if (child.type === "JSXSpreadChild") {
+        throw new Error("JSX spread children are not supported");
+      }
+      this[child.type](child, state);
+    }
+  }
+  if (node.closingElement) {
+    this[node.closingElement.type](node.closingElement, state);
+  }
+}
+function JSXEmptyExpression() {
+}
+function JSXExpressionContainer(node, state) {
+  state.write("{");
+  this[node.expression.type](node.expression, state);
+  state.write("}");
+}
+function JSXFragment(node, state) {
+  let index3 = -1;
+  this[node.openingFragment.type](node.openingFragment, state);
+  if (node.children) {
+    while (++index3 < node.children.length) {
+      const child = node.children[index3];
+      if (child.type === "JSXSpreadChild") {
+        throw new Error("JSX spread children are not supported");
+      }
+      this[child.type](child, state);
+    }
+  }
+  this[node.closingFragment.type](node.closingFragment, state);
+}
+function JSXIdentifier(node, state) {
+  state.write(node.name, node);
+}
+function JSXMemberExpression(node, state) {
+  this[node.object.type](node.object, state);
+  state.write(".");
+  this[node.property.type](node.property, state);
+}
+function JSXNamespacedName(node, state) {
+  this[node.namespace.type](node.namespace, state);
+  state.write(":");
+  this[node.name.type](node.name, state);
+}
+function JSXOpeningElement(node, state) {
+  let index3 = -1;
+  state.write("<");
+  this[node.name.type](node.name, state);
+  if (node.attributes) {
+    while (++index3 < node.attributes.length) {
+      state.write(" ");
+      this[node.attributes[index3].type](node.attributes[index3], state);
+    }
+  }
+  state.write(node.selfClosing ? " />" : ">");
+}
+function JSXOpeningFragment(node, state) {
+  state.write("<>", node);
+}
+function JSXSpreadAttribute(node, state) {
+  state.write("{");
+  this.SpreadElement(node, state);
+  state.write("}");
+}
+function JSXText(node, state) {
+  state.write(encodeJsx(node.value).replace(/<|{/g, ($0) => $0 === "<" ? "&lt;" : "&#123;"), node);
+}
+function encodeJsx(value) {
+  return value.replace(/&(?=[#a-z])/gi, "&amp;");
+}
+
+// ../../node_modules/.pnpm/comma-separated-tokens@2.0.2/node_modules/comma-separated-tokens/index.js
+function stringify2(values, options) {
+  var settings = options || {};
+  if (values[values.length - 1] === "") {
+    values = values.concat("");
+  }
+  return values.join((settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")).trim();
+}
+
+// ../../node_modules/.pnpm/estree-util-attach-comments@2.0.0/node_modules/estree-util-attach-comments/index.js
+var push2 = [].push;
+function attachComments(tree, comments) {
+  var list3 = (comments || []).concat().sort(compare);
+  if (list3.length)
+    walk2(tree, { comments: list3, index: 0 });
+  return tree;
+}
+function walk2(node, state) {
+  var children = [];
+  var comments = [];
+  var key;
+  var value;
+  var index3;
+  if (state.index === state.comments.length) {
+    return;
+  }
+  for (key in node) {
+    value = node[key];
+    if (value && typeof value === "object" && key !== "comments") {
+      if (Array.isArray(value)) {
+        index3 = -1;
+        while (++index3 < value.length) {
+          if (value[index3] && typeof value[index3].type === "string") {
+            children.push(value[index3]);
+          }
+        }
+      } else if (typeof value.type === "string") {
+        children.push(value);
+      }
+    }
+  }
+  children.sort(compare);
+  push2.apply(comments, slice(state, node, false, { leading: true, trailing: false }));
+  index3 = -1;
+  while (++index3 < children.length) {
+    walk2(children[index3], state);
+  }
+  push2.apply(comments, slice(state, node, true, {
+    leading: false,
+    trailing: Boolean(children.length)
+  }));
+  if (comments.length) {
+    node.comments = comments;
+  }
+}
+function slice(state, node, compareEnd, fields) {
+  var result = [];
+  while (state.comments[state.index] && compare(state.comments[state.index], node, compareEnd) < 1) {
+    result.push(Object.assign({}, state.comments[state.index++], fields));
+  }
+  return result;
+}
+function compare(left, right, compareEnd) {
+  var field = compareEnd ? "end" : "start";
+  if (left.range && right.range) {
+    return left.range[0] - right.range[compareEnd ? 1 : 0];
+  }
+  if (left.loc && left.loc.start && right.loc && right.loc[field]) {
+    return left.loc.start.line - right.loc[field].line || left.loc.start.column - right.loc[field].column;
+  }
+  if ("start" in left && field in right) {
+    return left.start - right[field];
+  }
+  return NaN;
+}
+
+// ../../node_modules/.pnpm/hast-util-whitespace@2.0.0/node_modules/hast-util-whitespace/index.js
+function whitespace(thing) {
+  var value = thing && typeof thing === "object" && thing.type === "text" ? thing.value || "" : thing;
+  return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/util/schema.js
+var Schema = class {
+  constructor(property, normal, space) {
+    this.property = property;
+    this.normal = normal;
+    if (space) {
+      this.space = space;
+    }
+  }
+};
+Schema.prototype.property = {};
+Schema.prototype.normal = {};
+Schema.prototype.space = null;
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/util/merge.js
+function merge(definitions2, space) {
+  const property = {};
+  const normal = {};
+  let index3 = -1;
+  while (++index3 < definitions2.length) {
+    Object.assign(property, definitions2[index3].property);
+    Object.assign(normal, definitions2[index3].normal);
+  }
+  return new Schema(property, normal, space);
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/normalize.js
+function normalize5(value) {
+  return value.toLowerCase();
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/util/info.js
+var Info = class {
+  constructor(property, attribute) {
+    this.property = property;
+    this.attribute = attribute;
+  }
+};
+Info.prototype.space = null;
+Info.prototype.boolean = false;
+Info.prototype.booleanish = false;
+Info.prototype.overloadedBoolean = false;
+Info.prototype.number = false;
+Info.prototype.commaSeparated = false;
+Info.prototype.spaceSeparated = false;
+Info.prototype.commaOrSpaceSeparated = false;
+Info.prototype.mustUseProperty = false;
+Info.prototype.defined = false;
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/util/types.js
+var types_exports = {};
+__export(types_exports, {
+  boolean: () => boolean,
+  booleanish: () => booleanish,
+  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
+  commaSeparated: () => commaSeparated,
+  number: () => number,
+  overloadedBoolean: () => overloadedBoolean,
+  spaceSeparated: () => spaceSeparated
+});
+var powers = 0;
+var boolean = increment();
+var booleanish = increment();
+var overloadedBoolean = increment();
+var number = increment();
+var spaceSeparated = increment();
+var commaSeparated = increment();
+var commaOrSpaceSeparated = increment();
+function increment() {
+  return 2 ** ++powers;
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/util/defined-info.js
+var checks = Object.keys(types_exports);
+var DefinedInfo = class extends Info {
+  constructor(property, attribute, mask, space) {
+    let index3 = -1;
+    super(property, attribute);
+    mark(this, "space", space);
+    if (typeof mask === "number") {
+      while (++index3 < checks.length) {
+        const check = checks[index3];
+        mark(this, checks[index3], (mask & types_exports[check]) === types_exports[check]);
+      }
+    }
+  }
+};
+DefinedInfo.prototype.defined = true;
+function mark(values, key, value) {
+  if (value) {
+    values[key] = value;
+  }
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/util/create.js
+var own11 = {}.hasOwnProperty;
+function create3(definition2) {
+  const property = {};
+  const normal = {};
+  let prop;
+  for (prop in definition2.properties) {
+    if (own11.call(definition2.properties, prop)) {
+      const value = definition2.properties[prop];
+      const info = new DefinedInfo(prop, definition2.transform(definition2.attributes || {}, prop), value, definition2.space);
+      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
+        info.mustUseProperty = true;
+      }
+      property[prop] = info;
+      normal[normalize5(prop)] = prop;
+      normal[normalize5(info.attribute)] = prop;
+    }
+  }
+  return new Schema(property, normal, definition2.space);
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/xlink.js
+var xlink = create3({
+  space: "xlink",
+  transform(_, prop) {
+    return "xlink:" + prop.slice(5).toLowerCase();
+  },
+  properties: {
+    xLinkActuate: null,
+    xLinkArcRole: null,
+    xLinkHref: null,
+    xLinkRole: null,
+    xLinkShow: null,
+    xLinkTitle: null,
+    xLinkType: null
+  }
+});
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/xml.js
+var xml = create3({
+  space: "xml",
+  transform(_, prop) {
+    return "xml:" + prop.slice(3).toLowerCase();
+  },
+  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
+});
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/util/case-sensitive-transform.js
+function caseSensitiveTransform(attributes, attribute) {
+  return attribute in attributes ? attributes[attribute] : attribute;
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/util/case-insensitive-transform.js
+function caseInsensitiveTransform(attributes, property) {
+  return caseSensitiveTransform(attributes, property.toLowerCase());
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/xmlns.js
+var xmlns = create3({
+  space: "xmlns",
+  attributes: { xmlnsxlink: "xmlns:xlink" },
+  transform: caseInsensitiveTransform,
+  properties: { xmlns: null, xmlnsXLink: null }
+});
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/aria.js
+var aria = create3({
+  transform(_, prop) {
+    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
+  },
+  properties: {
+    ariaActiveDescendant: null,
+    ariaAtomic: booleanish,
+    ariaAutoComplete: null,
+    ariaBusy: booleanish,
+    ariaChecked: booleanish,
+    ariaColCount: number,
+    ariaColIndex: number,
+    ariaColSpan: number,
+    ariaControls: spaceSeparated,
+    ariaCurrent: null,
+    ariaDescribedBy: spaceSeparated,
+    ariaDetails: null,
+    ariaDisabled: booleanish,
+    ariaDropEffect: spaceSeparated,
+    ariaErrorMessage: null,
+    ariaExpanded: booleanish,
+    ariaFlowTo: spaceSeparated,
+    ariaGrabbed: booleanish,
+    ariaHasPopup: null,
+    ariaHidden: booleanish,
+    ariaInvalid: null,
+    ariaKeyShortcuts: null,
+    ariaLabel: null,
+    ariaLabelledBy: spaceSeparated,
+    ariaLevel: number,
+    ariaLive: null,
+    ariaModal: booleanish,
+    ariaMultiLine: booleanish,
+    ariaMultiSelectable: booleanish,
+    ariaOrientation: null,
+    ariaOwns: spaceSeparated,
+    ariaPlaceholder: null,
+    ariaPosInSet: number,
+    ariaPressed: booleanish,
+    ariaReadOnly: booleanish,
+    ariaRelevant: null,
+    ariaRequired: booleanish,
+    ariaRoleDescription: spaceSeparated,
+    ariaRowCount: number,
+    ariaRowIndex: number,
+    ariaRowSpan: number,
+    ariaSelected: booleanish,
+    ariaSetSize: number,
+    ariaSort: null,
+    ariaValueMax: number,
+    ariaValueMin: number,
+    ariaValueNow: number,
+    ariaValueText: null,
+    role: null
+  }
+});
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/html.js
+var html2 = create3({
+  space: "html",
+  attributes: {
+    acceptcharset: "accept-charset",
+    classname: "class",
+    htmlfor: "for",
+    httpequiv: "http-equiv"
+  },
+  transform: caseInsensitiveTransform,
+  mustUseProperty: ["checked", "multiple", "muted", "selected"],
+  properties: {
+    abbr: null,
+    accept: commaSeparated,
+    acceptCharset: spaceSeparated,
+    accessKey: spaceSeparated,
+    action: null,
+    allow: null,
+    allowFullScreen: boolean,
+    allowPaymentRequest: boolean,
+    allowUserMedia: boolean,
+    alt: null,
+    as: null,
+    async: boolean,
+    autoCapitalize: null,
+    autoComplete: spaceSeparated,
+    autoFocus: boolean,
+    autoPlay: boolean,
+    capture: boolean,
+    charSet: null,
+    checked: boolean,
+    cite: null,
+    className: spaceSeparated,
+    cols: number,
+    colSpan: null,
+    content: null,
+    contentEditable: booleanish,
+    controls: boolean,
+    controlsList: spaceSeparated,
+    coords: number | commaSeparated,
+    crossOrigin: null,
+    data: null,
+    dateTime: null,
+    decoding: null,
+    default: boolean,
+    defer: boolean,
+    dir: null,
+    dirName: null,
+    disabled: boolean,
+    download: overloadedBoolean,
+    draggable: booleanish,
+    encType: null,
+    enterKeyHint: null,
+    form: null,
+    formAction: null,
+    formEncType: null,
+    formMethod: null,
+    formNoValidate: boolean,
+    formTarget: null,
+    headers: spaceSeparated,
+    height: number,
+    hidden: boolean,
+    high: number,
+    href: null,
+    hrefLang: null,
+    htmlFor: spaceSeparated,
+    httpEquiv: spaceSeparated,
+    id: null,
+    imageSizes: null,
+    imageSrcSet: null,
+    inputMode: null,
+    integrity: null,
+    is: null,
+    isMap: boolean,
+    itemId: null,
+    itemProp: spaceSeparated,
+    itemRef: spaceSeparated,
+    itemScope: boolean,
+    itemType: spaceSeparated,
+    kind: null,
+    label: null,
+    lang: null,
+    language: null,
+    list: null,
+    loading: null,
+    loop: boolean,
+    low: number,
+    manifest: null,
+    max: null,
+    maxLength: number,
+    media: null,
+    method: null,
+    min: null,
+    minLength: number,
+    multiple: boolean,
+    muted: boolean,
+    name: null,
+    nonce: null,
+    noModule: boolean,
+    noValidate: boolean,
+    onAbort: null,
+    onAfterPrint: null,
+    onAuxClick: null,
+    onBeforePrint: null,
+    onBeforeUnload: null,
+    onBlur: null,
+    onCancel: null,
+    onCanPlay: null,
+    onCanPlayThrough: null,
+    onChange: null,
+    onClick: null,
+    onClose: null,
+    onContextLost: null,
+    onContextMenu: null,
+    onContextRestored: null,
+    onCopy: null,
+    onCueChange: null,
+    onCut: null,
+    onDblClick: null,
+    onDrag: null,
+    onDragEnd: null,
+    onDragEnter: null,
+    onDragExit: null,
+    onDragLeave: null,
+    onDragOver: null,
+    onDragStart: null,
+    onDrop: null,
+    onDurationChange: null,
+    onEmptied: null,
+    onEnded: null,
+    onError: null,
+    onFocus: null,
+    onFormData: null,
+    onHashChange: null,
+    onInput: null,
+    onInvalid: null,
+    onKeyDown: null,
+    onKeyPress: null,
+    onKeyUp: null,
+    onLanguageChange: null,
+    onLoad: null,
+    onLoadedData: null,
+    onLoadedMetadata: null,
+    onLoadEnd: null,
+    onLoadStart: null,
+    onMessage: null,
+    onMessageError: null,
+    onMouseDown: null,
+    onMouseEnter: null,
+    onMouseLeave: null,
+    onMouseMove: null,
+    onMouseOut: null,
+    onMouseOver: null,
+    onMouseUp: null,
+    onOffline: null,
+    onOnline: null,
+    onPageHide: null,
+    onPageShow: null,
+    onPaste: null,
+    onPause: null,
+    onPlay: null,
+    onPlaying: null,
+    onPopState: null,
+    onProgress: null,
+    onRateChange: null,
+    onRejectionHandled: null,
+    onReset: null,
+    onResize: null,
+    onScroll: null,
+    onSecurityPolicyViolation: null,
+    onSeeked: null,
+    onSeeking: null,
+    onSelect: null,
+    onSlotChange: null,
+    onStalled: null,
+    onStorage: null,
+    onSubmit: null,
+    onSuspend: null,
+    onTimeUpdate: null,
+    onToggle: null,
+    onUnhandledRejection: null,
+    onUnload: null,
+    onVolumeChange: null,
+    onWaiting: null,
+    onWheel: null,
+    open: boolean,
+    optimum: number,
+    pattern: null,
+    ping: spaceSeparated,
+    placeholder: null,
+    playsInline: boolean,
+    poster: null,
+    preload: null,
+    readOnly: boolean,
+    referrerPolicy: null,
+    rel: spaceSeparated,
+    required: boolean,
+    reversed: boolean,
+    rows: number,
+    rowSpan: number,
+    sandbox: spaceSeparated,
+    scope: null,
+    scoped: boolean,
+    seamless: boolean,
+    selected: boolean,
+    shape: null,
+    size: number,
+    sizes: null,
+    slot: null,
+    span: number,
+    spellCheck: booleanish,
+    src: null,
+    srcDoc: null,
+    srcLang: null,
+    srcSet: null,
+    start: number,
+    step: null,
+    style: null,
+    tabIndex: number,
+    target: null,
+    title: null,
+    translate: null,
+    type: null,
+    typeMustMatch: boolean,
+    useMap: null,
+    value: booleanish,
+    width: number,
+    wrap: null,
+    align: null,
+    aLink: null,
+    archive: spaceSeparated,
+    axis: null,
+    background: null,
+    bgColor: null,
+    border: number,
+    borderColor: null,
+    bottomMargin: number,
+    cellPadding: null,
+    cellSpacing: null,
+    char: null,
+    charOff: null,
+    classId: null,
+    clear: null,
+    code: null,
+    codeBase: null,
+    codeType: null,
+    color: null,
+    compact: boolean,
+    declare: boolean,
+    event: null,
+    face: null,
+    frame: null,
+    frameBorder: null,
+    hSpace: number,
+    leftMargin: number,
+    link: null,
+    longDesc: null,
+    lowSrc: null,
+    marginHeight: number,
+    marginWidth: number,
+    noResize: boolean,
+    noHref: boolean,
+    noShade: boolean,
+    noWrap: boolean,
+    object: null,
+    profile: null,
+    prompt: null,
+    rev: null,
+    rightMargin: number,
+    rules: null,
+    scheme: null,
+    scrolling: booleanish,
+    standby: null,
+    summary: null,
+    text: null,
+    topMargin: number,
+    valueType: null,
+    version: null,
+    vAlign: null,
+    vLink: null,
+    vSpace: number,
+    allowTransparency: null,
+    autoCorrect: null,
+    autoSave: null,
+    disablePictureInPicture: boolean,
+    disableRemotePlayback: boolean,
+    prefix: null,
+    property: null,
+    results: number,
+    security: null,
+    unselectable: null
+  }
+});
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/svg.js
+var svg = create3({
+  space: "svg",
+  attributes: {
+    accentHeight: "accent-height",
+    alignmentBaseline: "alignment-baseline",
+    arabicForm: "arabic-form",
+    baselineShift: "baseline-shift",
+    capHeight: "cap-height",
+    className: "class",
+    clipPath: "clip-path",
+    clipRule: "clip-rule",
+    colorInterpolation: "color-interpolation",
+    colorInterpolationFilters: "color-interpolation-filters",
+    colorProfile: "color-profile",
+    colorRendering: "color-rendering",
+    crossOrigin: "crossorigin",
+    dataType: "datatype",
+    dominantBaseline: "dominant-baseline",
+    enableBackground: "enable-background",
+    fillOpacity: "fill-opacity",
+    fillRule: "fill-rule",
+    floodColor: "flood-color",
+    floodOpacity: "flood-opacity",
+    fontFamily: "font-family",
+    fontSize: "font-size",
+    fontSizeAdjust: "font-size-adjust",
+    fontStretch: "font-stretch",
+    fontStyle: "font-style",
+    fontVariant: "font-variant",
+    fontWeight: "font-weight",
+    glyphName: "glyph-name",
+    glyphOrientationHorizontal: "glyph-orientation-horizontal",
+    glyphOrientationVertical: "glyph-orientation-vertical",
+    hrefLang: "hreflang",
+    horizAdvX: "horiz-adv-x",
+    horizOriginX: "horiz-origin-x",
+    horizOriginY: "horiz-origin-y",
+    imageRendering: "image-rendering",
+    letterSpacing: "letter-spacing",
+    lightingColor: "lighting-color",
+    markerEnd: "marker-end",
+    markerMid: "marker-mid",
+    markerStart: "marker-start",
+    navDown: "nav-down",
+    navDownLeft: "nav-down-left",
+    navDownRight: "nav-down-right",
+    navLeft: "nav-left",
+    navNext: "nav-next",
+    navPrev: "nav-prev",
+    navRight: "nav-right",
+    navUp: "nav-up",
+    navUpLeft: "nav-up-left",
+    navUpRight: "nav-up-right",
+    onAbort: "onabort",
+    onActivate: "onactivate",
+    onAfterPrint: "onafterprint",
+    onBeforePrint: "onbeforeprint",
+    onBegin: "onbegin",
+    onCancel: "oncancel",
+    onCanPlay: "oncanplay",
+    onCanPlayThrough: "oncanplaythrough",
+    onChange: "onchange",
+    onClick: "onclick",
+    onClose: "onclose",
+    onCopy: "oncopy",
+    onCueChange: "oncuechange",
+    onCut: "oncut",
+    onDblClick: "ondblclick",
+    onDrag: "ondrag",
+    onDragEnd: "ondragend",
+    onDragEnter: "ondragenter",
+    onDragExit: "ondragexit",
+    onDragLeave: "ondragleave",
+    onDragOver: "ondragover",
+    onDragStart: "ondragstart",
+    onDrop: "ondrop",
+    onDurationChange: "ondurationchange",
+    onEmptied: "onemptied",
+    onEnd: "onend",
+    onEnded: "onended",
+    onError: "onerror",
+    onFocus: "onfocus",
+    onFocusIn: "onfocusin",
+    onFocusOut: "onfocusout",
+    onHashChange: "onhashchange",
+    onInput: "oninput",
+    onInvalid: "oninvalid",
+    onKeyDown: "onkeydown",
+    onKeyPress: "onkeypress",
+    onKeyUp: "onkeyup",
+    onLoad: "onload",
+    onLoadedData: "onloadeddata",
+    onLoadedMetadata: "onloadedmetadata",
+    onLoadStart: "onloadstart",
+    onMessage: "onmessage",
+    onMouseDown: "onmousedown",
+    onMouseEnter: "onmouseenter",
+    onMouseLeave: "onmouseleave",
+    onMouseMove: "onmousemove",
+    onMouseOut: "onmouseout",
+    onMouseOver: "onmouseover",
+    onMouseUp: "onmouseup",
+    onMouseWheel: "onmousewheel",
+    onOffline: "onoffline",
+    onOnline: "ononline",
+    onPageHide: "onpagehide",
+    onPageShow: "onpageshow",
+    onPaste: "onpaste",
+    onPause: "onpause",
+    onPlay: "onplay",
+    onPlaying: "onplaying",
+    onPopState: "onpopstate",
+    onProgress: "onprogress",
+    onRateChange: "onratechange",
+    onRepeat: "onrepeat",
+    onReset: "onreset",
+    onResize: "onresize",
+    onScroll: "onscroll",
+    onSeeked: "onseeked",
+    onSeeking: "onseeking",
+    onSelect: "onselect",
+    onShow: "onshow",
+    onStalled: "onstalled",
+    onStorage: "onstorage",
+    onSubmit: "onsubmit",
+    onSuspend: "onsuspend",
+    onTimeUpdate: "ontimeupdate",
+    onToggle: "ontoggle",
+    onUnload: "onunload",
+    onVolumeChange: "onvolumechange",
+    onWaiting: "onwaiting",
+    onZoom: "onzoom",
+    overlinePosition: "overline-position",
+    overlineThickness: "overline-thickness",
+    paintOrder: "paint-order",
+    panose1: "panose-1",
+    pointerEvents: "pointer-events",
+    referrerPolicy: "referrerpolicy",
+    renderingIntent: "rendering-intent",
+    shapeRendering: "shape-rendering",
+    stopColor: "stop-color",
+    stopOpacity: "stop-opacity",
+    strikethroughPosition: "strikethrough-position",
+    strikethroughThickness: "strikethrough-thickness",
+    strokeDashArray: "stroke-dasharray",
+    strokeDashOffset: "stroke-dashoffset",
+    strokeLineCap: "stroke-linecap",
+    strokeLineJoin: "stroke-linejoin",
+    strokeMiterLimit: "stroke-miterlimit",
+    strokeOpacity: "stroke-opacity",
+    strokeWidth: "stroke-width",
+    tabIndex: "tabindex",
+    textAnchor: "text-anchor",
+    textDecoration: "text-decoration",
+    textRendering: "text-rendering",
+    typeOf: "typeof",
+    underlinePosition: "underline-position",
+    underlineThickness: "underline-thickness",
+    unicodeBidi: "unicode-bidi",
+    unicodeRange: "unicode-range",
+    unitsPerEm: "units-per-em",
+    vAlphabetic: "v-alphabetic",
+    vHanging: "v-hanging",
+    vIdeographic: "v-ideographic",
+    vMathematical: "v-mathematical",
+    vectorEffect: "vector-effect",
+    vertAdvY: "vert-adv-y",
+    vertOriginX: "vert-origin-x",
+    vertOriginY: "vert-origin-y",
+    wordSpacing: "word-spacing",
+    writingMode: "writing-mode",
+    xHeight: "x-height",
+    playbackOrder: "playbackorder",
+    timelineBegin: "timelinebegin"
+  },
+  transform: caseSensitiveTransform,
+  properties: {
+    about: commaOrSpaceSeparated,
+    accentHeight: number,
+    accumulate: null,
+    additive: null,
+    alignmentBaseline: null,
+    alphabetic: number,
+    amplitude: number,
+    arabicForm: null,
+    ascent: number,
+    attributeName: null,
+    attributeType: null,
+    azimuth: number,
+    bandwidth: null,
+    baselineShift: null,
+    baseFrequency: null,
+    baseProfile: null,
+    bbox: null,
+    begin: null,
+    bias: number,
+    by: null,
+    calcMode: null,
+    capHeight: number,
+    className: spaceSeparated,
+    clip: null,
+    clipPath: null,
+    clipPathUnits: null,
+    clipRule: null,
+    color: null,
+    colorInterpolation: null,
+    colorInterpolationFilters: null,
+    colorProfile: null,
+    colorRendering: null,
+    content: null,
+    contentScriptType: null,
+    contentStyleType: null,
+    crossOrigin: null,
+    cursor: null,
+    cx: null,
+    cy: null,
+    d: null,
+    dataType: null,
+    defaultAction: null,
+    descent: number,
+    diffuseConstant: number,
+    direction: null,
+    display: null,
+    dur: null,
+    divisor: number,
+    dominantBaseline: null,
+    download: boolean,
+    dx: null,
+    dy: null,
+    edgeMode: null,
+    editable: null,
+    elevation: number,
+    enableBackground: null,
+    end: null,
+    event: null,
+    exponent: number,
+    externalResourcesRequired: null,
+    fill: null,
+    fillOpacity: number,
+    fillRule: null,
+    filter: null,
+    filterRes: null,
+    filterUnits: null,
+    floodColor: null,
+    floodOpacity: null,
+    focusable: null,
+    focusHighlight: null,
+    fontFamily: null,
+    fontSize: null,
+    fontSizeAdjust: null,
+    fontStretch: null,
+    fontStyle: null,
+    fontVariant: null,
+    fontWeight: null,
+    format: null,
+    fr: null,
+    from: null,
+    fx: null,
+    fy: null,
+    g1: commaSeparated,
+    g2: commaSeparated,
+    glyphName: commaSeparated,
+    glyphOrientationHorizontal: null,
+    glyphOrientationVertical: null,
+    glyphRef: null,
+    gradientTransform: null,
+    gradientUnits: null,
+    handler: null,
+    hanging: number,
+    hatchContentUnits: null,
+    hatchUnits: null,
+    height: null,
+    href: null,
+    hrefLang: null,
+    horizAdvX: number,
+    horizOriginX: number,
+    horizOriginY: number,
+    id: null,
+    ideographic: number,
+    imageRendering: null,
+    initialVisibility: null,
+    in: null,
+    in2: null,
+    intercept: number,
+    k: number,
+    k1: number,
+    k2: number,
+    k3: number,
+    k4: number,
+    kernelMatrix: commaOrSpaceSeparated,
+    kernelUnitLength: null,
+    keyPoints: null,
+    keySplines: null,
+    keyTimes: null,
+    kerning: null,
+    lang: null,
+    lengthAdjust: null,
+    letterSpacing: null,
+    lightingColor: null,
+    limitingConeAngle: number,
+    local: null,
+    markerEnd: null,
+    markerMid: null,
+    markerStart: null,
+    markerHeight: null,
+    markerUnits: null,
+    markerWidth: null,
+    mask: null,
+    maskContentUnits: null,
+    maskUnits: null,
+    mathematical: null,
+    max: null,
+    media: null,
+    mediaCharacterEncoding: null,
+    mediaContentEncodings: null,
+    mediaSize: number,
+    mediaTime: null,
+    method: null,
+    min: null,
+    mode: null,
+    name: null,
+    navDown: null,
+    navDownLeft: null,
+    navDownRight: null,
+    navLeft: null,
+    navNext: null,
+    navPrev: null,
+    navRight: null,
+    navUp: null,
+    navUpLeft: null,
+    navUpRight: null,
+    numOctaves: null,
+    observer: null,
+    offset: null,
+    onAbort: null,
+    onActivate: null,
+    onAfterPrint: null,
+    onBeforePrint: null,
+    onBegin: null,
+    onCancel: null,
+    onCanPlay: null,
+    onCanPlayThrough: null,
+    onChange: null,
+    onClick: null,
+    onClose: null,
+    onCopy: null,
+    onCueChange: null,
+    onCut: null,
+    onDblClick: null,
+    onDrag: null,
+    onDragEnd: null,
+    onDragEnter: null,
+    onDragExit: null,
+    onDragLeave: null,
+    onDragOver: null,
+    onDragStart: null,
+    onDrop: null,
+    onDurationChange: null,
+    onEmptied: null,
+    onEnd: null,
+    onEnded: null,
+    onError: null,
+    onFocus: null,
+    onFocusIn: null,
+    onFocusOut: null,
+    onHashChange: null,
+    onInput: null,
+    onInvalid: null,
+    onKeyDown: null,
+    onKeyPress: null,
+    onKeyUp: null,
+    onLoad: null,
+    onLoadedData: null,
+    onLoadedMetadata: null,
+    onLoadStart: null,
+    onMessage: null,
+    onMouseDown: null,
+    onMouseEnter: null,
+    onMouseLeave: null,
+    onMouseMove: null,
+    onMouseOut: null,
+    onMouseOver: null,
+    onMouseUp: null,
+    onMouseWheel: null,
+    onOffline: null,
+    onOnline: null,
+    onPageHide: null,
+    onPageShow: null,
+    onPaste: null,
+    onPause: null,
+    onPlay: null,
+    onPlaying: null,
+    onPopState: null,
+    onProgress: null,
+    onRateChange: null,
+    onRepeat: null,
+    onReset: null,
+    onResize: null,
+    onScroll: null,
+    onSeeked: null,
+    onSeeking: null,
+    onSelect: null,
+    onShow: null,
+    onStalled: null,
+    onStorage: null,
+    onSubmit: null,
+    onSuspend: null,
+    onTimeUpdate: null,
+    onToggle: null,
+    onUnload: null,
+    onVolumeChange: null,
+    onWaiting: null,
+    onZoom: null,
+    opacity: null,
+    operator: null,
+    order: null,
+    orient: null,
+    orientation: null,
+    origin: null,
+    overflow: null,
+    overlay: null,
+    overlinePosition: number,
+    overlineThickness: number,
+    paintOrder: null,
+    panose1: null,
+    path: null,
+    pathLength: number,
+    patternContentUnits: null,
+    patternTransform: null,
+    patternUnits: null,
+    phase: null,
+    ping: spaceSeparated,
+    pitch: null,
+    playbackOrder: null,
+    pointerEvents: null,
+    points: null,
+    pointsAtX: number,
+    pointsAtY: number,
+    pointsAtZ: number,
+    preserveAlpha: null,
+    preserveAspectRatio: null,
+    primitiveUnits: null,
+    propagate: null,
+    property: commaOrSpaceSeparated,
+    r: null,
+    radius: null,
+    referrerPolicy: null,
+    refX: null,
+    refY: null,
+    rel: commaOrSpaceSeparated,
+    rev: commaOrSpaceSeparated,
+    renderingIntent: null,
+    repeatCount: null,
+    repeatDur: null,
+    requiredExtensions: commaOrSpaceSeparated,
+    requiredFeatures: commaOrSpaceSeparated,
+    requiredFonts: commaOrSpaceSeparated,
+    requiredFormats: commaOrSpaceSeparated,
+    resource: null,
+    restart: null,
+    result: null,
+    rotate: null,
+    rx: null,
+    ry: null,
+    scale: null,
+    seed: null,
+    shapeRendering: null,
+    side: null,
+    slope: null,
+    snapshotTime: null,
+    specularConstant: number,
+    specularExponent: number,
+    spreadMethod: null,
+    spacing: null,
+    startOffset: null,
+    stdDeviation: null,
+    stemh: null,
+    stemv: null,
+    stitchTiles: null,
+    stopColor: null,
+    stopOpacity: null,
+    strikethroughPosition: number,
+    strikethroughThickness: number,
+    string: null,
+    stroke: null,
+    strokeDashArray: commaOrSpaceSeparated,
+    strokeDashOffset: null,
+    strokeLineCap: null,
+    strokeLineJoin: null,
+    strokeMiterLimit: number,
+    strokeOpacity: number,
+    strokeWidth: null,
+    style: null,
+    surfaceScale: number,
+    syncBehavior: null,
+    syncBehaviorDefault: null,
+    syncMaster: null,
+    syncTolerance: null,
+    syncToleranceDefault: null,
+    systemLanguage: commaOrSpaceSeparated,
+    tabIndex: number,
+    tableValues: null,
+    target: null,
+    targetX: number,
+    targetY: number,
+    textAnchor: null,
+    textDecoration: null,
+    textRendering: null,
+    textLength: null,
+    timelineBegin: null,
+    title: null,
+    transformBehavior: null,
+    type: null,
+    typeOf: commaOrSpaceSeparated,
+    to: null,
+    transform: null,
+    u1: null,
+    u2: null,
+    underlinePosition: number,
+    underlineThickness: number,
+    unicode: null,
+    unicodeBidi: null,
+    unicodeRange: null,
+    unitsPerEm: number,
+    values: null,
+    vAlphabetic: number,
+    vMathematical: number,
+    vectorEffect: null,
+    vHanging: number,
+    vIdeographic: number,
+    version: null,
+    vertAdvY: number,
+    vertOriginX: number,
+    vertOriginY: number,
+    viewBox: null,
+    viewTarget: null,
+    visibility: null,
+    width: null,
+    widths: null,
+    wordSpacing: null,
+    writingMode: null,
+    x: null,
+    x1: null,
+    x2: null,
+    xChannelSelector: null,
+    xHeight: number,
+    y: null,
+    y1: null,
+    y2: null,
+    yChannelSelector: null,
+    z: null,
+    zoomAndPan: null
+  }
+});
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/find.js
+var valid = /^data[-\w.:]+$/i;
+var dash = /-[a-z]/g;
+var cap = /[A-Z]/g;
+function find(schema, value) {
+  const normal = normalize5(value);
+  let prop = value;
+  let Type = Info;
+  if (normal in schema.normal) {
+    return schema.property[schema.normal[normal]];
+  }
+  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
+    if (value.charAt(4) === "-") {
+      const rest = value.slice(5).replace(dash, camelcase);
+      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
+    } else {
+      const rest = value.slice(4);
+      if (!dash.test(rest)) {
+        let dashes = rest.replace(cap, kebab);
+        if (dashes.charAt(0) !== "-") {
+          dashes = "-" + dashes;
+        }
+        value = "data" + dashes;
+      }
+    }
+    Type = DefinedInfo;
+  }
+  return new Type(prop, value);
+}
+function kebab($0) {
+  return "-" + $0.toLowerCase();
+}
+function camelcase($0) {
+  return $0.charAt(1).toUpperCase();
+}
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/lib/hast-to-react.js
+var hastToReact = {
+  classId: "classID",
+  dataType: "datatype",
+  itemId: "itemID",
+  strokeDashArray: "strokeDasharray",
+  strokeDashOffset: "strokeDashoffset",
+  strokeLineCap: "strokeLinecap",
+  strokeLineJoin: "strokeLinejoin",
+  strokeMiterLimit: "strokeMiterlimit",
+  typeOf: "typeof",
+  xLinkActuate: "xlinkActuate",
+  xLinkArcRole: "xlinkArcrole",
+  xLinkHref: "xlinkHref",
+  xLinkRole: "xlinkRole",
+  xLinkShow: "xlinkShow",
+  xLinkTitle: "xlinkTitle",
+  xLinkType: "xlinkType",
+  xmlnsXLink: "xmlnsXlink"
+};
+
+// ../../node_modules/.pnpm/property-information@6.1.1/node_modules/property-information/index.js
+var html3 = merge([xml, xlink, xmlns, aria, html2], "html");
+var svg2 = merge([xml, xlink, xmlns, aria, svg], "svg");
+
+// ../../node_modules/.pnpm/space-separated-tokens@2.0.1/node_modules/space-separated-tokens/index.js
+function stringify3(values) {
+  return values.join(" ").trim();
+}
+
+// ../../node_modules/.pnpm/hast-util-to-estree@2.0.2/node_modules/hast-util-to-estree/index.js
+var import_style_to_object = __toESM(require_style_to_object(), 1);
+
+// ../../node_modules/.pnpm/zwitch@2.0.2/node_modules/zwitch/index.js
+var own12 = {}.hasOwnProperty;
+function zwitch(key, options) {
+  var settings = options || {};
+  function one3(value) {
+    var fn = one3.invalid;
+    var handlers2 = one3.handlers;
+    if (value && own12.call(value, key)) {
+      fn = own12.call(handlers2, value[key]) ? handlers2[value[key]] : one3.unknown;
+    }
+    if (fn) {
+      return fn.apply(this, arguments);
+    }
+  }
+  one3.handlers = settings.handlers || {};
+  one3.invalid = settings.invalid;
+  one3.unknown = settings.unknown;
+  return one3;
+}
+
+// ../../node_modules/.pnpm/hast-util-to-estree@2.0.2/node_modules/hast-util-to-estree/index.js
+var toReact = hastToReact;
+var own13 = {}.hasOwnProperty;
+var tableElements = /* @__PURE__ */ new Set([
+  "table",
+  "thead",
+  "tbody",
+  "tfoot",
+  "tr",
+  "th",
+  "td"
+]);
+function toEstree(tree, options = {}) {
+  const context = {
+    schema: options.space === "svg" ? svg2 : html3,
+    comments: [],
+    esm: [],
+    handle: zwitch("type", {
+      invalid,
+      unknown: unknown2,
+      handlers: Object.assign({}, {
+        comment,
+        doctype: ignore2,
+        element,
+        mdxjsEsm: mdxjsEsm2,
+        mdxFlowExpression: mdxExpression2,
+        mdxJsxFlowElement: mdxJsxElement,
+        mdxJsxTextElement: mdxJsxElement,
+        mdxTextExpression: mdxExpression2,
+        root: root2,
+        text: text4
+      }, options.handlers)
+    })
+  };
+  let result = context.handle(tree, context);
+  const body = context.esm;
+  if (result) {
+    if (result.type !== "JSXFragment" && result.type !== "JSXElement") {
+      result = create4(tree, {
+        type: "JSXFragment",
+        openingFragment: { type: "JSXOpeningFragment" },
+        closingFragment: { type: "JSXClosingFragment" },
+        children: [result]
+      });
+    }
+    body.push(create4(tree, { type: "ExpressionStatement", expression: result }));
+  }
+  return create4(tree, {
+    type: "Program",
+    body,
+    sourceType: "module",
+    comments: context.comments
+  });
+}
+function invalid(value) {
+  throw new Error("Cannot handle value `" + value + "`, expected node");
+}
+function unknown2(node) {
+  throw new Error("Cannot handle unknown node `" + node.type + "`");
+}
+function ignore2() {
+}
+function comment(node, context) {
+  const esnode = inherit(node, { type: "Block", value: node.value });
+  context.comments.push(esnode);
+  return create4(node, {
+    type: "JSXExpressionContainer",
+    expression: create4(node, {
+      type: "JSXEmptyExpression",
+      comments: [Object.assign({}, esnode, { leading: false, trailing: true })]
+    })
+  });
+}
+function element(node, context) {
+  const parentSchema = context.schema;
+  let schema = parentSchema;
+  const props = node.properties || {};
+  if (parentSchema.space === "html" && node.tagName.toLowerCase() === "svg") {
+    schema = svg2;
+    context.schema = schema;
+  }
+  const children = all3(node, context);
+  const attributes = [];
+  let prop;
+  for (prop in props) {
+    if (own13.call(props, prop)) {
+      let value = props[prop];
+      const info = find(schema, prop);
+      let attributeValue;
+      if (value === void 0 || value === null || typeof value === "number" && Number.isNaN(value) || value === false || !value && info.boolean) {
+        continue;
+      }
+      prop = info.space ? toReact[info.property] || info.property : info.attribute;
+      if (Array.isArray(value)) {
+        value = info.commaSeparated ? stringify2(value) : stringify3(value);
+      }
+      if (prop === "style") {
+        const styleValue = typeof value === "string" ? parseStyle(value, node.tagName) : value;
+        const cssProperties = [];
+        let cssProp;
+        for (cssProp in styleValue) {
+          if (own13.call(styleValue, cssProp)) {
+            cssProperties.push({
+              type: "Property",
+              method: false,
+              shorthand: false,
+              computed: false,
+              key: { type: "Identifier", name: cssProp },
+              value: { type: "Literal", value: String(styleValue[cssProp]) },
+              kind: "init"
+            });
+          }
+        }
+        attributeValue = {
+          type: "JSXExpressionContainer",
+          expression: { type: "ObjectExpression", properties: cssProperties }
+        };
+      } else if (value === true) {
+        attributeValue = null;
+      } else {
+        attributeValue = { type: "Literal", value: String(value) };
+      }
+      if (jsxIdentifierName(prop)) {
+        attributes.push({
+          type: "JSXAttribute",
+          name: { type: "JSXIdentifier", name: prop },
+          value: attributeValue
+        });
+      } else {
+        attributes.push({
+          type: "JSXSpreadAttribute",
+          argument: {
+            type: "ObjectExpression",
+            properties: [
+              {
+                type: "Property",
+                method: false,
+                shorthand: false,
+                computed: false,
+                key: { type: "Literal", value: String(prop) },
+                value: attributeValue || { type: "Literal", value: true },
+                kind: "init"
+              }
+            ]
+          }
+        });
+      }
+    }
+  }
+  context.schema = parentSchema;
+  return inherit(node, {
+    type: "JSXElement",
+    openingElement: {
+      type: "JSXOpeningElement",
+      attributes,
+      name: createJsxName(node.tagName),
+      selfClosing: children.length === 0
+    },
+    closingElement: children.length > 0 ? { type: "JSXClosingElement", name: createJsxName(node.tagName) } : null,
+    children
+  });
+}
+function mdxjsEsm2(node, context) {
+  const estree = node.data && node.data.estree;
+  const comments = estree && estree.comments || [];
+  if (estree) {
+    context.comments.push(...comments);
+    attachComments(estree, comments);
+    context.esm.push(...estree.body);
+  }
+}
+function mdxExpression2(node, context) {
+  const estree = node.data && node.data.estree;
+  const comments = estree && estree.comments || [];
+  let expression;
+  if (estree) {
+    context.comments.push(...comments);
+    attachComments(estree, estree.comments);
+    expression = estree.body[0] && estree.body[0].type === "ExpressionStatement" && estree.body[0].expression || void 0;
+  }
+  return inherit(node, {
+    type: "JSXExpressionContainer",
+    expression: expression || create4(node, { type: "JSXEmptyExpression" })
+  });
+}
+function mdxJsxElement(node, context) {
+  const parentSchema = context.schema;
+  let schema = parentSchema;
+  const attrs = node.attributes || [];
+  let index3 = -1;
+  if (node.name && parentSchema.space === "html" && node.name.toLowerCase() === "svg") {
+    schema = svg2;
+    context.schema = schema;
+  }
+  const children = all3(node, context);
+  const attributes = [];
+  while (++index3 < attrs.length) {
+    const attr = attrs[index3];
+    const value = attr.value;
+    let attributeValue;
+    if (attr.type === "mdxJsxAttribute") {
+      if (value === void 0 || value === null) {
+        attributeValue = null;
+      } else if (typeof value === "object") {
+        const estree = value.data && value.data.estree;
+        const comments = estree && estree.comments || [];
+        let expression;
+        if (estree) {
+          context.comments.push(...comments);
+          attachComments(estree, estree.comments);
+          expression = estree.body[0] && estree.body[0].type === "ExpressionStatement" && estree.body[0].expression || void 0;
+        }
+        attributeValue = inherit(value, {
+          type: "JSXExpressionContainer",
+          expression: expression || { type: "JSXEmptyExpression" }
+        });
+      } else {
+        attributeValue = { type: "Literal", value: String(value) };
+      }
+      attributes.push(inherit(attr, {
+        type: "JSXAttribute",
+        name: createJsxName(attr.name, true),
+        value: attributeValue
+      }));
+    } else {
+      const estree = attr.data && attr.data.estree;
+      const comments = estree && estree.comments || [];
+      let argumentValue;
+      if (estree) {
+        context.comments.push(...comments);
+        attachComments(estree, estree.comments);
+        argumentValue = estree.body[0] && estree.body[0].type === "ExpressionStatement" && estree.body[0].expression && estree.body[0].expression.type === "ObjectExpression" && estree.body[0].expression.properties && estree.body[0].expression.properties[0] && estree.body[0].expression.properties[0].type === "SpreadElement" && estree.body[0].expression.properties[0].argument || void 0;
+      }
+      attributes.push(inherit(attr, {
+        type: "JSXSpreadAttribute",
+        argument: argumentValue || { type: "ObjectExpression", properties: [] }
+      }));
+    }
+  }
+  context.schema = parentSchema;
+  return inherit(node, node.name ? {
+    type: "JSXElement",
+    openingElement: {
+      type: "JSXOpeningElement",
+      attributes,
+      name: createJsxName(node.name),
+      selfClosing: children.length === 0
+    },
+    closingElement: children.length > 0 ? { type: "JSXClosingElement", name: createJsxName(node.name) } : null,
+    children
+  } : {
+    type: "JSXFragment",
+    openingFragment: { type: "JSXOpeningFragment" },
+    closingFragment: { type: "JSXClosingFragment" },
+    children
+  });
+}
+function root2(node, context) {
+  const children = all3(node, context);
+  const cleanChildren = [];
+  let index3 = -1;
+  let queue;
+  while (++index3 < children.length) {
+    const child = children[index3];
+    if (child.type === "JSXExpressionContainer" && child.expression.type === "Literal" && whitespace(child.expression.value)) {
+      if (queue)
+        queue.push(child);
+    } else {
+      if (queue)
+        cleanChildren.push(...queue);
+      cleanChildren.push(child);
+      queue = [];
+    }
+  }
+  return inherit(node, {
+    type: "JSXFragment",
+    openingFragment: { type: "JSXOpeningFragment" },
+    closingFragment: { type: "JSXClosingFragment" },
+    children: cleanChildren
+  });
+}
+function text4(node) {
+  const value = String(node.value || "");
+  if (!value)
+    return;
+  return create4(node, {
+    type: "JSXExpressionContainer",
+    expression: inherit(node, { type: "Literal", value })
+  });
+}
+function all3(parent, context) {
+  const children = parent.children || [];
+  let index3 = -1;
+  const results = [];
+  const ignoreLineBreak = context.schema.space === "html" && parent.type === "element" && tableElements.has(parent.tagName.toLowerCase());
+  while (++index3 < children.length) {
+    const child = children[index3];
+    if (ignoreLineBreak && child.type === "text" && child.value === "\n") {
+      continue;
+    }
+    const result = context.handle(child, context);
+    if (Array.isArray(result)) {
+      results.push(...result);
+    } else if (result) {
+      results.push(result);
+    }
+  }
+  return results;
+}
+function inherit(hast, esnode) {
+  const left = hast.data;
+  let right;
+  let key;
+  create4(hast, esnode);
+  if (left) {
+    for (key in left) {
+      if (own13.call(left, key) && key !== "estree") {
+        if (!right)
+          right = {};
+        right[key] = left[key];
+      }
+    }
+    if (right) {
+      esnode.data = right;
+    }
+  }
+  return esnode;
+}
+function create4(hast, esnode) {
+  const p = position2(hast);
+  if (p.start.line && p.start.offset !== void 0 && p.end.offset !== void 0) {
+    esnode.start = p.start.offset;
+    esnode.end = p.end.offset;
+    esnode.loc = {
+      start: { line: p.start.line, column: p.start.column - 1 },
+      end: { line: p.end.line, column: p.end.column - 1 }
+    };
+    esnode.range = [p.start.offset, p.end.offset];
+  }
+  return esnode;
+}
+var createJsxName = function(name3, attribute) {
+  if (!attribute && name3.includes(".")) {
+    const parts = name3.split(".");
+    let part = parts.shift();
+    let node = { type: "JSXIdentifier", name: part };
+    while (part = parts.shift()) {
+      node = {
+        type: "JSXMemberExpression",
+        object: node,
+        property: { type: "JSXIdentifier", name: part }
+      };
+    }
+    return node;
+  }
+  if (name3.includes(":")) {
+    const parts = name3.split(":");
+    return {
+      type: "JSXNamespacedName",
+      namespace: { type: "JSXIdentifier", name: parts[0] },
+      name: { type: "JSXIdentifier", name: parts[1] }
+    };
+  }
+  return { type: "JSXIdentifier", name: name3 };
+};
+function parseStyle(value, tagName) {
+  const result = {};
+  try {
+    (0, import_style_to_object.default)(value, iterator);
+  } catch (error) {
+    const exception = error;
+    exception.message = tagName + "[style]" + exception.message.slice("undefined".length);
+    throw error;
+  }
+  return result;
+  function iterator(name3, value2) {
+    if (name3.slice(0, 4) === "-ms-")
+      name3 = "ms-" + name3.slice(4);
+    result[name3.replace(/-([a-z])/g, styleReplacer)] = value2;
+  }
+}
+function styleReplacer(_, $1) {
+  return $1.toUpperCase();
+}
+function jsxIdentifierName(name3) {
+  let index3 = -1;
+  while (++index3 < name3.length) {
+    if (!(index3 ? cont3 : start2)(name3.charCodeAt(index3)))
+      return false;
+  }
+  return index3 > 0;
+  function cont3(code3) {
+    return cont2(code3) || code3 === 45;
+  }
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/plugin/rehype-recma.js
+function rehypeRecma() {
+  return (tree) => toEstree(tree);
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/plugin/rehype-remove-raw.js
+function rehypeRemoveRaw() {
+  return (tree) => {
+    visit2(tree, "raw", (_, index3, parent) => {
+      if (parent && typeof index3 === "number") {
+        parent.children.splice(index3, 1);
+        return index3;
+      }
+    });
+  };
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/plugin/remark-mark-and-unravel.js
+function remarkMarkAndUnravel() {
+  return (tree) => {
+    visit2(tree, (node, index3, parent_) => {
+      const parent = parent_;
+      let offset2 = -1;
+      let all4 = true;
+      let oneOrMore;
+      if (parent && typeof index3 === "number" && node.type === "paragraph") {
+        const children = node.children;
+        while (++offset2 < children.length) {
+          const child = children[offset2];
+          if (child.type === "mdxJsxTextElement" || child.type === "mdxTextExpression") {
+            oneOrMore = true;
+          } else if (child.type === "text" && /^[\t\r\n ]+$/.test(String(child.value))) {
+          } else {
+            all4 = false;
+            break;
+          }
+        }
+        if (all4 && oneOrMore) {
+          offset2 = -1;
+          while (++offset2 < children.length) {
+            const child = children[offset2];
+            if (child.type === "mdxJsxTextElement") {
+              child.type = "mdxJsxFlowElement";
+            }
+            if (child.type === "mdxTextExpression") {
+              child.type = "mdxFlowExpression";
+            }
+          }
+          parent.children.splice(index3, 1, ...children);
+          return index3;
+        }
+      }
+      if (node.type === "mdxJsxFlowElement" || node.type === "mdxJsxTextElement") {
+        const data2 = node.data || (node.data = {});
+        data2._mdxExplicitJsx = true;
+      }
+    });
+  };
+}
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/node-types.js
+var nodeTypes = [
+  "mdxFlowExpression",
+  "mdxJsxFlowElement",
+  "mdxJsxTextElement",
+  "mdxTextExpression",
+  "mdxjsEsm"
+];
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/condition.js
+import process from "process";
+var development = process.env.NODE_ENV === "development";
+
+// ../../node_modules/.pnpm/@mdx-js+mdx@2.1.0/node_modules/@mdx-js/mdx/lib/core.js
+var removedOptions = [
+  "filepath",
+  "compilers",
+  "hastPlugins",
+  "mdPlugins",
+  "skipExport",
+  "wrapExport"
+];
+function createProcessor(options = {}) {
+  const _a = options, {
+    development: development2 = development,
+    jsx,
+    format,
+    outputFormat,
+    providerImportSource,
+    recmaPlugins,
+    rehypePlugins,
+    remarkPlugins,
+    remarkRehypeOptions = {},
+    SourceMapGenerator
+  } = _a, rest = __objRest(_a, [
+    "development",
+    "jsx",
+    "format",
+    "outputFormat",
+    "providerImportSource",
+    "recmaPlugins",
+    "rehypePlugins",
+    "remarkPlugins",
+    "remarkRehypeOptions",
+    "SourceMapGenerator"
+  ]);
+  let index3 = -1;
+  while (++index3 < removedOptions.length) {
+    const key = removedOptions[index3];
+    if (key in options) {
+      throw new Error("`options." + key + "` is no longer supported. Please see <https://mdxjs.com/migrating/v2/> for more information");
+    }
+  }
+  if (format === "detect") {
+    throw new Error("Incorrect `format: 'detect'`: `createProcessor` can support either `md` or `mdx`; it does not support detecting the format");
+  }
+  const pipeline = unified().use(remark_parse_default);
+  if (format !== "md") {
+    pipeline.use(remarkMdx);
+  }
+  pipeline.use(remarkMarkAndUnravel).use(remarkPlugins || []).use(lib_default, __spreadProps(__spreadValues({}, remarkRehypeOptions), {
+    allowDangerousHtml: true,
+    passThrough: [...remarkRehypeOptions.passThrough || [], ...nodeTypes]
+  })).use(rehypePlugins || []);
+  if (format === "md") {
+    pipeline.use(rehypeRemoveRaw);
+  }
+  pipeline.use(rehypeRecma).use(recmaDocument, __spreadProps(__spreadValues({}, rest), { outputFormat })).use(recmaJsxRewrite, { development: development2, providerImportSource, outputFormat });
+  if (!jsx) {
+    pipeline.use(recmaJsxBuild, { outputFormat });
+  }
+  pipeline.use(recmaStringify, { SourceMapGenerator }).use(recmaPlugins || []);
+  return pipeline;
+}
+
+// ../../node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.3/node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
+var www = {
+  tokenize: tokenizeWww,
+  partial: true
+};
+var domain = {
+  tokenize: tokenizeDomain,
+  partial: true
+};
+var path = {
+  tokenize: tokenizePath,
+  partial: true
+};
+var punctuation = {
+  tokenize: tokenizePunctuation,
+  partial: true
+};
+var namedCharacterReference = {
+  tokenize: tokenizeNamedCharacterReference,
+  partial: true
+};
+var wwwAutolink = {
+  tokenize: tokenizeWwwAutolink,
+  previous: previousWww
+};
+var httpAutolink = {
+  tokenize: tokenizeHttpAutolink,
+  previous: previousHttp
+};
+var emailAutolink = {
+  tokenize: tokenizeEmailAutolink,
+  previous: previousEmail
+};
+var text5 = {};
+var gfmAutolinkLiteral = {
+  text: text5
+};
+var code2 = 48;
+while (code2 < 123) {
+  text5[code2] = emailAutolink;
+  code2++;
+  if (code2 === 58)
+    code2 = 65;
+  else if (code2 === 91)
+    code2 = 97;
+}
+text5[43] = emailAutolink;
+text5[45] = emailAutolink;
+text5[46] = emailAutolink;
+text5[95] = emailAutolink;
+text5[72] = [emailAutolink, httpAutolink];
+text5[104] = [emailAutolink, httpAutolink];
+text5[87] = [emailAutolink, wwwAutolink];
+text5[119] = [emailAutolink, wwwAutolink];
+function tokenizeEmailAutolink(effects, ok3, nok) {
+  const self2 = this;
+  let hasDot;
+  let hasDigitInLastSegment;
+  return start3;
+  function start3(code3) {
+    if (!gfmAtext(code3) || !previousEmail(self2.previous) || previousUnbalanced(self2.events)) {
+      return nok(code3);
+    }
+    effects.enter("literalAutolink");
+    effects.enter("literalAutolinkEmail");
+    return atext(code3);
+  }
+  function atext(code3) {
+    if (gfmAtext(code3)) {
+      effects.consume(code3);
+      return atext;
+    }
+    if (code3 === 64) {
+      effects.consume(code3);
+      return label;
+    }
+    return nok(code3);
+  }
+  function label(code3) {
+    if (code3 === 46) {
+      return effects.check(punctuation, done, dotContinuation)(code3);
+    }
+    if (code3 === 45 || code3 === 95) {
+      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code3);
+    }
+    if (asciiAlphanumeric(code3)) {
+      if (!hasDigitInLastSegment && asciiDigit(code3)) {
+        hasDigitInLastSegment = true;
+      }
+      effects.consume(code3);
+      return label;
+    }
+    return done(code3);
+  }
+  function dotContinuation(code3) {
+    effects.consume(code3);
+    hasDot = true;
+    hasDigitInLastSegment = void 0;
+    return label;
+  }
+  function dashOrUnderscoreContinuation(code3) {
+    effects.consume(code3);
+    return afterDashOrUnderscore;
+  }
+  function afterDashOrUnderscore(code3) {
+    if (code3 === 46) {
+      return effects.check(punctuation, nok, dotContinuation)(code3);
+    }
+    return label(code3);
+  }
+  function done(code3) {
+    if (hasDot && !hasDigitInLastSegment) {
+      effects.exit("literalAutolinkEmail");
+      effects.exit("literalAutolink");
+      return ok3(code3);
+    }
+    return nok(code3);
+  }
+}
+function tokenizeWwwAutolink(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    if (code3 !== 87 && code3 !== 119 || !previousWww(self2.previous) || previousUnbalanced(self2.events)) {
+      return nok(code3);
+    }
+    effects.enter("literalAutolink");
+    effects.enter("literalAutolinkWww");
+    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code3);
+  }
+  function done(code3) {
+    effects.exit("literalAutolinkWww");
+    effects.exit("literalAutolink");
+    return ok3(code3);
+  }
+}
+function tokenizeHttpAutolink(effects, ok3, nok) {
+  const self2 = this;
+  return start3;
+  function start3(code3) {
+    if (code3 !== 72 && code3 !== 104 || !previousHttp(self2.previous) || previousUnbalanced(self2.events)) {
+      return nok(code3);
+    }
+    effects.enter("literalAutolink");
+    effects.enter("literalAutolinkHttp");
+    effects.consume(code3);
+    return t1;
+  }
+  function t1(code3) {
+    if (code3 === 84 || code3 === 116) {
+      effects.consume(code3);
+      return t2;
+    }
+    return nok(code3);
+  }
+  function t2(code3) {
+    if (code3 === 84 || code3 === 116) {
+      effects.consume(code3);
+      return p;
+    }
+    return nok(code3);
+  }
+  function p(code3) {
+    if (code3 === 80 || code3 === 112) {
+      effects.consume(code3);
+      return s2;
+    }
+    return nok(code3);
+  }
+  function s2(code3) {
+    if (code3 === 83 || code3 === 115) {
+      effects.consume(code3);
+      return colon;
+    }
+    return colon(code3);
+  }
+  function colon(code3) {
+    if (code3 === 58) {
+      effects.consume(code3);
+      return slash1;
+    }
+    return nok(code3);
+  }
+  function slash1(code3) {
+    if (code3 === 47) {
+      effects.consume(code3);
+      return slash2;
+    }
+    return nok(code3);
+  }
+  function slash2(code3) {
+    if (code3 === 47) {
+      effects.consume(code3);
+      return after;
+    }
+    return nok(code3);
+  }
+  function after(code3) {
+    return code3 === null || asciiControl(code3) || unicodeWhitespace(code3) || unicodePunctuation(code3) ? nok(code3) : effects.attempt(domain, effects.attempt(path, done), nok)(code3);
+  }
+  function done(code3) {
+    effects.exit("literalAutolinkHttp");
+    effects.exit("literalAutolink");
+    return ok3(code3);
+  }
+}
+function tokenizeWww(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.consume(code3);
+    return w2;
+  }
+  function w2(code3) {
+    if (code3 === 87 || code3 === 119) {
+      effects.consume(code3);
+      return w3;
+    }
+    return nok(code3);
+  }
+  function w3(code3) {
+    if (code3 === 87 || code3 === 119) {
+      effects.consume(code3);
+      return dot;
+    }
+    return nok(code3);
+  }
+  function dot(code3) {
+    if (code3 === 46) {
+      effects.consume(code3);
+      return after;
+    }
+    return nok(code3);
+  }
+  function after(code3) {
+    return code3 === null || markdownLineEnding(code3) ? nok(code3) : ok3(code3);
+  }
+}
+function tokenizeDomain(effects, ok3, nok) {
+  let hasUnderscoreInLastSegment;
+  let hasUnderscoreInLastLastSegment;
+  return domain2;
+  function domain2(code3) {
+    if (code3 === 38) {
+      return effects.check(namedCharacterReference, done, punctuationContinuation)(code3);
+    }
+    if (code3 === 46 || code3 === 95) {
+      return effects.check(punctuation, done, punctuationContinuation)(code3);
+    }
+    if (code3 === null || asciiControl(code3) || unicodeWhitespace(code3) || code3 !== 45 && unicodePunctuation(code3)) {
+      return done(code3);
+    }
+    effects.consume(code3);
+    return domain2;
+  }
+  function punctuationContinuation(code3) {
+    if (code3 === 46) {
+      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
+      hasUnderscoreInLastSegment = void 0;
+      effects.consume(code3);
+      return domain2;
+    }
+    if (code3 === 95)
+      hasUnderscoreInLastSegment = true;
+    effects.consume(code3);
+    return domain2;
+  }
+  function done(code3) {
+    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
+      return ok3(code3);
+    }
+    return nok(code3);
+  }
+}
+function tokenizePath(effects, ok3) {
+  let balance = 0;
+  return inPath;
+  function inPath(code3) {
+    if (code3 === 38) {
+      return effects.check(namedCharacterReference, ok3, continuedPunctuation)(code3);
+    }
+    if (code3 === 40) {
+      balance++;
+    }
+    if (code3 === 41) {
+      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code3);
+    }
+    if (pathEnd(code3)) {
+      return ok3(code3);
+    }
+    if (trailingPunctuation(code3)) {
+      return effects.check(punctuation, ok3, continuedPunctuation)(code3);
+    }
+    effects.consume(code3);
+    return inPath;
+  }
+  function continuedPunctuation(code3) {
+    effects.consume(code3);
+    return inPath;
+  }
+  function parenAtPathEnd(code3) {
+    balance--;
+    return balance < 0 ? ok3(code3) : continuedPunctuation(code3);
+  }
+}
+function tokenizeNamedCharacterReference(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.consume(code3);
+    return inside;
+  }
+  function inside(code3) {
+    if (asciiAlpha(code3)) {
+      effects.consume(code3);
+      return inside;
+    }
+    if (code3 === 59) {
+      effects.consume(code3);
+      return after;
+    }
+    return nok(code3);
+  }
+  function after(code3) {
+    return pathEnd(code3) ? ok3(code3) : nok(code3);
+  }
+}
+function tokenizePunctuation(effects, ok3, nok) {
+  return start3;
+  function start3(code3) {
+    effects.consume(code3);
+    return after;
+  }
+  function after(code3) {
+    if (trailingPunctuation(code3)) {
+      effects.consume(code3);
+      return after;
+    }
+    return pathEnd(code3) ? ok3(code3) : nok(code3);
+  }
+}
+function trailingPunctuation(code3) {
+  return code3 === 33 || code3 === 34 || code3 === 39 || code3 === 41 || code3 === 42 || code3 === 44 || code3 === 46 || code3 === 58 || code3 === 59 || code3 === 60 || code3 === 63 || code3 === 95 || code3 === 126;
+}
+function pathEnd(code3) {
+  return code3 === null || code3 === 60 || markdownLineEndingOrSpace(code3);
+}
+function gfmAtext(code3) {
+  return code3 === 43 || code3 === 45 || code3 === 46 || code3 === 95 || asciiAlphanumeric(code3);
+}
+function previousWww(code3) {
+  return code3 === null || code3 === 40 || code3 === 42 || code3 === 95 || code3 === 126 || markdownLineEndingOrSpace(code3);
+}
+function previousHttp(code3) {
+  return code3 === null || !asciiAlpha(code3);
+}
+function previousEmail(code3) {
+  return code3 !== 47 && previousHttp(code3);
+}
+function previousUnbalanced(events) {
+  let index3 = events.length;
+  let result = false;
+  while (index3--) {
+    const token = events[index3][1];
+    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
+      result = true;
+      break;
+    }
+    if (token._gfmAutolinkLiteralWalkedInto) {
+      result = false;
+      break;
+    }
+  }
+  if (events.length > 0 && !result) {
+    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
+  }
+  return result;
+}
+
+// ../../node_modules/.pnpm/micromark-extension-gfm-footnote@1.0.3/node_modules/micromark-extension-gfm-footnote/lib/syntax.js
+var indent = {
+  tokenize: tokenizeIndent2,
+  partial: true
+};
+function gfmFootnote() {
+  return {
+    document: {
+      [91]: {
+        tokenize: tokenizeDefinitionStart,
+        continuation: {
+          tokenize: tokenizeDefinitionContinuation
+        },
+        exit: gfmFootnoteDefinitionEnd
+      }
+    },
+    text: {
+      [91]: {
+        tokenize: tokenizeGfmFootnoteCall
+      },
+      [93]: {
+        add: "after",
+        tokenize: tokenizePotentialGfmFootnoteCall,
+        resolveTo: resolveToPotentialGfmFootnoteCall
+      }
+    }
+  };
+}
+function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
+  const self2 = this;
+  let index3 = self2.events.length;
+  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
+  let labelStart;
+  while (index3--) {
+    const token = self2.events[index3][1];
+    if (token.type === "labelImage") {
+      labelStart = token;
+      break;
+    }
+    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
+      break;
+    }
+  }
+  return start3;
+  function start3(code3) {
+    if (!labelStart || !labelStart._balanced) {
+      return nok(code3);
+    }
+    const id = normalizeIdentifier(self2.sliceSerialize({
+      start: labelStart.end,
+      end: self2.now()
+    }));
+    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {
+      return nok(code3);
+    }
+    effects.enter("gfmFootnoteCallLabelMarker");
+    effects.consume(code3);
+    effects.exit("gfmFootnoteCallLabelMarker");
+    return ok3(code3);
+  }
+}
+function resolveToPotentialGfmFootnoteCall(events, context) {
+  let index3 = events.length;
+  let labelStart;
+  while (index3--) {
+    if (events[index3][1].type === "labelImage" && events[index3][0] === "enter") {
+      labelStart = events[index3][1];
+      break;
+    }
+  }
+  events[index3 + 1][1].type = "data";
+  events[index3 + 3][1].type = "gfmFootnoteCallLabelMarker";
+  const call = {
+    type: "gfmFootnoteCall",
+    start: Object.assign({}, events[index3 + 3][1].start),
+    end: Object.assign({}, events[events.length - 1][1].end)
+  };
+  const marker = {
+    type: "gfmFootnoteCallMarker",
+    start: Object.assign({}, events[index3 + 3][1].end),
+    end: Object.assign({}, events[index3 + 3][1].end)
+  };
+  marker.end.column++;
+  marker.end.offset++;
+  marker.end._bufferIndex++;
+  const string3 = {
+    type: "gfmFootnoteCallString",
+    start: Object.assign({}, marker.end),
+    end: Object.assign({}, events[events.length - 1][1].start)
+  };
+  const chunk = {
+    type: "chunkString",
+    contentType: "string",
+    start: Object.assign({}, string3.start),
+    end: Object.assign({}, string3.end)
+  };
+  const replacement = [
+    events[index3 + 1],
+    events[index3 + 2],
+    ["enter", call, context],
+    events[index3 + 3],
+    events[index3 + 4],
+    ["enter", marker, context],
+    ["exit", marker, context],
+    ["enter", string3, context],
+    ["enter", chunk, context],
+    ["exit", chunk, context],
+    ["exit", string3, context],
+    events[events.length - 2],
+    events[events.length - 1],
+    ["exit", call, context]
+  ];
+  events.splice(index3, events.length - index3 + 1, ...replacement);
+  return events;
+}
+function tokenizeGfmFootnoteCall(effects, ok3, nok) {
+  const self2 = this;
+  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
+  let size = 0;
+  let data2;
+  return start3;
+  function start3(code3) {
+    effects.enter("gfmFootnoteCall");
+    effects.enter("gfmFootnoteCallLabelMarker");
+    effects.consume(code3);
+    effects.exit("gfmFootnoteCallLabelMarker");
+    return callStart;
+  }
+  function callStart(code3) {
+    if (code3 !== 94)
+      return nok(code3);
+    effects.enter("gfmFootnoteCallMarker");
+    effects.consume(code3);
+    effects.exit("gfmFootnoteCallMarker");
+    effects.enter("gfmFootnoteCallString");
+    effects.enter("chunkString").contentType = "string";
+    return callData;
+  }
+  function callData(code3) {
+    let token;
+    if (code3 === null || code3 === 91 || size++ > 999) {
+      return nok(code3);
+    }
+    if (code3 === 93) {
+      if (!data2) {
+        return nok(code3);
+      }
+      effects.exit("chunkString");
+      token = effects.exit("gfmFootnoteCallString");
+      return defined.includes(normalizeIdentifier(self2.sliceSerialize(token))) ? end(code3) : nok(code3);
+    }
+    effects.consume(code3);
+    if (!markdownLineEndingOrSpace(code3)) {
+      data2 = true;
+    }
+    return code3 === 92 ? callEscape : callData;
+  }
+  function callEscape(code3) {
+    if (code3 === 91 || code3 === 92 || code3 === 93) {
+      effects.consume(code3);
+      size++;
+      return callData;
+    }
+    return callData(code3);
+  }
+  function end(code3) {
+    effects.enter("gfmFootnoteCallLabelMarker");
+    effects.consume(code3);
+    effects.exit("gfmFootnoteCallLabelMarker");
+    effects.exit("gfmFootnoteCall");
+    return ok3;
+  }
+}
+function tokenizeDefinitionStart(effects, ok3, nok) {
+  const self2 = this;
+  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
+  let identifier;
+  let size = 0;
+  let data2;
+  return start3;
+  function start3(code3) {
+    effects.enter("gfmFootnoteDefinition")._container = true;
+    effects.enter("gfmFootnoteDefinitionLabel");
+    effects.enter("gfmFootnoteDefinitionLabelMarker");
+    effects.consume(code3);
+    effects.exit("gfmFootnoteDefinitionLabelMarker");
+    return labelStart;
+  }
+  function labelStart(code3) {
+    if (code3 === 94) {
+      effects.enter("gfmFootnoteDefinitionMarker");
+      effects.consume(code3);
+      effects.exit("gfmFootnoteDefinitionMarker");
+      effects.enter("gfmFootnoteDefinitionLabelString");
+      return atBreak;
+    }
+    return nok(code3);
+  }
+  function atBreak(code3) {
+    let token;
+    if (code3 === null || code3 === 91 || size > 999) {
+      return nok(code3);
+    }
+    if (code3 === 93) {
+      if (!data2) {
+        return nok(code3);
+      }
+      token = effects.exit("gfmFootnoteDefinitionLabelString");
+      identifier = normalizeIdentifier(self2.sliceSerialize(token));
+      effects.enter("gfmFootnoteDefinitionLabelMarker");
+      effects.consume(code3);
+      effects.exit("gfmFootnoteDefinitionLabelMarker");
+      effects.exit("gfmFootnoteDefinitionLabel");
+      return labelAfter;
+    }
+    if (markdownLineEnding(code3)) {
+      effects.enter("lineEnding");
+      effects.consume(code3);
+      effects.exit("lineEnding");
+      size++;
+      return atBreak;
+    }
+    effects.enter("chunkString").contentType = "string";
+    return label(code3);
+  }
+  function label(code3) {
+    if (code3 === null || markdownLineEnding(code3) || code3 === 91 || code3 === 93 || size > 999) {
+      effects.exit("chunkString");
+      return atBreak(code3);
+    }
+    if (!markdownLineEndingOrSpace(code3)) {
+      data2 = true;
+    }
+    size++;
+    effects.consume(code3);
+    return code3 === 92 ? labelEscape : label;
+  }
+  function labelEscape(code3) {
+    if (code3 === 91 || code3 === 92 || code3 === 93) {
+      effects.consume(code3);
+      size++;
+      return label;
+    }
+    return label(code3);
+  }
+  function labelAfter(code3) {
+    if (code3 === 58) {
+      effects.enter("definitionMarker");
+      effects.consume(code3);
+      effects.exit("definitionMarker");
+      return factorySpace(effects, done, "gfmFootnoteDefinitionWhitespace");
+    }
+    return nok(code3);
+  }
+  function done(code3) {
+    if (!defined.includes(identifier)) {
+      defined.push(identifier);
+    }
+    return ok3(code3);
+  }
+}
+function tokenizeDefinitionContinuation(effects, ok3, nok) {
+  return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
+}
+function gfmFootnoteDefinitionEnd(effects) {
+  effects.exit("gfmFootnoteDefinition");
+}
+function tokenizeIndent2(effects, ok3, nok) {
+  const self2 = this;
+  return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
+  function afterPrefix(code3) {
+    const tail = self2.events[self2.events.length - 1];
+    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok3(code3) : nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.4/node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
+function gfmStrikethrough(options = {}) {
+  let single = options.singleTilde;
+  const tokenizer3 = {
+    tokenize: tokenizeStrikethrough,
+    resolveAll: resolveAllStrikethrough
+  };
+  if (single === null || single === void 0) {
+    single = true;
+  }
+  return {
+    text: {
+      [126]: tokenizer3
+    },
+    insideSpan: {
+      null: [tokenizer3]
+    },
+    attentionMarkers: {
+      null: [126]
+    }
+  };
+  function resolveAllStrikethrough(events, context) {
+    let index3 = -1;
+    while (++index3 < events.length) {
+      if (events[index3][0] === "enter" && events[index3][1].type === "strikethroughSequenceTemporary" && events[index3][1]._close) {
+        let open = index3;
+        while (open--) {
+          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index3][1].end.offset - events[index3][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
+            events[index3][1].type = "strikethroughSequence";
+            events[open][1].type = "strikethroughSequence";
+            const strikethrough2 = {
+              type: "strikethrough",
+              start: Object.assign({}, events[open][1].start),
+              end: Object.assign({}, events[index3][1].end)
+            };
+            const text7 = {
+              type: "strikethroughText",
+              start: Object.assign({}, events[open][1].end),
+              end: Object.assign({}, events[index3][1].start)
+            };
+            const nextEvents = [
+              ["enter", strikethrough2, context],
+              ["enter", events[open][1], context],
+              ["exit", events[open][1], context],
+              ["enter", text7, context]
+            ];
+            splice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index3), context));
+            splice(nextEvents, nextEvents.length, 0, [
+              ["exit", text7, context],
+              ["enter", events[index3][1], context],
+              ["exit", events[index3][1], context],
+              ["exit", strikethrough2, context]
+            ]);
+            splice(events, open - 1, index3 - open + 3, nextEvents);
+            index3 = open + nextEvents.length - 2;
+            break;
+          }
+        }
+      }
+    }
+    index3 = -1;
+    while (++index3 < events.length) {
+      if (events[index3][1].type === "strikethroughSequenceTemporary") {
+        events[index3][1].type = "data";
+      }
+    }
+    return events;
+  }
+  function tokenizeStrikethrough(effects, ok3, nok) {
+    const previous3 = this.previous;
+    const events = this.events;
+    let size = 0;
+    return start3;
+    function start3(code3) {
+      if (previous3 === 126 && events[events.length - 1][1].type !== "characterEscape") {
+        return nok(code3);
+      }
+      effects.enter("strikethroughSequenceTemporary");
+      return more(code3);
+    }
+    function more(code3) {
+      const before = classifyCharacter(previous3);
+      if (code3 === 126) {
+        if (size > 1)
+          return nok(code3);
+        effects.consume(code3);
+        size++;
+        return more;
+      }
+      if (size < 2 && !single)
+        return nok(code3);
+      const token = effects.exit("strikethroughSequenceTemporary");
+      const after = classifyCharacter(code3);
+      token._open = !after || after === 2 && Boolean(before);
+      token._close = !before || before === 2 && Boolean(after);
+      return ok3(code3);
+    }
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.5/node_modules/micromark-extension-gfm-table/lib/syntax.js
+var gfmTable = {
+  flow: {
+    null: {
+      tokenize: tokenizeTable,
+      resolve: resolveTable
+    }
+  }
+};
+var nextPrefixedOrBlank = {
+  tokenize: tokenizeNextPrefixedOrBlank,
+  partial: true
+};
+function resolveTable(events, context) {
+  let index3 = -1;
+  let inHead;
+  let inDelimiterRow;
+  let inRow;
+  let contentStart;
+  let contentEnd;
+  let cellStart;
+  let seenCellInRow;
+  while (++index3 < events.length) {
+    const token = events[index3][1];
+    if (inRow) {
+      if (token.type === "temporaryTableCellContent") {
+        contentStart = contentStart || index3;
+        contentEnd = index3;
+      }
+      if ((token.type === "tableCellDivider" || token.type === "tableRow") && contentEnd) {
+        const content3 = {
+          type: "tableContent",
+          start: events[contentStart][1].start,
+          end: events[contentEnd][1].end
+        };
+        const text7 = {
+          type: "chunkText",
+          start: content3.start,
+          end: content3.end,
+          contentType: "text"
+        };
+        events.splice(contentStart, contentEnd - contentStart + 1, ["enter", content3, context], ["enter", text7, context], ["exit", text7, context], ["exit", content3, context]);
+        index3 -= contentEnd - contentStart - 3;
+        contentStart = void 0;
+        contentEnd = void 0;
+      }
+    }
+    if (events[index3][0] === "exit" && cellStart !== void 0 && cellStart + (seenCellInRow ? 0 : 1) < index3 && (token.type === "tableCellDivider" || token.type === "tableRow" && (cellStart + 3 < index3 || events[cellStart][1].type !== "whitespace"))) {
+      const cell = {
+        type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
+        start: events[cellStart][1].start,
+        end: events[index3][1].end
+      };
+      events.splice(index3 + (token.type === "tableCellDivider" ? 1 : 0), 0, [
+        "exit",
+        cell,
+        context
+      ]);
+      events.splice(cellStart, 0, ["enter", cell, context]);
+      index3 += 2;
+      cellStart = index3 + 1;
+      seenCellInRow = true;
+    }
+    if (token.type === "tableRow") {
+      inRow = events[index3][0] === "enter";
+      if (inRow) {
+        cellStart = index3 + 1;
+        seenCellInRow = false;
+      }
+    }
+    if (token.type === "tableDelimiterRow") {
+      inDelimiterRow = events[index3][0] === "enter";
+      if (inDelimiterRow) {
+        cellStart = index3 + 1;
+        seenCellInRow = false;
+      }
+    }
+    if (token.type === "tableHead") {
+      inHead = events[index3][0] === "enter";
+    }
+  }
+  return events;
+}
+function tokenizeTable(effects, ok3, nok) {
+  const self2 = this;
+  const align = [];
+  let tableHeaderCount = 0;
+  let seenDelimiter;
+  let hasDash;
+  return start3;
+  function start3(code3) {
+    effects.enter("table")._align = align;
+    effects.enter("tableHead");
+    effects.enter("tableRow");
+    if (code3 === 124) {
+      return cellDividerHead(code3);
+    }
+    tableHeaderCount++;
+    effects.enter("temporaryTableCellContent");
+    return inCellContentHead(code3);
+  }
+  function cellDividerHead(code3) {
+    effects.enter("tableCellDivider");
+    effects.consume(code3);
+    effects.exit("tableCellDivider");
+    seenDelimiter = true;
+    return cellBreakHead;
+  }
+  function cellBreakHead(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      return atRowEndHead(code3);
+    }
+    if (markdownSpace(code3)) {
+      effects.enter("whitespace");
+      effects.consume(code3);
+      return inWhitespaceHead;
+    }
+    if (seenDelimiter) {
+      seenDelimiter = void 0;
+      tableHeaderCount++;
+    }
+    if (code3 === 124) {
+      return cellDividerHead(code3);
+    }
+    effects.enter("temporaryTableCellContent");
+    return inCellContentHead(code3);
+  }
+  function inWhitespaceHead(code3) {
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return inWhitespaceHead;
+    }
+    effects.exit("whitespace");
+    return cellBreakHead(code3);
+  }
+  function inCellContentHead(code3) {
+    if (code3 === null || code3 === 124 || markdownLineEndingOrSpace(code3)) {
+      effects.exit("temporaryTableCellContent");
+      return cellBreakHead(code3);
+    }
+    effects.consume(code3);
+    return code3 === 92 ? inCellContentEscapeHead : inCellContentHead;
+  }
+  function inCellContentEscapeHead(code3) {
+    if (code3 === 92 || code3 === 124) {
+      effects.consume(code3);
+      return inCellContentHead;
+    }
+    return inCellContentHead(code3);
+  }
+  function atRowEndHead(code3) {
+    if (code3 === null) {
+      return nok(code3);
+    }
+    effects.exit("tableRow");
+    effects.exit("tableHead");
+    const originalInterrupt = self2.interrupt;
+    self2.interrupt = true;
+    return effects.attempt({
+      tokenize: tokenizeRowEnd,
+      partial: true
+    }, function(code4) {
+      self2.interrupt = originalInterrupt;
+      effects.enter("tableDelimiterRow");
+      return atDelimiterRowBreak(code4);
+    }, function(code4) {
+      self2.interrupt = originalInterrupt;
+      return nok(code4);
+    })(code3);
+  }
+  function atDelimiterRowBreak(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      return rowEndDelimiter(code3);
+    }
+    if (markdownSpace(code3)) {
+      effects.enter("whitespace");
+      effects.consume(code3);
+      return inWhitespaceDelimiter;
+    }
+    if (code3 === 45) {
+      effects.enter("tableDelimiterFiller");
+      effects.consume(code3);
+      hasDash = true;
+      align.push("none");
+      return inFillerDelimiter;
+    }
+    if (code3 === 58) {
+      effects.enter("tableDelimiterAlignment");
+      effects.consume(code3);
+      effects.exit("tableDelimiterAlignment");
+      align.push("left");
+      return afterLeftAlignment;
+    }
+    if (code3 === 124) {
+      effects.enter("tableCellDivider");
+      effects.consume(code3);
+      effects.exit("tableCellDivider");
+      return atDelimiterRowBreak;
+    }
+    return nok(code3);
+  }
+  function inWhitespaceDelimiter(code3) {
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return inWhitespaceDelimiter;
+    }
+    effects.exit("whitespace");
+    return atDelimiterRowBreak(code3);
+  }
+  function inFillerDelimiter(code3) {
+    if (code3 === 45) {
+      effects.consume(code3);
+      return inFillerDelimiter;
+    }
+    effects.exit("tableDelimiterFiller");
+    if (code3 === 58) {
+      effects.enter("tableDelimiterAlignment");
+      effects.consume(code3);
+      effects.exit("tableDelimiterAlignment");
+      align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
+      return afterRightAlignment;
+    }
+    return atDelimiterRowBreak(code3);
+  }
+  function afterLeftAlignment(code3) {
+    if (code3 === 45) {
+      effects.enter("tableDelimiterFiller");
+      effects.consume(code3);
+      hasDash = true;
+      return inFillerDelimiter;
+    }
+    return nok(code3);
+  }
+  function afterRightAlignment(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      return rowEndDelimiter(code3);
+    }
+    if (markdownSpace(code3)) {
+      effects.enter("whitespace");
+      effects.consume(code3);
+      return inWhitespaceDelimiter;
+    }
+    if (code3 === 124) {
+      effects.enter("tableCellDivider");
+      effects.consume(code3);
+      effects.exit("tableCellDivider");
+      return atDelimiterRowBreak;
+    }
+    return nok(code3);
+  }
+  function rowEndDelimiter(code3) {
+    effects.exit("tableDelimiterRow");
+    if (!hasDash || tableHeaderCount !== align.length) {
+      return nok(code3);
+    }
+    if (code3 === null) {
+      return tableClose(code3);
+    }
+    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({
+      tokenize: tokenizeRowEnd,
+      partial: true
+    }, factorySpace(effects, bodyStart, "linePrefix", 4), tableClose))(code3);
+  }
+  function tableClose(code3) {
+    effects.exit("table");
+    return ok3(code3);
+  }
+  function bodyStart(code3) {
+    effects.enter("tableBody");
+    return rowStartBody(code3);
+  }
+  function rowStartBody(code3) {
+    effects.enter("tableRow");
+    if (code3 === 124) {
+      return cellDividerBody(code3);
+    }
+    effects.enter("temporaryTableCellContent");
+    return inCellContentBody(code3);
+  }
+  function cellDividerBody(code3) {
+    effects.enter("tableCellDivider");
+    effects.consume(code3);
+    effects.exit("tableCellDivider");
+    return cellBreakBody;
+  }
+  function cellBreakBody(code3) {
+    if (code3 === null || markdownLineEnding(code3)) {
+      return atRowEndBody(code3);
+    }
+    if (markdownSpace(code3)) {
+      effects.enter("whitespace");
+      effects.consume(code3);
+      return inWhitespaceBody;
+    }
+    if (code3 === 124) {
+      return cellDividerBody(code3);
+    }
+    effects.enter("temporaryTableCellContent");
+    return inCellContentBody(code3);
+  }
+  function inWhitespaceBody(code3) {
+    if (markdownSpace(code3)) {
+      effects.consume(code3);
+      return inWhitespaceBody;
+    }
+    effects.exit("whitespace");
+    return cellBreakBody(code3);
+  }
+  function inCellContentBody(code3) {
+    if (code3 === null || code3 === 124 || markdownLineEndingOrSpace(code3)) {
+      effects.exit("temporaryTableCellContent");
+      return cellBreakBody(code3);
+    }
+    effects.consume(code3);
+    return code3 === 92 ? inCellContentEscapeBody : inCellContentBody;
+  }
+  function inCellContentEscapeBody(code3) {
+    if (code3 === 92 || code3 === 124) {
+      effects.consume(code3);
+      return inCellContentBody;
+    }
+    return inCellContentBody(code3);
+  }
+  function atRowEndBody(code3) {
+    effects.exit("tableRow");
+    if (code3 === null) {
+      return tableBodyClose(code3);
+    }
+    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({
+      tokenize: tokenizeRowEnd,
+      partial: true
+    }, factorySpace(effects, rowStartBody, "linePrefix", 4), tableBodyClose))(code3);
+  }
+  function tableBodyClose(code3) {
+    effects.exit("tableBody");
+    return tableClose(code3);
+  }
+  function tokenizeRowEnd(effects2, ok4, nok2) {
+    return start4;
+    function start4(code3) {
+      effects2.enter("lineEnding");
+      effects2.consume(code3);
+      effects2.exit("lineEnding");
+      return factorySpace(effects2, prefixed, "linePrefix");
+    }
+    function prefixed(code3) {
+      if (self2.parser.lazy[self2.now().line] || code3 === null || markdownLineEnding(code3)) {
+        return nok2(code3);
+      }
+      const tail = self2.events[self2.events.length - 1];
+      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
+        return nok2(code3);
+      }
+      self2._gfmTableDynamicInterruptHack = true;
+      return effects2.check(self2.parser.constructs.flow, function(code4) {
+        self2._gfmTableDynamicInterruptHack = false;
+        return nok2(code4);
+      }, function(code4) {
+        self2._gfmTableDynamicInterruptHack = false;
+        return ok4(code4);
+      })(code3);
+    }
+  }
+}
+function tokenizeNextPrefixedOrBlank(effects, ok3, nok) {
+  let size = 0;
+  return start3;
+  function start3(code3) {
+    effects.enter("check");
+    effects.consume(code3);
+    return whitespace2;
+  }
+  function whitespace2(code3) {
+    if (code3 === -1 || code3 === 32) {
+      effects.consume(code3);
+      size++;
+      return size === 4 ? ok3 : whitespace2;
+    }
+    if (code3 === null || markdownLineEndingOrSpace(code3)) {
+      return ok3(code3);
+    }
+    return nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.3/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
+var tasklistCheck = {
+  tokenize: tokenizeTasklistCheck
+};
+var gfmTaskListItem = {
+  text: {
+    [91]: tasklistCheck
+  }
+};
+function tokenizeTasklistCheck(effects, ok3, nok) {
+  const self2 = this;
+  return open;
+  function open(code3) {
+    if (self2.previous !== null || !self2._gfmTasklistFirstContentOfListItem) {
+      return nok(code3);
+    }
+    effects.enter("taskListCheck");
+    effects.enter("taskListCheckMarker");
+    effects.consume(code3);
+    effects.exit("taskListCheckMarker");
+    return inside;
+  }
+  function inside(code3) {
+    if (markdownLineEndingOrSpace(code3)) {
+      effects.enter("taskListCheckValueUnchecked");
+      effects.consume(code3);
+      effects.exit("taskListCheckValueUnchecked");
+      return close;
+    }
+    if (code3 === 88 || code3 === 120) {
+      effects.enter("taskListCheckValueChecked");
+      effects.consume(code3);
+      effects.exit("taskListCheckValueChecked");
+      return close;
+    }
+    return nok(code3);
+  }
+  function close(code3) {
+    if (code3 === 93) {
+      effects.enter("taskListCheckMarker");
+      effects.consume(code3);
+      effects.exit("taskListCheckMarker");
+      effects.exit("taskListCheck");
+      return effects.check({
+        tokenize: spaceThenNonSpace
+      }, ok3, nok);
+    }
+    return nok(code3);
+  }
+}
+function spaceThenNonSpace(effects, ok3, nok) {
+  const self2 = this;
+  return factorySpace(effects, after, "whitespace");
+  function after(code3) {
+    const tail = self2.events[self2.events.length - 1];
+    return (tail && tail[1].type === "whitespace" || markdownLineEnding(code3)) && code3 !== null ? ok3(code3) : nok(code3);
+  }
+}
+
+// ../../node_modules/.pnpm/micromark-extension-gfm@2.0.1/node_modules/micromark-extension-gfm/index.js
+function gfm(options) {
+  return combineExtensions([
+    gfmAutolinkLiteral,
+    gfmFootnote(),
+    gfmStrikethrough(options),
+    gfmTable,
+    gfmTaskListItem
+  ]);
+}
+
+// ../../node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js
+function escapeStringRegexp(string3) {
+  if (typeof string3 !== "string") {
+    throw new TypeError("Expected a string");
+  }
+  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
+}
+
+// ../../node_modules/.pnpm/mdast-util-find-and-replace@2.1.0/node_modules/mdast-util-find-and-replace/index.js
+var own14 = {}.hasOwnProperty;
+var findAndReplace = function(tree, find3, replace2, options) {
+  let settings;
+  let schema;
+  if (typeof find3 === "string" || find3 instanceof RegExp) {
+    schema = [[find3, replace2]];
+    settings = options;
+  } else {
+    schema = find3;
+    settings = replace2;
+  }
+  if (!settings) {
+    settings = {};
+  }
+  const ignored = convert(settings.ignore || []);
+  const pairs = toPairs(schema);
+  let pairIndex = -1;
+  while (++pairIndex < pairs.length) {
+    visitParents2(tree, "text", visitor);
+  }
+  return tree;
+  function visitor(node, parents) {
+    let index3 = -1;
+    let grandparent;
+    while (++index3 < parents.length) {
+      const parent = parents[index3];
+      if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : void 0, grandparent)) {
+        return;
+      }
+      grandparent = parent;
+    }
+    if (grandparent) {
+      return handler(node, grandparent);
+    }
+  }
+  function handler(node, parent) {
+    const find4 = pairs[pairIndex][0];
+    const replace3 = pairs[pairIndex][1];
+    let start3 = 0;
+    let index3 = parent.children.indexOf(node);
+    let nodes2 = [];
+    let position4;
+    find4.lastIndex = 0;
+    let match = find4.exec(node.value);
+    while (match) {
+      position4 = match.index;
+      let value = replace3(...match, {
+        index: match.index,
+        input: match.input
+      });
+      if (typeof value === "string") {
+        value = value.length > 0 ? { type: "text", value } : void 0;
+      }
+      if (value !== false) {
+        if (start3 !== position4) {
+          nodes2.push({
+            type: "text",
+            value: node.value.slice(start3, position4)
+          });
+        }
+        if (Array.isArray(value)) {
+          nodes2.push(...value);
+        } else if (value) {
+          nodes2.push(value);
+        }
+        start3 = position4 + match[0].length;
+      }
+      if (!find4.global) {
+        break;
+      }
+      match = find4.exec(node.value);
+    }
+    if (position4 === void 0) {
+      nodes2 = [node];
+      index3--;
+    } else {
+      if (start3 < node.value.length) {
+        nodes2.push({ type: "text", value: node.value.slice(start3) });
+      }
+      parent.children.splice(index3, 1, ...nodes2);
+    }
+    return index3 + nodes2.length + 1;
+  }
+};
+function toPairs(schema) {
+  const result = [];
+  if (typeof schema !== "object") {
+    throw new TypeError("Expected array or object as schema");
+  }
+  if (Array.isArray(schema)) {
+    let index3 = -1;
+    while (++index3 < schema.length) {
+      result.push([
+        toExpression(schema[index3][0]),
+        toFunction(schema[index3][1])
+      ]);
+    }
+  } else {
+    let key;
+    for (key in schema) {
+      if (own14.call(schema, key)) {
+        result.push([toExpression(key), toFunction(schema[key])]);
+      }
+    }
+  }
+  return result;
+}
+function toExpression(find3) {
+  return typeof find3 === "string" ? new RegExp(escapeStringRegexp(find3), "g") : find3;
+}
+function toFunction(replace2) {
+  return typeof replace2 === "function" ? replace2 : () => replace2;
+}
+
+// ../../node_modules/.pnpm/mdast-util-gfm-autolink-literal@1.0.2/node_modules/mdast-util-gfm-autolink-literal/index.js
+var inConstruct = "phrasing";
+var notInConstruct = ["autolink", "link", "image", "label"];
+var gfmAutolinkLiteralFromMarkdown = {
+  transforms: [transformGfmAutolinkLiterals],
+  enter: {
+    literalAutolink: enterLiteralAutolink,
+    literalAutolinkEmail: enterLiteralAutolinkValue,
+    literalAutolinkHttp: enterLiteralAutolinkValue,
+    literalAutolinkWww: enterLiteralAutolinkValue
+  },
+  exit: {
+    literalAutolink: exitLiteralAutolink,
+    literalAutolinkEmail: exitLiteralAutolinkEmail,
+    literalAutolinkHttp: exitLiteralAutolinkHttp,
+    literalAutolinkWww: exitLiteralAutolinkWww
+  }
+};
+var gfmAutolinkLiteralToMarkdown = {
+  unsafe: [
+    {
+      character: "@",
+      before: "[+\\-.\\w]",
+      after: "[\\-.\\w]",
+      inConstruct,
+      notInConstruct
+    },
+    {
+      character: ".",
+      before: "[Ww]",
+      after: "[\\-.\\w]",
+      inConstruct,
+      notInConstruct
+    },
+    { character: ":", before: "[ps]", after: "\\/", inConstruct, notInConstruct }
+  ]
+};
+function enterLiteralAutolink(token) {
+  this.enter({ type: "link", title: null, url: "", children: [] }, token);
+}
+function enterLiteralAutolinkValue(token) {
+  this.config.enter.autolinkProtocol.call(this, token);
+}
+function exitLiteralAutolinkHttp(token) {
+  this.config.exit.autolinkProtocol.call(this, token);
+}
+function exitLiteralAutolinkWww(token) {
+  this.config.exit.data.call(this, token);
+  const node = this.stack[this.stack.length - 1];
+  node.url = "http://" + this.sliceSerialize(token);
+}
+function exitLiteralAutolinkEmail(token) {
+  this.config.exit.autolinkEmail.call(this, token);
+}
+function exitLiteralAutolink(token) {
+  this.exit(token);
+}
+function transformGfmAutolinkLiterals(tree) {
+  findAndReplace(tree, [
+    [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
+    [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
+  ], { ignore: ["link", "linkReference"] });
+}
+function findUrl(_, protocol, domain2, path3, match) {
+  let prefix = "";
+  if (!previous2(match)) {
+    return false;
+  }
+  if (/^w/i.test(protocol)) {
+    domain2 = protocol + domain2;
+    protocol = "";
+    prefix = "http://";
+  }
+  if (!isCorrectDomain(domain2)) {
+    return false;
+  }
+  const parts = splitUrl(domain2 + path3);
+  if (!parts[0])
+    return false;
+  const result = {
+    type: "link",
+    title: null,
+    url: prefix + protocol + parts[0],
+    children: [{ type: "text", value: protocol + parts[0] }]
+  };
+  if (parts[1]) {
+    return [result, { type: "text", value: parts[1] }];
+  }
+  return result;
+}
+function findEmail(_, atext, label, match) {
+  if (!previous2(match, true) || /[_-\d]$/.test(label)) {
+    return false;
+  }
+  return {
+    type: "link",
+    title: null,
+    url: "mailto:" + atext + "@" + label,
+    children: [{ type: "text", value: atext + "@" + label }]
+  };
+}
+function isCorrectDomain(domain2) {
+  const parts = domain2.split(".");
+  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
+    return false;
+  }
+  return true;
+}
+function splitUrl(url) {
+  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
+  let closingParenIndex;
+  let openingParens;
+  let closingParens;
+  let trail;
+  if (trailExec) {
+    url = url.slice(0, trailExec.index);
+    trail = trailExec[0];
+    closingParenIndex = trail.indexOf(")");
+    openingParens = ccount(url, "(");
+    closingParens = ccount(url, ")");
+    while (closingParenIndex !== -1 && openingParens > closingParens) {
+      url += trail.slice(0, closingParenIndex + 1);
+      trail = trail.slice(closingParenIndex + 1);
+      closingParenIndex = trail.indexOf(")");
+      closingParens++;
+    }
+  }
+  return [url, trail];
+}
+function previous2(match, email) {
+  const code3 = match.input.charCodeAt(match.index - 1);
+  return (match.index === 0 || unicodeWhitespace(code3) || unicodePunctuation(code3)) && (!email || code3 !== 47);
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/association.js
+function association(node) {
+  if (node.label || !node.identifier) {
+    return node.label || "";
+  }
+  return decodeString(node.identifier);
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
+function containerFlow2(parent, context) {
+  const indexStack = context.indexStack;
+  const children = parent.children || [];
+  const results = [];
+  let index3 = -1;
+  indexStack.push(-1);
+  while (++index3 < children.length) {
+    const child = children[index3];
+    indexStack[indexStack.length - 1] = index3;
+    results.push(context.handle(child, parent, context, { before: "\n", after: "\n" }));
+    if (child.type !== "list") {
+      context.bulletLastUsed = void 0;
+    }
+    if (index3 < children.length - 1) {
+      results.push(between(child, children[index3 + 1]));
+    }
+  }
+  indexStack.pop();
+  return results.join("");
+  function between(left, right) {
+    let index4 = context.join.length;
+    while (index4--) {
+      const result = context.join[index4](left, right, parent, context);
+      if (result === true || result === 1) {
+        break;
+      }
+      if (typeof result === "number") {
+        return "\n".repeat(1 + result);
+      }
+      if (result === false) {
+        return "\n\n<!---->\n\n";
+      }
+    }
+    return "\n\n";
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
+var eol2 = /\r?\n|\r/g;
+function indentLines2(value, map2) {
+  const result = [];
+  let start3 = 0;
+  let line = 0;
+  let match;
+  while (match = eol2.exec(value)) {
+    one3(value.slice(start3, match.index));
+    result.push(match[0]);
+    start3 = match.index + match[0].length;
+    line++;
+  }
+  one3(value.slice(start3));
+  return result.join("");
+  function one3(value2) {
+    result.push(map2(value2, line, !value2));
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
+function patternCompile(pattern) {
+  if (!pattern._compiled) {
+    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
+    pattern._compiled = new RegExp((before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""), "g");
+  }
+  return pattern._compiled;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
+function patternInScope(stack, pattern) {
+  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
+}
+function listInScope(stack, list3, none) {
+  if (!list3) {
+    return none;
+  }
+  if (typeof list3 === "string") {
+    list3 = [list3];
+  }
+  let index3 = -1;
+  while (++index3 < list3.length) {
+    if (stack.includes(list3[index3])) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/safe.js
+function safe(context, input, config) {
+  const value = (config.before || "") + (input || "") + (config.after || "");
+  const positions = [];
+  const result = [];
+  const infos = {};
+  let index3 = -1;
+  while (++index3 < context.unsafe.length) {
+    const pattern = context.unsafe[index3];
+    if (!patternInScope(context.stack, pattern)) {
+      continue;
+    }
+    const expression = patternCompile(pattern);
+    let match;
+    while (match = expression.exec(value)) {
+      const before = "before" in pattern || Boolean(pattern.atBreak);
+      const after = "after" in pattern;
+      const position4 = match.index + (before ? match[1].length : 0);
+      if (positions.includes(position4)) {
+        if (infos[position4].before && !before) {
+          infos[position4].before = false;
+        }
+        if (infos[position4].after && !after) {
+          infos[position4].after = false;
+        }
+      } else {
+        positions.push(position4);
+        infos[position4] = { before, after };
+      }
+    }
+  }
+  positions.sort(numerical);
+  let start3 = config.before ? config.before.length : 0;
+  const end = value.length - (config.after ? config.after.length : 0);
+  index3 = -1;
+  while (++index3 < positions.length) {
+    const position4 = positions[index3];
+    if (position4 < start3 || position4 >= end) {
+      continue;
+    }
+    if (position4 + 1 < end && positions[index3 + 1] === position4 + 1 && infos[position4].after && !infos[position4 + 1].before && !infos[position4 + 1].after || positions[index3 - 1] === position4 - 1 && infos[position4].before && !infos[position4 - 1].before && !infos[position4 - 1].after) {
+      continue;
+    }
+    if (start3 !== position4) {
+      result.push(escapeBackslashes(value.slice(start3, position4), "\\"));
+    }
+    start3 = position4;
+    if (/[!-/:-@[-`{-~]/.test(value.charAt(position4)) && (!config.encode || !config.encode.includes(value.charAt(position4)))) {
+      result.push("\\");
+    } else {
+      result.push("&#x" + value.charCodeAt(position4).toString(16).toUpperCase() + ";");
+      start3++;
+    }
+  }
+  result.push(escapeBackslashes(value.slice(start3, end), config.after));
+  return result.join("");
+}
+function numerical(a, b) {
+  return a - b;
+}
+function escapeBackslashes(value, after) {
+  const expression = /\\(?=[!-/:-@[-`{-~])/g;
+  const positions = [];
+  const results = [];
+  const whole = value + after;
+  let index3 = -1;
+  let start3 = 0;
+  let match;
+  while (match = expression.exec(whole)) {
+    positions.push(match.index);
+  }
+  while (++index3 < positions.length) {
+    if (start3 !== positions[index3]) {
+      results.push(value.slice(start3, positions[index3]));
+    }
+    results.push("\\");
+    start3 = positions[index3];
+  }
+  results.push(value.slice(start3));
+  return results.join("");
+}
+
+// ../../node_modules/.pnpm/mdast-util-gfm-footnote@1.0.0/node_modules/mdast-util-gfm-footnote/index.js
+var warningColonInFootnote = false;
+var warningListInFootnote = false;
+function gfmFootnoteFromMarkdown() {
+  return {
+    enter: {
+      gfmFootnoteDefinition: enterFootnoteDefinition,
+      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
+      gfmFootnoteCall: enterFootnoteCall,
+      gfmFootnoteCallString: enterFootnoteCallString
+    },
+    exit: {
+      gfmFootnoteDefinition: exitFootnoteDefinition,
+      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
+      gfmFootnoteCall: exitFootnoteCall,
+      gfmFootnoteCallString: exitFootnoteCallString
+    }
+  };
+  function enterFootnoteDefinition(token) {
+    this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, token);
+  }
+  function enterFootnoteDefinitionLabelString() {
+    this.buffer();
+  }
+  function exitFootnoteDefinitionLabelString(token) {
+    const label = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.label = label;
+    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
+  }
+  function exitFootnoteDefinition(token) {
+    this.exit(token);
+  }
+  function enterFootnoteCall(token) {
+    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
+  }
+  function enterFootnoteCallString() {
+    this.buffer();
+  }
+  function exitFootnoteCallString(token) {
+    const label = this.resume();
+    const node = this.stack[this.stack.length - 1];
+    node.label = label;
+    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
+  }
+  function exitFootnoteCall(token) {
+    this.exit(token);
+  }
+}
+function gfmFootnoteToMarkdown() {
+  footnoteReference2.peek = footnoteReferencePeek;
+  return {
+    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
+    handlers: { footnoteDefinition, footnoteReference: footnoteReference2 }
+  };
+  function footnoteReference2(node, _, context) {
+    const exit3 = context.enter("footnoteReference");
+    const subexit = context.enter("reference");
+    const reference = safe(context, association(node), {
+      before: "^",
+      after: "]"
+    });
+    subexit();
+    exit3();
+    return "[^" + reference + "]";
+  }
+  function footnoteReferencePeek() {
+    return "[";
+  }
+  function footnoteDefinition(node, _, context) {
+    const exit3 = context.enter("footnoteDefinition");
+    const subexit = context.enter("label");
+    const id = safe(context, association(node), { before: "^", after: "]" });
+    const label = "[^" + id + "]:";
+    subexit();
+    const value = indentLines2(containerFlow2(node, context), map2);
+    exit3();
+    if (!warningColonInFootnote && id.includes(":")) {
+      console.warn("[mdast-util-gfm-footnote] Warning: Found a colon in footnote identifier `" + id + "`. GitHub currently crahes on colons in footnotes (see <https://github.com/github/cmark-gfm/issues/241> for more info)");
+      warningColonInFootnote = true;
+    }
+    if (!warningListInFootnote) {
+      visit2(node, "list", () => {
+        console.warn("[mdast-util-gfm-footnote] Warning: Found a list in a footnote definition. GitHub currently crahes on lists in footnotes (see <https://github.com/github/cmark-gfm/issues/241> for more info)");
+        warningListInFootnote = true;
+        return EXIT2;
+      });
+    }
+    return value;
+    function map2(line, index3, blank) {
+      if (index3) {
+        return (blank ? "" : "    ") + line;
+      }
+      return (blank ? label : label + " ") + line;
+    }
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
+function containerPhrasing2(parent, context, safeOptions) {
+  const indexStack = context.indexStack;
+  const children = parent.children || [];
+  const results = [];
+  let index3 = -1;
+  let before = safeOptions.before;
+  indexStack.push(-1);
+  while (++index3 < children.length) {
+    const child = children[index3];
+    let after;
+    indexStack[indexStack.length - 1] = index3;
+    if (index3 + 1 < children.length) {
+      let handle = context.handle.handlers[children[index3 + 1].type];
+      if (handle && handle.peek)
+        handle = handle.peek;
+      after = handle ? handle(children[index3 + 1], parent, context, {
+        before: "",
+        after: ""
+      }).charAt(0) : "";
+    } else {
+      after = safeOptions.after;
+    }
+    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
+      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
+      before = " ";
+    }
+    results.push(context.handle(child, parent, context, { before, after }));
+    before = results[results.length - 1].slice(-1);
+  }
+  indexStack.pop();
+  return results.join("");
+}
+
+// ../../node_modules/.pnpm/mdast-util-gfm-strikethrough@1.0.0/node_modules/mdast-util-gfm-strikethrough/index.js
+var gfmStrikethroughFromMarkdown = {
+  canContainEols: ["delete"],
+  enter: { strikethrough: enterStrikethrough },
+  exit: { strikethrough: exitStrikethrough }
+};
+var gfmStrikethroughToMarkdown = {
+  unsafe: [{ character: "~", inConstruct: "phrasing" }],
+  handlers: { delete: handleDelete }
+};
+handleDelete.peek = peekDelete;
+function enterStrikethrough(token) {
+  this.enter({ type: "delete", children: [] }, token);
+}
+function exitStrikethrough(token) {
+  this.exit(token);
+}
+function handleDelete(node, _, context) {
+  const exit3 = context.enter("emphasis");
+  const value = containerPhrasing2(node, context, { before: "~", after: "~" });
+  exit3();
+  return "~~" + value + "~~";
+}
+function peekDelete() {
+  return "~";
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
+inlineCode2.peek = inlineCodePeek;
+function inlineCode2(node, _, context) {
+  let value = node.value || "";
+  let sequence = "`";
+  let index3 = -1;
+  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
+    sequence += "`";
+  }
+  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
+    value = " " + value + " ";
+  }
+  while (++index3 < context.unsafe.length) {
+    const pattern = context.unsafe[index3];
+    const expression = patternCompile(pattern);
+    let match;
+    if (!pattern.atBreak)
+      continue;
+    while (match = expression.exec(value)) {
+      let position4 = match.index;
+      if (value.charCodeAt(position4) === 10 && value.charCodeAt(position4 - 1) === 13) {
+        position4--;
+      }
+      value = value.slice(0, position4) + " " + value.slice(match.index + 1);
+    }
+  }
+  return sequence + value + sequence;
+}
+function inlineCodePeek() {
+  return "`";
+}
+
+// ../../node_modules/.pnpm/markdown-table@3.0.2/node_modules/markdown-table/index.js
+function markdownTable(table2, options = {}) {
+  const align = (options.align || []).concat();
+  const stringLength = options.stringLength || defaultStringLength;
+  const alignments = [];
+  const cellMatrix = [];
+  const sizeMatrix = [];
+  const longestCellByColumn = [];
+  let mostCellsPerRow = 0;
+  let rowIndex = -1;
+  while (++rowIndex < table2.length) {
+    const row2 = [];
+    const sizes2 = [];
+    let columnIndex2 = -1;
+    if (table2[rowIndex].length > mostCellsPerRow) {
+      mostCellsPerRow = table2[rowIndex].length;
+    }
+    while (++columnIndex2 < table2[rowIndex].length) {
+      const cell = serialize(table2[rowIndex][columnIndex2]);
+      if (options.alignDelimiters !== false) {
+        const size = stringLength(cell);
+        sizes2[columnIndex2] = size;
+        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
+          longestCellByColumn[columnIndex2] = size;
+        }
+      }
+      row2.push(cell);
+    }
+    cellMatrix[rowIndex] = row2;
+    sizeMatrix[rowIndex] = sizes2;
+  }
+  let columnIndex = -1;
+  if (typeof align === "object" && "length" in align) {
+    while (++columnIndex < mostCellsPerRow) {
+      alignments[columnIndex] = toAlignment(align[columnIndex]);
+    }
+  } else {
+    const code3 = toAlignment(align);
+    while (++columnIndex < mostCellsPerRow) {
+      alignments[columnIndex] = code3;
+    }
+  }
+  columnIndex = -1;
+  const row = [];
+  const sizes = [];
+  while (++columnIndex < mostCellsPerRow) {
+    const code3 = alignments[columnIndex];
+    let before = "";
+    let after = "";
+    if (code3 === 99) {
+      before = ":";
+      after = ":";
+    } else if (code3 === 108) {
+      before = ":";
+    } else if (code3 === 114) {
+      after = ":";
+    }
+    let size = options.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);
+    const cell = before + "-".repeat(size) + after;
+    if (options.alignDelimiters !== false) {
+      size = before.length + size + after.length;
+      if (size > longestCellByColumn[columnIndex]) {
+        longestCellByColumn[columnIndex] = size;
+      }
+      sizes[columnIndex] = size;
+    }
+    row[columnIndex] = cell;
+  }
+  cellMatrix.splice(1, 0, row);
+  sizeMatrix.splice(1, 0, sizes);
+  rowIndex = -1;
+  const lines = [];
+  while (++rowIndex < cellMatrix.length) {
+    const row2 = cellMatrix[rowIndex];
+    const sizes2 = sizeMatrix[rowIndex];
+    columnIndex = -1;
+    const line = [];
+    while (++columnIndex < mostCellsPerRow) {
+      const cell = row2[columnIndex] || "";
+      let before = "";
+      let after = "";
+      if (options.alignDelimiters !== false) {
+        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
+        const code3 = alignments[columnIndex];
+        if (code3 === 114) {
+          before = " ".repeat(size);
+        } else if (code3 === 99) {
+          if (size % 2) {
+            before = " ".repeat(size / 2 + 0.5);
+            after = " ".repeat(size / 2 - 0.5);
+          } else {
+            before = " ".repeat(size / 2);
+            after = before;
+          }
+        } else {
+          after = " ".repeat(size);
+        }
+      }
+      if (options.delimiterStart !== false && !columnIndex) {
+        line.push("|");
+      }
+      if (options.padding !== false && !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
+        line.push(" ");
+      }
+      if (options.alignDelimiters !== false) {
+        line.push(before);
+      }
+      line.push(cell);
+      if (options.alignDelimiters !== false) {
+        line.push(after);
+      }
+      if (options.padding !== false) {
+        line.push(" ");
+      }
+      if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
+        line.push("|");
+      }
+    }
+    lines.push(options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join(""));
+  }
+  return lines.join("\n");
+}
+function serialize(value) {
+  return value === null || value === void 0 ? "" : String(value);
+}
+function defaultStringLength(value) {
+  return value.length;
+}
+function toAlignment(value) {
+  const code3 = typeof value === "string" ? value.codePointAt(0) : 0;
+  return code3 === 67 || code3 === 99 ? 99 : code3 === 76 || code3 === 108 ? 108 : code3 === 82 || code3 === 114 ? 114 : 0;
+}
+
+// ../../node_modules/.pnpm/mdast-util-gfm-table@1.0.2/node_modules/mdast-util-gfm-table/index.js
+var gfmTableFromMarkdown = {
+  enter: {
+    table: enterTable,
+    tableData: enterCell,
+    tableHeader: enterCell,
+    tableRow: enterRow
+  },
+  exit: {
+    codeText: exitCodeText,
+    table: exitTable,
+    tableData: exit2,
+    tableHeader: exit2,
+    tableRow: exit2
+  }
+};
+function enterTable(token) {
+  const align = token._align;
+  this.enter({
+    type: "table",
+    align: align.map((d) => d === "none" ? null : d),
+    children: []
+  }, token);
+  this.setData("inTable", true);
+}
+function exitTable(token) {
+  this.exit(token);
+  this.setData("inTable");
+}
+function enterRow(token) {
+  this.enter({ type: "tableRow", children: [] }, token);
+}
+function exit2(token) {
+  this.exit(token);
+}
+function enterCell(token) {
+  this.enter({ type: "tableCell", children: [] }, token);
+}
+function exitCodeText(token) {
+  let value = this.resume();
+  if (this.getData("inTable")) {
+    value = value.replace(/\\([\\|])/g, replace);
+  }
+  const node = this.stack[this.stack.length - 1];
+  node.value = value;
+  this.exit(token);
+}
+function replace($0, $1) {
+  return $1 === "|" ? $1 : $0;
+}
+function gfmTableToMarkdown(options) {
+  const settings = options || {};
+  const padding = settings.tableCellPadding;
+  const alignDelimiters = settings.tablePipeAlign;
+  const stringLength = settings.stringLength;
+  const around = padding ? " " : "|";
+  return {
+    unsafe: [
+      { character: "\r", inConstruct: "tableCell" },
+      { character: "\n", inConstruct: "tableCell" },
+      { atBreak: true, character: "|", after: "[	 :-]" },
+      { character: "|", inConstruct: "tableCell" },
+      { atBreak: true, character: ":", after: "-" },
+      { atBreak: true, character: "-", after: "[:|-]" }
+    ],
+    handlers: {
+      table: handleTable,
+      tableRow: handleTableRow,
+      tableCell: handleTableCell,
+      inlineCode: inlineCodeWithTable
+    }
+  };
+  function handleTable(node, _, context) {
+    return serializeData(handleTableAsData(node, context), node.align);
+  }
+  function handleTableRow(node, _, context) {
+    const row = handleTableRowAsData(node, context);
+    const value = serializeData([row]);
+    return value.slice(0, value.indexOf("\n"));
+  }
+  function handleTableCell(node, _, context) {
+    const exit3 = context.enter("tableCell");
+    const subexit = context.enter("phrasing");
+    const value = containerPhrasing2(node, context, {
+      before: around,
+      after: around
+    });
+    subexit();
+    exit3();
+    return value;
+  }
+  function serializeData(matrix, align) {
+    return markdownTable(matrix, {
+      align,
+      alignDelimiters,
+      padding,
+      stringLength
+    });
+  }
+  function handleTableAsData(node, context) {
+    const children = node.children;
+    let index3 = -1;
+    const result = [];
+    const subexit = context.enter("table");
+    while (++index3 < children.length) {
+      result[index3] = handleTableRowAsData(children[index3], context);
+    }
+    subexit();
+    return result;
+  }
+  function handleTableRowAsData(node, context) {
+    const children = node.children;
+    let index3 = -1;
+    const result = [];
+    const subexit = context.enter("tableRow");
+    while (++index3 < children.length) {
+      result[index3] = handleTableCell(children[index3], node, context);
+    }
+    subexit();
+    return result;
+  }
+  function inlineCodeWithTable(node, parent, context) {
+    let value = inlineCode2(node, parent, context);
+    if (context.stack.includes("tableCell")) {
+      value = value.replace(/\|/g, "\\$&");
+    }
+    return value;
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
+function checkBullet(context) {
+  const marker = context.options.bullet || "*";
+  if (marker !== "*" && marker !== "+" && marker !== "-") {
+    throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
+  }
+  return marker;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
+function checkListItemIndent(context) {
+  const style3 = context.options.listItemIndent || "tab";
+  if (style3 === 1 || style3 === "1") {
+    return "one";
+  }
+  if (style3 !== "tab" && style3 !== "one" && style3 !== "mixed") {
+    throw new Error("Cannot serialize items with `" + style3 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
+  }
+  return style3;
+}
+
+// ../../node_modules/.pnpm/mdast-util-to-markdown@1.2.6/node_modules/mdast-util-to-markdown/lib/handle/list-item.js
+function listItem2(node, parent, context) {
+  const listItemIndent = checkListItemIndent(context);
+  let bullet = context.bulletCurrent || checkBullet(context);
+  if (parent && parent.type === "list" && parent.ordered) {
+    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + bullet;
+  }
+  let size = bullet.length + 1;
+  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node.spread)) {
+    size = Math.ceil(size / 4) * 4;
+  }
+  const exit3 = context.enter("listItem");
+  const value = indentLines2(containerFlow2(node, context), map2);
+  exit3();
+  return value;
+  function map2(line, index3, blank) {
+    if (index3) {
+      return (blank ? "" : " ".repeat(size)) + line;
+    }
+    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-gfm-task-list-item@1.0.0/node_modules/mdast-util-gfm-task-list-item/index.js
+var gfmTaskListItemFromMarkdown = {
+  exit: {
+    taskListCheckValueChecked: exitCheck,
+    taskListCheckValueUnchecked: exitCheck,
+    paragraph: exitParagraphWithTaskListItem
+  }
+};
+var gfmTaskListItemToMarkdown = {
+  unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
+  handlers: { listItem: listItemWithTaskListItem }
+};
+function exitCheck(token) {
+  this.stack[this.stack.length - 2].checked = token.type === "taskListCheckValueChecked";
+}
+function exitParagraphWithTaskListItem(token) {
+  const parent = this.stack[this.stack.length - 2];
+  const node = this.stack[this.stack.length - 1];
+  const siblings = parent.children;
+  const head = node.children[0];
+  let index3 = -1;
+  let firstParaghraph;
+  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
+    while (++index3 < siblings.length) {
+      const sibling = siblings[index3];
+      if (sibling.type === "paragraph") {
+        firstParaghraph = sibling;
+        break;
+      }
+    }
+    if (firstParaghraph === node) {
+      head.value = head.value.slice(1);
+      if (head.value.length === 0) {
+        node.children.shift();
+      } else {
+        head.position.start.column++;
+        head.position.start.offset++;
+        node.position.start = Object.assign({}, head.position.start);
+      }
+    }
+  }
+  this.exit(token);
+}
+function listItemWithTaskListItem(node, parent, context) {
+  const head = node.children[0];
+  let value = listItem2(node, parent, context);
+  if (typeof node.checked === "boolean" && head && head.type === "paragraph") {
+    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
+  }
+  return value;
+  function check($0) {
+    return $0 + "[" + (node.checked ? "x" : " ") + "] ";
+  }
+}
+
+// ../../node_modules/.pnpm/mdast-util-gfm@2.0.0/node_modules/mdast-util-gfm/index.js
+function gfmFromMarkdown() {
+  return [
+    gfmAutolinkLiteralFromMarkdown,
+    gfmFootnoteFromMarkdown(),
+    gfmStrikethroughFromMarkdown,
+    gfmTableFromMarkdown,
+    gfmTaskListItemFromMarkdown
+  ];
+}
+function gfmToMarkdown(options) {
+  return {
+    extensions: [
+      gfmAutolinkLiteralToMarkdown,
+      gfmFootnoteToMarkdown(),
+      gfmStrikethroughToMarkdown,
+      gfmTableToMarkdown(options),
+      gfmTaskListItemToMarkdown
+    ]
+  };
+}
+
+// ../../node_modules/.pnpm/remark-gfm@3.0.1/node_modules/remark-gfm/index.js
+function remarkGfm(options = {}) {
+  const data2 = this.data();
+  add("micromarkExtensions", gfm(options));
+  add("fromMarkdownExtensions", gfmFromMarkdown());
+  add("toMarkdownExtensions", gfmToMarkdown(options));
+  function add(field, value) {
+    const list3 = data2[field] ? data2[field] : data2[field] = [];
+    list3.push(value);
+  }
+}
+
+// ../../node_modules/.pnpm/rehype-pretty-code@0.1.0_shiki@0.10.1/node_modules/rehype-pretty-code/dist/rehype-pretty-code.js
+var import_parse_numeric_range = __toESM(require_parse_numeric_range(), 1);
+var import_shiki = __toESM(require_dist(), 1);
+import proc from "process";
+import { fileURLToPath as fileURLToPath2 } from "url";
+import path2 from "path";
+var convert2 = function(test) {
+  if (test === void 0 || test === null) {
+    return ok2;
+  }
+  if (typeof test === "string") {
+    return typeFactory2(test);
+  }
+  if (typeof test === "object") {
+    return Array.isArray(test) ? anyFactory2(test) : propsFactory2(test);
+  }
+  if (typeof test === "function") {
+    return castFactory2(test);
+  }
+  throw new Error("Expected function, string, or object as test");
+};
+function anyFactory2(tests) {
+  const checks3 = [];
+  let index3 = -1;
+  while (++index3 < tests.length) {
+    checks3[index3] = convert2(tests[index3]);
+  }
+  return castFactory2(any);
+  function any(...parameters) {
+    let index4 = -1;
+    while (++index4 < checks3.length) {
+      if (checks3[index4].call(this, ...parameters))
+        return true;
+    }
+    return false;
+  }
+}
+function propsFactory2(check) {
+  return castFactory2(all4);
+  function all4(node) {
+    let key;
+    for (key in check) {
+      if (node[key] !== check[key])
+        return false;
+    }
+    return true;
+  }
+}
+function typeFactory2(check) {
+  return castFactory2(type2);
+  function type2(node) {
+    return node && node.type === check;
+  }
+}
+function castFactory2(check) {
+  return assertion;
+  function assertion(...parameters) {
+    return Boolean(check.call(this, ...parameters));
+  }
+}
+function ok2() {
+  return true;
+}
+function color4(d) {
+  return "\x1B[33m" + d + "\x1B[39m";
+}
+var CONTINUE4 = true;
+var SKIP4 = "skip";
+var EXIT4 = false;
+var visitParents3 = function(tree, test, visitor, reverse) {
+  if (typeof test === "function" && typeof visitor !== "function") {
+    reverse = visitor;
+    visitor = test;
+    test = null;
+  }
+  const is = convert2(test);
+  const step = reverse ? -1 : 1;
+  factory2(tree, null, [])();
+  function factory2(node, index3, parents) {
+    const value = typeof node === "object" && node !== null ? node : {};
+    let name3;
+    if (typeof value.type === "string") {
+      name3 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
+      Object.defineProperty(visit8, "name", {
+        value: "node (" + color4(value.type + (name3 ? "<" + name3 + ">" : "")) + ")"
+      });
+    }
+    return visit8;
+    function visit8() {
+      let result = [];
+      let subresult;
+      let offset2;
+      let grandparents;
+      if (!test || is(node, index3, parents[parents.length - 1] || null)) {
+        result = toResult4(visitor(node, parents));
+        if (result[0] === EXIT4) {
+          return result;
+        }
+      }
+      if (node.children && result[0] !== SKIP4) {
+        offset2 = (reverse ? node.children.length : -1) + step;
+        grandparents = parents.concat(node);
+        while (offset2 > -1 && offset2 < node.children.length) {
+          subresult = factory2(node.children[offset2], offset2, grandparents)();
+          if (subresult[0] === EXIT4) {
+            return subresult;
+          }
+          offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
+        }
+      }
+      return result;
+    }
+  }
+};
+function toResult4(value) {
+  if (Array.isArray(value)) {
+    return value;
+  }
+  if (typeof value === "number") {
+    return [CONTINUE4, value];
+  }
+  return [value];
+}
+var visit4 = function(tree, test, visitor, reverse) {
+  if (typeof test === "function" && typeof visitor !== "function") {
+    reverse = visitor;
+    visitor = test;
+    test = null;
+  }
+  visitParents3(tree, test, overload, reverse);
+  function overload(node, parents) {
+    const parent = parents[parents.length - 1];
+    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
+  }
+};
+function bail2(error) {
+  if (error) {
+    throw error;
+  }
+}
+var isBuffer2 = function isBuffer3(obj) {
+  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
+};
+var hasOwn2 = Object.prototype.hasOwnProperty;
+var toStr = Object.prototype.toString;
+var defineProperty = Object.defineProperty;
+var gOPD = Object.getOwnPropertyDescriptor;
+var isArray2 = function isArray3(arr) {
+  if (typeof Array.isArray === "function") {
+    return Array.isArray(arr);
+  }
+  return toStr.call(arr) === "[object Array]";
+};
+var isPlainObject$1 = function isPlainObject2(obj) {
+  if (!obj || toStr.call(obj) !== "[object Object]") {
+    return false;
+  }
+  var hasOwnConstructor = hasOwn2.call(obj, "constructor");
+  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
+  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
+    return false;
+  }
+  var key;
+  for (key in obj) {
+  }
+  return typeof key === "undefined" || hasOwn2.call(obj, key);
+};
+var setProperty = function setProperty2(target, options) {
+  if (defineProperty && options.name === "__proto__") {
+    defineProperty(target, options.name, {
+      enumerable: true,
+      configurable: true,
+      value: options.newValue,
+      writable: true
+    });
+  } else {
+    target[options.name] = options.newValue;
+  }
+};
+var getProperty = function getProperty2(obj, name3) {
+  if (name3 === "__proto__") {
+    if (!hasOwn2.call(obj, name3)) {
+      return void 0;
+    } else if (gOPD) {
+      return gOPD(obj, name3).value;
+    }
+  }
+  return obj[name3];
+};
+var extend3 = function extend4() {
+  var options, name3, src, copy, copyIsArray, clone;
+  var target = arguments[0];
+  var i = 1;
+  var length = arguments.length;
+  var deep = false;
+  if (typeof target === "boolean") {
+    deep = target;
+    target = arguments[1] || {};
+    i = 2;
+  }
+  if (target == null || typeof target !== "object" && typeof target !== "function") {
+    target = {};
+  }
+  for (; i < length; ++i) {
+    options = arguments[i];
+    if (options != null) {
+      for (name3 in options) {
+        src = getProperty(target, name3);
+        copy = getProperty(options, name3);
+        if (target !== copy) {
+          if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray2(copy)))) {
+            if (copyIsArray) {
+              copyIsArray = false;
+              clone = src && isArray2(src) ? src : [];
+            } else {
+              clone = src && isPlainObject$1(src) ? src : {};
+            }
+            setProperty(target, { name: name3, newValue: extend4(deep, clone, copy) });
+          } else if (typeof copy !== "undefined") {
+            setProperty(target, { name: name3, newValue: copy });
+          }
+        }
+      }
+    }
+  }
+  return target;
+};
+function isPlainObject3(value) {
+  if (Object.prototype.toString.call(value) !== "[object Object]") {
+    return false;
+  }
+  const prototype = Object.getPrototypeOf(value);
+  return prototype === null || prototype === Object.prototype;
+}
+function trough2() {
+  const fns = [];
+  const pipeline = { run, use };
+  return pipeline;
+  function run(...values) {
+    let middlewareIndex = -1;
+    const callback = values.pop();
+    if (typeof callback !== "function") {
+      throw new TypeError("Expected function as last argument, not " + callback);
+    }
+    next(null, ...values);
+    function next(error, ...output) {
+      const fn = fns[++middlewareIndex];
+      let index3 = -1;
+      if (error) {
+        callback(error);
+        return;
+      }
+      while (++index3 < values.length) {
+        if (output[index3] === null || output[index3] === void 0) {
+          output[index3] = values[index3];
+        }
+      }
+      values = output;
+      if (fn) {
+        wrap3(fn, next)(...output);
+      } else {
+        callback(null, ...output);
+      }
+    }
+  }
+  function use(middelware) {
+    if (typeof middelware !== "function") {
+      throw new TypeError("Expected `middelware` to be a function, not " + middelware);
+    }
+    fns.push(middelware);
+    return pipeline;
+  }
+}
+function wrap3(middleware, callback) {
+  let called;
+  return wrapped;
+  function wrapped(...parameters) {
+    const fnExpectsCallback = middleware.length > parameters.length;
+    let result;
+    if (fnExpectsCallback) {
+      parameters.push(done);
+    }
+    try {
+      result = middleware(...parameters);
+    } catch (error) {
+      const exception = error;
+      if (fnExpectsCallback && called) {
+        throw exception;
+      }
+      return done(exception);
+    }
+    if (!fnExpectsCallback) {
+      if (result instanceof Promise) {
+        result.then(then, done);
+      } else if (result instanceof Error) {
+        done(result);
+      } else {
+        then(result);
+      }
+    }
+  }
+  function done(error, ...output) {
+    if (!called) {
+      called = true;
+      callback(error, ...output);
+    }
+  }
+  function then(value) {
+    done(null, value);
+  }
+}
+var own$4 = {}.hasOwnProperty;
+function stringifyPosition2(value) {
+  if (!value || typeof value !== "object") {
+    return "";
+  }
+  if (own$4.call(value, "position") || own$4.call(value, "type")) {
+    return position$1(value.position);
+  }
+  if (own$4.call(value, "start") || own$4.call(value, "end")) {
+    return position$1(value);
+  }
+  if (own$4.call(value, "line") || own$4.call(value, "column")) {
+    return point$1(value);
+  }
+  return "";
+}
+function point$1(point4) {
+  return index2(point4 && point4.line) + ":" + index2(point4 && point4.column);
+}
+function position$1(pos) {
+  return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
+}
+function index2(value) {
+  return value && typeof value === "number" ? value : 1;
+}
+var VFileMessage2 = class extends Error {
+  constructor(reason, place, origin) {
+    var parts = [null, null];
+    var position4 = {
+      start: { line: null, column: null },
+      end: { line: null, column: null }
+    };
+    var index3;
+    super();
+    if (typeof place === "string") {
+      origin = place;
+      place = null;
+    }
+    if (typeof origin === "string") {
+      index3 = origin.indexOf(":");
+      if (index3 === -1) {
+        parts[1] = origin;
+      } else {
+        parts[0] = origin.slice(0, index3);
+        parts[1] = origin.slice(index3 + 1);
+      }
+    }
+    if (place) {
+      if ("type" in place || "position" in place) {
+        if (place.position) {
+          position4 = place.position;
+        }
+      } else if ("start" in place || "end" in place) {
+        position4 = place;
+      } else if ("line" in place || "column" in place) {
+        position4.start = place;
+      }
+    }
+    this.name = stringifyPosition2(place) || "1:1";
+    this.message = typeof reason === "object" ? reason.message : reason;
+    this.stack = typeof reason === "object" ? reason.stack : "";
+    this.reason = this.message;
+    this.fatal;
+    this.line = position4.start.line;
+    this.column = position4.start.column;
+    this.source = parts[0];
+    this.ruleId = parts[1];
+    this.position = position4;
+    this.actual;
+    this.expected;
+    this.file;
+    this.url;
+    this.note;
+  }
+};
+VFileMessage2.prototype.file = "";
+VFileMessage2.prototype.name = "";
+VFileMessage2.prototype.reason = "";
+VFileMessage2.prototype.message = "";
+VFileMessage2.prototype.stack = "";
+VFileMessage2.prototype.fatal = null;
+VFileMessage2.prototype.column = null;
+VFileMessage2.prototype.line = null;
+VFileMessage2.prototype.source = null;
+VFileMessage2.prototype.ruleId = null;
+VFileMessage2.prototype.position = null;
+function isUrl2(fileURLOrPath) {
+  return fileURLOrPath !== null && typeof fileURLOrPath === "object" && fileURLOrPath.href && fileURLOrPath.origin;
+}
+var order2 = ["history", "path", "basename", "stem", "extname", "dirname"];
+var VFile2 = class {
+  constructor(value) {
+    let options;
+    if (!value) {
+      options = {};
+    } else if (typeof value === "string" || isBuffer2(value)) {
+      options = { value };
+    } else if (isUrl2(value)) {
+      options = { path: value };
+    } else {
+      options = value;
+    }
+    this.data = {};
+    this.messages = [];
+    this.history = [];
+    this.cwd = proc.cwd();
+    this.value;
+    this.stored;
+    this.result;
+    this.map;
+    let index3 = -1;
+    while (++index3 < order2.length) {
+      const prop2 = order2[index3];
+      if (prop2 in options && options[prop2] !== void 0) {
+        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
+      }
+    }
+    let prop;
+    for (prop in options) {
+      if (!order2.includes(prop))
+        this[prop] = options[prop];
+    }
+  }
+  get path() {
+    return this.history[this.history.length - 1];
+  }
+  set path(path3) {
+    if (isUrl2(path3)) {
+      path3 = fileURLToPath2(path3);
+    }
+    assertNonEmpty2(path3, "path");
+    if (this.path !== path3) {
+      this.history.push(path3);
+    }
+  }
+  get dirname() {
+    return typeof this.path === "string" ? path2.dirname(this.path) : void 0;
+  }
+  set dirname(dirname) {
+    assertPath2(this.basename, "dirname");
+    this.path = path2.join(dirname || "", this.basename);
+  }
+  get basename() {
+    return typeof this.path === "string" ? path2.basename(this.path) : void 0;
+  }
+  set basename(basename) {
+    assertNonEmpty2(basename, "basename");
+    assertPart2(basename, "basename");
+    this.path = path2.join(this.dirname || "", basename);
+  }
+  get extname() {
+    return typeof this.path === "string" ? path2.extname(this.path) : void 0;
+  }
+  set extname(extname) {
+    assertPart2(extname, "extname");
+    assertPath2(this.dirname, "extname");
+    if (extname) {
+      if (extname.charCodeAt(0) !== 46) {
+        throw new Error("`extname` must start with `.`");
+      }
+      if (extname.includes(".", 1)) {
+        throw new Error("`extname` cannot contain multiple dots");
+      }
+    }
+    this.path = path2.join(this.dirname, this.stem + (extname || ""));
+  }
+  get stem() {
+    return typeof this.path === "string" ? path2.basename(this.path, this.extname) : void 0;
+  }
+  set stem(stem) {
+    assertNonEmpty2(stem, "stem");
+    assertPart2(stem, "stem");
+    this.path = path2.join(this.dirname || "", stem + (this.extname || ""));
+  }
+  toString(encoding) {
+    return (this.value || "").toString(encoding);
+  }
+  message(reason, place, origin) {
+    const message = new VFileMessage2(reason, place, origin);
+    if (this.path) {
+      message.name = this.path + ":" + message.name;
+      message.file = this.path;
+    }
+    message.fatal = false;
+    this.messages.push(message);
+    return message;
+  }
+  info(reason, place, origin) {
+    const message = this.message(reason, place, origin);
+    message.fatal = null;
+    return message;
+  }
+  fail(reason, place, origin) {
+    const message = this.message(reason, place, origin);
+    message.fatal = true;
+    throw message;
+  }
+};
+function assertPart2(part, name3) {
+  if (part && part.includes(path2.sep)) {
+    throw new Error("`" + name3 + "` cannot be a path: did not expect `" + path2.sep + "`");
+  }
+}
+function assertNonEmpty2(part, name3) {
+  if (!part) {
+    throw new Error("`" + name3 + "` cannot be empty");
+  }
+}
+function assertPath2(path3, name3) {
+  if (!path3) {
+    throw new Error("Setting `" + name3 + "` requires `path` to be set too");
+  }
+}
+var unified2 = base$1().freeze();
+var own$3 = {}.hasOwnProperty;
+function base$1() {
+  const transformers = trough2();
+  const attachers = [];
+  let namespace = {};
+  let frozen;
+  let freezeIndex = -1;
+  processor.data = data2;
+  processor.Parser = void 0;
+  processor.Compiler = void 0;
+  processor.freeze = freeze;
+  processor.attachers = attachers;
+  processor.use = use;
+  processor.parse = parse5;
+  processor.stringify = stringify4;
+  processor.run = run;
+  processor.runSync = runSync;
+  processor.process = process2;
+  processor.processSync = processSync;
+  return processor;
+  function processor() {
+    const destination = base$1();
+    let index3 = -1;
+    while (++index3 < attachers.length) {
+      destination.use(...attachers[index3]);
+    }
+    destination.data(extend3(true, {}, namespace));
+    return destination;
+  }
+  function data2(key, value) {
+    if (typeof key === "string") {
+      if (arguments.length === 2) {
+        assertUnfrozen2("data", frozen);
+        namespace[key] = value;
+        return processor;
+      }
+      return own$3.call(namespace, key) && namespace[key] || null;
+    }
+    if (key) {
+      assertUnfrozen2("data", frozen);
+      namespace = key;
+      return processor;
+    }
+    return namespace;
+  }
+  function freeze() {
+    if (frozen) {
+      return processor;
+    }
+    while (++freezeIndex < attachers.length) {
+      const [attacher, ...options] = attachers[freezeIndex];
+      if (options[0] === false) {
+        continue;
+      }
+      if (options[0] === true) {
+        options[1] = void 0;
+      }
+      const transformer = attacher.call(processor, ...options);
+      if (typeof transformer === "function") {
+        transformers.use(transformer);
+      }
+    }
+    frozen = true;
+    freezeIndex = Number.POSITIVE_INFINITY;
+    return processor;
+  }
+  function use(value, ...options) {
+    let settings;
+    assertUnfrozen2("use", frozen);
+    if (value === null || value === void 0)
+      ;
+    else if (typeof value === "function") {
+      addPlugin(value, ...options);
+    } else if (typeof value === "object") {
+      if (Array.isArray(value)) {
+        addList(value);
+      } else {
+        addPreset(value);
+      }
+    } else {
+      throw new TypeError("Expected usable value, not `" + value + "`");
+    }
+    if (settings) {
+      namespace.settings = Object.assign(namespace.settings || {}, settings);
+    }
+    return processor;
+    function add(value2) {
+      if (typeof value2 === "function") {
+        addPlugin(value2);
+      } else if (typeof value2 === "object") {
+        if (Array.isArray(value2)) {
+          const [plugin, ...options2] = value2;
+          addPlugin(plugin, ...options2);
+        } else {
+          addPreset(value2);
+        }
+      } else {
+        throw new TypeError("Expected usable value, not `" + value2 + "`");
+      }
+    }
+    function addPreset(result) {
+      addList(result.plugins);
+      if (result.settings) {
+        settings = Object.assign(settings || {}, result.settings);
+      }
+    }
+    function addList(plugins) {
+      let index3 = -1;
+      if (plugins === null || plugins === void 0)
+        ;
+      else if (Array.isArray(plugins)) {
+        while (++index3 < plugins.length) {
+          const thing = plugins[index3];
+          add(thing);
+        }
+      } else {
+        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
+      }
+    }
+    function addPlugin(plugin, value2) {
+      let index3 = -1;
+      let entry;
+      while (++index3 < attachers.length) {
+        if (attachers[index3][0] === plugin) {
+          entry = attachers[index3];
+          break;
+        }
+      }
+      if (entry) {
+        if (isPlainObject3(entry[1]) && isPlainObject3(value2)) {
+          value2 = extend3(true, entry[1], value2);
+        }
+        entry[1] = value2;
+      } else {
+        attachers.push([...arguments]);
+      }
+    }
+  }
+  function parse5(doc) {
+    processor.freeze();
+    const file = vfile2(doc);
+    const Parser4 = processor.Parser;
+    assertParser2("parse", Parser4);
+    if (newable2(Parser4, "parse")) {
+      return new Parser4(String(file), file).parse();
+    }
+    return Parser4(String(file), file);
+  }
+  function stringify4(node, doc) {
+    processor.freeze();
+    const file = vfile2(doc);
+    const Compiler = processor.Compiler;
+    assertCompiler2("stringify", Compiler);
+    assertNode2(node);
+    if (newable2(Compiler, "compile")) {
+      return new Compiler(node, file).compile();
+    }
+    return Compiler(node, file);
+  }
+  function run(node, doc, callback) {
+    assertNode2(node);
+    processor.freeze();
+    if (!callback && typeof doc === "function") {
+      callback = doc;
+      doc = void 0;
+    }
+    if (!callback) {
+      return new Promise(executor);
+    }
+    executor(null, callback);
+    function executor(resolve, reject) {
+      transformers.run(node, vfile2(doc), done);
+      function done(error, tree, file) {
+        tree = tree || node;
+        if (error) {
+          reject(error);
+        } else if (resolve) {
+          resolve(tree);
+        } else {
+          callback(null, tree, file);
+        }
+      }
+    }
+  }
+  function runSync(node, file) {
+    let result;
+    let complete;
+    processor.run(node, file, done);
+    assertDone2("runSync", "run", complete);
+    return result;
+    function done(error, tree) {
+      bail2(error);
+      result = tree;
+      complete = true;
+    }
+  }
+  function process2(doc, callback) {
+    processor.freeze();
+    assertParser2("process", processor.Parser);
+    assertCompiler2("process", processor.Compiler);
+    if (!callback) {
+      return new Promise(executor);
+    }
+    executor(null, callback);
+    function executor(resolve, reject) {
+      const file = vfile2(doc);
+      processor.run(processor.parse(file), file, (error, tree, file2) => {
+        if (error || !tree || !file2) {
+          done(error);
+        } else {
+          const result = processor.stringify(tree, file2);
+          if (result === void 0 || result === null)
+            ;
+          else if (looksLikeAVFileValue2(result)) {
+            file2.value = result;
+          } else {
+            file2.result = result;
+          }
+          done(error, file2);
+        }
+      });
+      function done(error, file2) {
+        if (error || !file2) {
+          reject(error);
+        } else if (resolve) {
+          resolve(file2);
+        } else {
+          callback(null, file2);
+        }
+      }
+    }
+  }
+  function processSync(doc) {
+    let complete;
+    processor.freeze();
+    assertParser2("processSync", processor.Parser);
+    assertCompiler2("processSync", processor.Compiler);
+    const file = vfile2(doc);
+    processor.process(file, done);
+    assertDone2("processSync", "process", complete);
+    return file;
+    function done(error) {
+      complete = true;
+      bail2(error);
+    }
+  }
+}
+function newable2(value, name3) {
+  return typeof value === "function" && value.prototype && (keys2(value.prototype) || name3 in value.prototype);
+}
+function keys2(value) {
+  let key;
+  for (key in value) {
+    if (own$3.call(value, key)) {
+      return true;
+    }
+  }
+  return false;
+}
+function assertParser2(name3, value) {
+  if (typeof value !== "function") {
+    throw new TypeError("Cannot `" + name3 + "` without `Parser`");
+  }
+}
+function assertCompiler2(name3, value) {
+  if (typeof value !== "function") {
+    throw new TypeError("Cannot `" + name3 + "` without `Compiler`");
+  }
+}
+function assertUnfrozen2(name3, frozen) {
+  if (frozen) {
+    throw new Error("Cannot call `" + name3 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
+  }
+}
+function assertNode2(node) {
+  if (!isPlainObject3(node) || typeof node.type !== "string") {
+    throw new TypeError("Expected node, got `" + node + "`");
+  }
+}
+function assertDone2(name3, asyncName, complete) {
+  if (!complete) {
+    throw new Error("`" + name3 + "` finished async. Use `" + asyncName + "` instead");
+  }
+}
+function vfile2(value) {
+  return looksLikeAVFile2(value) ? value : new VFile2(value);
+}
+function looksLikeAVFile2(value) {
+  return Boolean(value && typeof value === "object" && "message" in value && "messages" in value);
+}
+function looksLikeAVFileValue2(value) {
+  return typeof value === "string" || isBuffer2(value);
+}
+var unicode$3 = {};
+var UNDEFINED_CODE_POINTS = [
+  65534,
+  65535,
+  131070,
+  131071,
+  196606,
+  196607,
+  262142,
+  262143,
+  327678,
+  327679,
+  393214,
+  393215,
+  458750,
+  458751,
+  524286,
+  524287,
+  589822,
+  589823,
+  655358,
+  655359,
+  720894,
+  720895,
+  786430,
+  786431,
+  851966,
+  851967,
+  917502,
+  917503,
+  983038,
+  983039,
+  1048574,
+  1048575,
+  1114110,
+  1114111
+];
+unicode$3.REPLACEMENT_CHARACTER = "\uFFFD";
+unicode$3.CODE_POINTS = {
+  EOF: -1,
+  NULL: 0,
+  TABULATION: 9,
+  CARRIAGE_RETURN: 13,
+  LINE_FEED: 10,
+  FORM_FEED: 12,
+  SPACE: 32,
+  EXCLAMATION_MARK: 33,
+  QUOTATION_MARK: 34,
+  NUMBER_SIGN: 35,
+  AMPERSAND: 38,
+  APOSTROPHE: 39,
+  HYPHEN_MINUS: 45,
+  SOLIDUS: 47,
+  DIGIT_0: 48,
+  DIGIT_9: 57,
+  SEMICOLON: 59,
+  LESS_THAN_SIGN: 60,
+  EQUALS_SIGN: 61,
+  GREATER_THAN_SIGN: 62,
+  QUESTION_MARK: 63,
+  LATIN_CAPITAL_A: 65,
+  LATIN_CAPITAL_F: 70,
+  LATIN_CAPITAL_X: 88,
+  LATIN_CAPITAL_Z: 90,
+  RIGHT_SQUARE_BRACKET: 93,
+  GRAVE_ACCENT: 96,
+  LATIN_SMALL_A: 97,
+  LATIN_SMALL_F: 102,
+  LATIN_SMALL_X: 120,
+  LATIN_SMALL_Z: 122,
+  REPLACEMENT_CHARACTER: 65533
+};
+unicode$3.CODE_POINT_SEQUENCES = {
+  DASH_DASH_STRING: [45, 45],
+  DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
+  CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
+  SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
+  PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
+  SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
+};
+unicode$3.isSurrogate = function(cp) {
+  return cp >= 55296 && cp <= 57343;
+};
+unicode$3.isSurrogatePair = function(cp) {
+  return cp >= 56320 && cp <= 57343;
+};
+unicode$3.getSurrogatePairCodePoint = function(cp1, cp2) {
+  return (cp1 - 55296) * 1024 + 9216 + cp2;
+};
+unicode$3.isControlCodePoint = function(cp) {
+  return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
+};
+unicode$3.isUndefinedCodePoint = function(cp) {
+  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
+};
+var errorCodes = {
+  controlCharacterInInputStream: "control-character-in-input-stream",
+  noncharacterInInputStream: "noncharacter-in-input-stream",
+  surrogateInInputStream: "surrogate-in-input-stream",
+  nonVoidHtmlElementStartTagWithTrailingSolidus: "non-void-html-element-start-tag-with-trailing-solidus",
+  endTagWithAttributes: "end-tag-with-attributes",
+  endTagWithTrailingSolidus: "end-tag-with-trailing-solidus",
+  unexpectedSolidusInTag: "unexpected-solidus-in-tag",
+  unexpectedNullCharacter: "unexpected-null-character",
+  unexpectedQuestionMarkInsteadOfTagName: "unexpected-question-mark-instead-of-tag-name",
+  invalidFirstCharacterOfTagName: "invalid-first-character-of-tag-name",
+  unexpectedEqualsSignBeforeAttributeName: "unexpected-equals-sign-before-attribute-name",
+  missingEndTagName: "missing-end-tag-name",
+  unexpectedCharacterInAttributeName: "unexpected-character-in-attribute-name",
+  unknownNamedCharacterReference: "unknown-named-character-reference",
+  missingSemicolonAfterCharacterReference: "missing-semicolon-after-character-reference",
+  unexpectedCharacterAfterDoctypeSystemIdentifier: "unexpected-character-after-doctype-system-identifier",
+  unexpectedCharacterInUnquotedAttributeValue: "unexpected-character-in-unquoted-attribute-value",
+  eofBeforeTagName: "eof-before-tag-name",
+  eofInTag: "eof-in-tag",
+  missingAttributeValue: "missing-attribute-value",
+  missingWhitespaceBetweenAttributes: "missing-whitespace-between-attributes",
+  missingWhitespaceAfterDoctypePublicKeyword: "missing-whitespace-after-doctype-public-keyword",
+  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: "missing-whitespace-between-doctype-public-and-system-identifiers",
+  missingWhitespaceAfterDoctypeSystemKeyword: "missing-whitespace-after-doctype-system-keyword",
+  missingQuoteBeforeDoctypePublicIdentifier: "missing-quote-before-doctype-public-identifier",
+  missingQuoteBeforeDoctypeSystemIdentifier: "missing-quote-before-doctype-system-identifier",
+  missingDoctypePublicIdentifier: "missing-doctype-public-identifier",
+  missingDoctypeSystemIdentifier: "missing-doctype-system-identifier",
+  abruptDoctypePublicIdentifier: "abrupt-doctype-public-identifier",
+  abruptDoctypeSystemIdentifier: "abrupt-doctype-system-identifier",
+  cdataInHtmlContent: "cdata-in-html-content",
+  incorrectlyOpenedComment: "incorrectly-opened-comment",
+  eofInScriptHtmlCommentLikeText: "eof-in-script-html-comment-like-text",
+  eofInDoctype: "eof-in-doctype",
+  nestedComment: "nested-comment",
+  abruptClosingOfEmptyComment: "abrupt-closing-of-empty-comment",
+  eofInComment: "eof-in-comment",
+  incorrectlyClosedComment: "incorrectly-closed-comment",
+  eofInCdata: "eof-in-cdata",
+  absenceOfDigitsInNumericCharacterReference: "absence-of-digits-in-numeric-character-reference",
+  nullCharacterReference: "null-character-reference",
+  surrogateCharacterReference: "surrogate-character-reference",
+  characterReferenceOutsideUnicodeRange: "character-reference-outside-unicode-range",
+  controlCharacterReference: "control-character-reference",
+  noncharacterCharacterReference: "noncharacter-character-reference",
+  missingWhitespaceBeforeDoctypeName: "missing-whitespace-before-doctype-name",
+  missingDoctypeName: "missing-doctype-name",
+  invalidCharacterSequenceAfterDoctypeName: "invalid-character-sequence-after-doctype-name",
+  duplicateAttribute: "duplicate-attribute",
+  nonConformingDoctype: "non-conforming-doctype",
+  missingDoctype: "missing-doctype",
+  misplacedDoctype: "misplaced-doctype",
+  endTagWithoutMatchingOpenElement: "end-tag-without-matching-open-element",
+  closingOfElementWithOpenChildElements: "closing-of-element-with-open-child-elements",
+  disallowedContentInNoscriptInHead: "disallowed-content-in-noscript-in-head",
+  openElementsLeftAfterEof: "open-elements-left-after-eof",
+  abandonedHeadElementChild: "abandoned-head-element-child",
+  misplacedStartTagForHeadElement: "misplaced-start-tag-for-head-element",
+  nestedNoscriptInHead: "nested-noscript-in-head",
+  eofInElementThatCanContainOnlyText: "eof-in-element-that-can-contain-only-text"
+};
+var unicode$2 = unicode$3;
+var ERR$2 = errorCodes;
+var $$6 = unicode$2.CODE_POINTS;
+var DEFAULT_BUFFER_WATERLINE = 1 << 16;
+var Preprocessor$1 = class {
+  constructor() {
+    this.html = null;
+    this.pos = -1;
+    this.lastGapPos = -1;
+    this.lastCharPos = -1;
+    this.gapStack = [];
+    this.skipNextNewLine = false;
+    this.lastChunkWritten = false;
+    this.endOfChunkHit = false;
+    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
+  }
+  _err() {
+  }
+  _addGap() {
+    this.gapStack.push(this.lastGapPos);
+    this.lastGapPos = this.pos;
+  }
+  _processSurrogate(cp) {
+    if (this.pos !== this.lastCharPos) {
+      const nextCp = this.html.charCodeAt(this.pos + 1);
+      if (unicode$2.isSurrogatePair(nextCp)) {
+        this.pos++;
+        this._addGap();
+        return unicode$2.getSurrogatePairCodePoint(cp, nextCp);
+      }
+    } else if (!this.lastChunkWritten) {
+      this.endOfChunkHit = true;
+      return $$6.EOF;
+    }
+    this._err(ERR$2.surrogateInInputStream);
+    return cp;
+  }
+  dropParsedChunk() {
+    if (this.pos > this.bufferWaterline) {
+      this.lastCharPos -= this.pos;
+      this.html = this.html.substring(this.pos);
+      this.pos = 0;
+      this.lastGapPos = -1;
+      this.gapStack = [];
+    }
+  }
+  write(chunk, isLastChunk) {
+    if (this.html) {
+      this.html += chunk;
+    } else {
+      this.html = chunk;
+    }
+    this.lastCharPos = this.html.length - 1;
+    this.endOfChunkHit = false;
+    this.lastChunkWritten = isLastChunk;
+  }
+  insertHtmlAtCurrentPos(chunk) {
+    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);
+    this.lastCharPos = this.html.length - 1;
+    this.endOfChunkHit = false;
+  }
+  advance() {
+    this.pos++;
+    if (this.pos > this.lastCharPos) {
+      this.endOfChunkHit = !this.lastChunkWritten;
+      return $$6.EOF;
+    }
+    let cp = this.html.charCodeAt(this.pos);
+    if (this.skipNextNewLine && cp === $$6.LINE_FEED) {
+      this.skipNextNewLine = false;
+      this._addGap();
+      return this.advance();
+    }
+    if (cp === $$6.CARRIAGE_RETURN) {
+      this.skipNextNewLine = true;
+      return $$6.LINE_FEED;
+    }
+    this.skipNextNewLine = false;
+    if (unicode$2.isSurrogate(cp)) {
+      cp = this._processSurrogate(cp);
+    }
+    const isCommonValidRange = cp > 31 && cp < 127 || cp === $$6.LINE_FEED || cp === $$6.CARRIAGE_RETURN || cp > 159 && cp < 64976;
+    if (!isCommonValidRange) {
+      this._checkForProblematicCharacters(cp);
+    }
+    return cp;
+  }
+  _checkForProblematicCharacters(cp) {
+    if (unicode$2.isControlCodePoint(cp)) {
+      this._err(ERR$2.controlCharacterInInputStream);
+    } else if (unicode$2.isUndefinedCodePoint(cp)) {
+      this._err(ERR$2.noncharacterInInputStream);
+    }
+  }
+  retreat() {
+    if (this.pos === this.lastGapPos) {
+      this.lastGapPos = this.gapStack.pop();
+      this.pos--;
+    }
+    this.pos--;
+  }
+};
+var preprocessor = Preprocessor$1;
+var namedEntityData = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);
+var Preprocessor = preprocessor;
+var unicode$1 = unicode$3;
+var neTree = namedEntityData;
+var ERR$1 = errorCodes;
+var $$5 = unicode$1.CODE_POINTS;
+var $$ = unicode$1.CODE_POINT_SEQUENCES;
+var C1_CONTROLS_REFERENCE_REPLACEMENTS = {
+  128: 8364,
+  130: 8218,
+  131: 402,
+  132: 8222,
+  133: 8230,
+  134: 8224,
+  135: 8225,
+  136: 710,
+  137: 8240,
+  138: 352,
+  139: 8249,
+  140: 338,
+  142: 381,
+  145: 8216,
+  146: 8217,
+  147: 8220,
+  148: 8221,
+  149: 8226,
+  150: 8211,
+  151: 8212,
+  152: 732,
+  153: 8482,
+  154: 353,
+  155: 8250,
+  156: 339,
+  158: 382,
+  159: 376
+};
+var HAS_DATA_FLAG = 1 << 0;
+var DATA_DUPLET_FLAG = 1 << 1;
+var HAS_BRANCHES_FLAG = 1 << 2;
+var MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;
+var DATA_STATE = "DATA_STATE";
+var RCDATA_STATE = "RCDATA_STATE";
+var RAWTEXT_STATE = "RAWTEXT_STATE";
+var SCRIPT_DATA_STATE = "SCRIPT_DATA_STATE";
+var PLAINTEXT_STATE = "PLAINTEXT_STATE";
+var TAG_OPEN_STATE = "TAG_OPEN_STATE";
+var END_TAG_OPEN_STATE = "END_TAG_OPEN_STATE";
+var TAG_NAME_STATE = "TAG_NAME_STATE";
+var RCDATA_LESS_THAN_SIGN_STATE = "RCDATA_LESS_THAN_SIGN_STATE";
+var RCDATA_END_TAG_OPEN_STATE = "RCDATA_END_TAG_OPEN_STATE";
+var RCDATA_END_TAG_NAME_STATE = "RCDATA_END_TAG_NAME_STATE";
+var RAWTEXT_LESS_THAN_SIGN_STATE = "RAWTEXT_LESS_THAN_SIGN_STATE";
+var RAWTEXT_END_TAG_OPEN_STATE = "RAWTEXT_END_TAG_OPEN_STATE";
+var RAWTEXT_END_TAG_NAME_STATE = "RAWTEXT_END_TAG_NAME_STATE";
+var SCRIPT_DATA_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_LESS_THAN_SIGN_STATE";
+var SCRIPT_DATA_END_TAG_OPEN_STATE = "SCRIPT_DATA_END_TAG_OPEN_STATE";
+var SCRIPT_DATA_END_TAG_NAME_STATE = "SCRIPT_DATA_END_TAG_NAME_STATE";
+var SCRIPT_DATA_ESCAPE_START_STATE = "SCRIPT_DATA_ESCAPE_START_STATE";
+var SCRIPT_DATA_ESCAPE_START_DASH_STATE = "SCRIPT_DATA_ESCAPE_START_DASH_STATE";
+var SCRIPT_DATA_ESCAPED_STATE = "SCRIPT_DATA_ESCAPED_STATE";
+var SCRIPT_DATA_ESCAPED_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_STATE";
+var SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_DASH_STATE";
+var SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE";
+var SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE";
+var SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE";
+var SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE";
+var SCRIPT_DATA_DOUBLE_ESCAPED_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_STATE";
+var SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE";
+var SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE";
+var SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE";
+var SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE";
+var BEFORE_ATTRIBUTE_NAME_STATE = "BEFORE_ATTRIBUTE_NAME_STATE";
+var ATTRIBUTE_NAME_STATE = "ATTRIBUTE_NAME_STATE";
+var AFTER_ATTRIBUTE_NAME_STATE = "AFTER_ATTRIBUTE_NAME_STATE";
+var BEFORE_ATTRIBUTE_VALUE_STATE = "BEFORE_ATTRIBUTE_VALUE_STATE";
+var ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE";
+var ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = "ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE";
+var ATTRIBUTE_VALUE_UNQUOTED_STATE = "ATTRIBUTE_VALUE_UNQUOTED_STATE";
+var AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = "AFTER_ATTRIBUTE_VALUE_QUOTED_STATE";
+var SELF_CLOSING_START_TAG_STATE = "SELF_CLOSING_START_TAG_STATE";
+var BOGUS_COMMENT_STATE = "BOGUS_COMMENT_STATE";
+var MARKUP_DECLARATION_OPEN_STATE = "MARKUP_DECLARATION_OPEN_STATE";
+var COMMENT_START_STATE = "COMMENT_START_STATE";
+var COMMENT_START_DASH_STATE = "COMMENT_START_DASH_STATE";
+var COMMENT_STATE = "COMMENT_STATE";
+var COMMENT_LESS_THAN_SIGN_STATE = "COMMENT_LESS_THAN_SIGN_STATE";
+var COMMENT_LESS_THAN_SIGN_BANG_STATE = "COMMENT_LESS_THAN_SIGN_BANG_STATE";
+var COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE";
+var COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE";
+var COMMENT_END_DASH_STATE = "COMMENT_END_DASH_STATE";
+var COMMENT_END_STATE = "COMMENT_END_STATE";
+var COMMENT_END_BANG_STATE = "COMMENT_END_BANG_STATE";
+var DOCTYPE_STATE = "DOCTYPE_STATE";
+var BEFORE_DOCTYPE_NAME_STATE = "BEFORE_DOCTYPE_NAME_STATE";
+var DOCTYPE_NAME_STATE = "DOCTYPE_NAME_STATE";
+var AFTER_DOCTYPE_NAME_STATE = "AFTER_DOCTYPE_NAME_STATE";
+var AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = "AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE";
+var BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
+var DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE";
+var DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE";
+var AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
+var BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE";
+var AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = "AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE";
+var BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
+var DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE";
+var DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE";
+var AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
+var BOGUS_DOCTYPE_STATE = "BOGUS_DOCTYPE_STATE";
+var CDATA_SECTION_STATE = "CDATA_SECTION_STATE";
+var CDATA_SECTION_BRACKET_STATE = "CDATA_SECTION_BRACKET_STATE";
+var CDATA_SECTION_END_STATE = "CDATA_SECTION_END_STATE";
+var CHARACTER_REFERENCE_STATE = "CHARACTER_REFERENCE_STATE";
+var NAMED_CHARACTER_REFERENCE_STATE = "NAMED_CHARACTER_REFERENCE_STATE";
+var AMBIGUOUS_AMPERSAND_STATE = "AMBIGUOS_AMPERSAND_STATE";
+var NUMERIC_CHARACTER_REFERENCE_STATE = "NUMERIC_CHARACTER_REFERENCE_STATE";
+var HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_START_STATE";
+var DECIMAL_CHARACTER_REFERENCE_START_STATE = "DECIMAL_CHARACTER_REFERENCE_START_STATE";
+var HEXADEMICAL_CHARACTER_REFERENCE_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_STATE";
+var DECIMAL_CHARACTER_REFERENCE_STATE = "DECIMAL_CHARACTER_REFERENCE_STATE";
+var NUMERIC_CHARACTER_REFERENCE_END_STATE = "NUMERIC_CHARACTER_REFERENCE_END_STATE";
+function isWhitespace(cp) {
+  return cp === $$5.SPACE || cp === $$5.LINE_FEED || cp === $$5.TABULATION || cp === $$5.FORM_FEED;
+}
+function isAsciiDigit(cp) {
+  return cp >= $$5.DIGIT_0 && cp <= $$5.DIGIT_9;
+}
+function isAsciiUpper(cp) {
+  return cp >= $$5.LATIN_CAPITAL_A && cp <= $$5.LATIN_CAPITAL_Z;
+}
+function isAsciiLower(cp) {
+  return cp >= $$5.LATIN_SMALL_A && cp <= $$5.LATIN_SMALL_Z;
+}
+function isAsciiLetter(cp) {
+  return isAsciiLower(cp) || isAsciiUpper(cp);
+}
+function isAsciiAlphaNumeric(cp) {
+  return isAsciiLetter(cp) || isAsciiDigit(cp);
+}
+function isAsciiUpperHexDigit(cp) {
+  return cp >= $$5.LATIN_CAPITAL_A && cp <= $$5.LATIN_CAPITAL_F;
+}
+function isAsciiLowerHexDigit(cp) {
+  return cp >= $$5.LATIN_SMALL_A && cp <= $$5.LATIN_SMALL_F;
+}
+function isAsciiHexDigit(cp) {
+  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
+}
+function toAsciiLowerCodePoint(cp) {
+  return cp + 32;
+}
+function toChar(cp) {
+  if (cp <= 65535) {
+    return String.fromCharCode(cp);
+  }
+  cp -= 65536;
+  return String.fromCharCode(cp >>> 10 & 1023 | 55296) + String.fromCharCode(56320 | cp & 1023);
+}
+function toAsciiLowerChar(cp) {
+  return String.fromCharCode(toAsciiLowerCodePoint(cp));
+}
+function findNamedEntityTreeBranch(nodeIx, cp) {
+  const branchCount = neTree[++nodeIx];
+  let lo = ++nodeIx;
+  let hi = lo + branchCount - 1;
+  while (lo <= hi) {
+    const mid = lo + hi >>> 1;
+    const midCp = neTree[mid];
+    if (midCp < cp) {
+      lo = mid + 1;
+    } else if (midCp > cp) {
+      hi = mid - 1;
+    } else {
+      return neTree[mid + branchCount];
+    }
+  }
+  return -1;
+}
+var Tokenizer$4 = class {
+  constructor() {
+    this.preprocessor = new Preprocessor();
+    this.tokenQueue = [];
+    this.allowCDATA = false;
+    this.state = DATA_STATE;
+    this.returnState = "";
+    this.charRefCode = -1;
+    this.tempBuff = [];
+    this.lastStartTagName = "";
+    this.consumedAfterSnapshot = -1;
+    this.active = false;
+    this.currentCharacterToken = null;
+    this.currentToken = null;
+    this.currentAttr = null;
+  }
+  _err() {
+  }
+  _errOnNextCodePoint(err) {
+    this._consume();
+    this._err(err);
+    this._unconsume();
+  }
+  getNextToken() {
+    while (!this.tokenQueue.length && this.active) {
+      this.consumedAfterSnapshot = 0;
+      const cp = this._consume();
+      if (!this._ensureHibernation()) {
+        this[this.state](cp);
+      }
+    }
+    return this.tokenQueue.shift();
+  }
+  write(chunk, isLastChunk) {
+    this.active = true;
+    this.preprocessor.write(chunk, isLastChunk);
+  }
+  insertHtmlAtCurrentPos(chunk) {
+    this.active = true;
+    this.preprocessor.insertHtmlAtCurrentPos(chunk);
+  }
+  _ensureHibernation() {
+    if (this.preprocessor.endOfChunkHit) {
+      for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
+        this.preprocessor.retreat();
+      }
+      this.active = false;
+      this.tokenQueue.push({ type: Tokenizer$4.HIBERNATION_TOKEN });
+      return true;
+    }
+    return false;
+  }
+  _consume() {
+    this.consumedAfterSnapshot++;
+    return this.preprocessor.advance();
+  }
+  _unconsume() {
+    this.consumedAfterSnapshot--;
+    this.preprocessor.retreat();
+  }
+  _reconsumeInState(state) {
+    this.state = state;
+    this._unconsume();
+  }
+  _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
+    let consumedCount = 0;
+    let isMatch = true;
+    const patternLength = pattern.length;
+    let patternPos = 0;
+    let cp = startCp;
+    let patternCp = void 0;
+    for (; patternPos < patternLength; patternPos++) {
+      if (patternPos > 0) {
+        cp = this._consume();
+        consumedCount++;
+      }
+      if (cp === $$5.EOF) {
+        isMatch = false;
+        break;
+      }
+      patternCp = pattern[patternPos];
+      if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
+        isMatch = false;
+        break;
+      }
+    }
+    if (!isMatch) {
+      while (consumedCount--) {
+        this._unconsume();
+      }
+    }
+    return isMatch;
+  }
+  _isTempBufferEqualToScriptString() {
+    if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
+      return false;
+    }
+    for (let i = 0; i < this.tempBuff.length; i++) {
+      if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
+  _createStartTagToken() {
+    this.currentToken = {
+      type: Tokenizer$4.START_TAG_TOKEN,
+      tagName: "",
+      selfClosing: false,
+      ackSelfClosing: false,
+      attrs: []
+    };
+  }
+  _createEndTagToken() {
+    this.currentToken = {
+      type: Tokenizer$4.END_TAG_TOKEN,
+      tagName: "",
+      selfClosing: false,
+      attrs: []
+    };
+  }
+  _createCommentToken() {
+    this.currentToken = {
+      type: Tokenizer$4.COMMENT_TOKEN,
+      data: ""
+    };
+  }
+  _createDoctypeToken(initialName) {
+    this.currentToken = {
+      type: Tokenizer$4.DOCTYPE_TOKEN,
+      name: initialName,
+      forceQuirks: false,
+      publicId: null,
+      systemId: null
+    };
+  }
+  _createCharacterToken(type2, ch) {
+    this.currentCharacterToken = {
+      type: type2,
+      chars: ch
+    };
+  }
+  _createEOFToken() {
+    this.currentToken = { type: Tokenizer$4.EOF_TOKEN };
+  }
+  _createAttr(attrNameFirstCh) {
+    this.currentAttr = {
+      name: attrNameFirstCh,
+      value: ""
+    };
+  }
+  _leaveAttrName(toState) {
+    if (Tokenizer$4.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
+      this.currentToken.attrs.push(this.currentAttr);
+    } else {
+      this._err(ERR$1.duplicateAttribute);
+    }
+    this.state = toState;
+  }
+  _leaveAttrValue(toState) {
+    this.state = toState;
+  }
+  _emitCurrentToken() {
+    this._emitCurrentCharacterToken();
+    const ct = this.currentToken;
+    this.currentToken = null;
+    if (ct.type === Tokenizer$4.START_TAG_TOKEN) {
+      this.lastStartTagName = ct.tagName;
+    } else if (ct.type === Tokenizer$4.END_TAG_TOKEN) {
+      if (ct.attrs.length > 0) {
+        this._err(ERR$1.endTagWithAttributes);
+      }
+      if (ct.selfClosing) {
+        this._err(ERR$1.endTagWithTrailingSolidus);
+      }
+    }
+    this.tokenQueue.push(ct);
+  }
+  _emitCurrentCharacterToken() {
+    if (this.currentCharacterToken) {
+      this.tokenQueue.push(this.currentCharacterToken);
+      this.currentCharacterToken = null;
+    }
+  }
+  _emitEOFToken() {
+    this._createEOFToken();
+    this._emitCurrentToken();
+  }
+  _appendCharToCurrentCharacterToken(type2, ch) {
+    if (this.currentCharacterToken && this.currentCharacterToken.type !== type2) {
+      this._emitCurrentCharacterToken();
+    }
+    if (this.currentCharacterToken) {
+      this.currentCharacterToken.chars += ch;
+    } else {
+      this._createCharacterToken(type2, ch);
+    }
+  }
+  _emitCodePoint(cp) {
+    let type2 = Tokenizer$4.CHARACTER_TOKEN;
+    if (isWhitespace(cp)) {
+      type2 = Tokenizer$4.WHITESPACE_CHARACTER_TOKEN;
+    } else if (cp === $$5.NULL) {
+      type2 = Tokenizer$4.NULL_CHARACTER_TOKEN;
+    }
+    this._appendCharToCurrentCharacterToken(type2, toChar(cp));
+  }
+  _emitSeveralCodePoints(codePoints) {
+    for (let i = 0; i < codePoints.length; i++) {
+      this._emitCodePoint(codePoints[i]);
+    }
+  }
+  _emitChars(ch) {
+    this._appendCharToCurrentCharacterToken(Tokenizer$4.CHARACTER_TOKEN, ch);
+  }
+  _matchNamedCharacterReference(startCp) {
+    let result = null;
+    let excess = 1;
+    let i = findNamedEntityTreeBranch(0, startCp);
+    this.tempBuff.push(startCp);
+    while (i > -1) {
+      const current2 = neTree[i];
+      const inNode = current2 < MAX_BRANCH_MARKER_VALUE;
+      const nodeWithData = inNode && current2 & HAS_DATA_FLAG;
+      if (nodeWithData) {
+        result = current2 & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
+        excess = 0;
+      }
+      const cp = this._consume();
+      this.tempBuff.push(cp);
+      excess++;
+      if (cp === $$5.EOF) {
+        break;
+      }
+      if (inNode) {
+        i = current2 & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;
+      } else {
+        i = cp === current2 ? ++i : -1;
+      }
+    }
+    while (excess--) {
+      this.tempBuff.pop();
+      this._unconsume();
+    }
+    return result;
+  }
+  _isCharacterReferenceInAttribute() {
+    return this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE;
+  }
+  _isCharacterReferenceAttributeQuirk(withSemicolon) {
+    if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
+      const nextCp = this._consume();
+      this._unconsume();
+      return nextCp === $$5.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
+    }
+    return false;
+  }
+  _flushCodePointsConsumedAsCharacterReference() {
+    if (this._isCharacterReferenceInAttribute()) {
+      for (let i = 0; i < this.tempBuff.length; i++) {
+        this.currentAttr.value += toChar(this.tempBuff[i]);
+      }
+    } else {
+      this._emitSeveralCodePoints(this.tempBuff);
+    }
+    this.tempBuff = [];
+  }
+  [DATA_STATE](cp) {
+    this.preprocessor.dropParsedChunk();
+    if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = TAG_OPEN_STATE;
+    } else if (cp === $$5.AMPERSAND) {
+      this.returnState = DATA_STATE;
+      this.state = CHARACTER_REFERENCE_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this._emitCodePoint(cp);
+    } else if (cp === $$5.EOF) {
+      this._emitEOFToken();
+    } else {
+      this._emitCodePoint(cp);
+    }
+  }
+  [RCDATA_STATE](cp) {
+    this.preprocessor.dropParsedChunk();
+    if (cp === $$5.AMPERSAND) {
+      this.returnState = RCDATA_STATE;
+      this.state = CHARACTER_REFERENCE_STATE;
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = RCDATA_LESS_THAN_SIGN_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._emitEOFToken();
+    } else {
+      this._emitCodePoint(cp);
+    }
+  }
+  [RAWTEXT_STATE](cp) {
+    this.preprocessor.dropParsedChunk();
+    if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._emitEOFToken();
+    } else {
+      this._emitCodePoint(cp);
+    }
+  }
+  [SCRIPT_DATA_STATE](cp) {
+    this.preprocessor.dropParsedChunk();
+    if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._emitEOFToken();
+    } else {
+      this._emitCodePoint(cp);
+    }
+  }
+  [PLAINTEXT_STATE](cp) {
+    this.preprocessor.dropParsedChunk();
+    if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._emitEOFToken();
+    } else {
+      this._emitCodePoint(cp);
+    }
+  }
+  [TAG_OPEN_STATE](cp) {
+    if (cp === $$5.EXCLAMATION_MARK) {
+      this.state = MARKUP_DECLARATION_OPEN_STATE;
+    } else if (cp === $$5.SOLIDUS) {
+      this.state = END_TAG_OPEN_STATE;
+    } else if (isAsciiLetter(cp)) {
+      this._createStartTagToken();
+      this._reconsumeInState(TAG_NAME_STATE);
+    } else if (cp === $$5.QUESTION_MARK) {
+      this._err(ERR$1.unexpectedQuestionMarkInsteadOfTagName);
+      this._createCommentToken();
+      this._reconsumeInState(BOGUS_COMMENT_STATE);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofBeforeTagName);
+      this._emitChars("<");
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.invalidFirstCharacterOfTagName);
+      this._emitChars("<");
+      this._reconsumeInState(DATA_STATE);
+    }
+  }
+  [END_TAG_OPEN_STATE](cp) {
+    if (isAsciiLetter(cp)) {
+      this._createEndTagToken();
+      this._reconsumeInState(TAG_NAME_STATE);
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.missingEndTagName);
+      this.state = DATA_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofBeforeTagName);
+      this._emitChars("</");
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.invalidFirstCharacterOfTagName);
+      this._createCommentToken();
+      this._reconsumeInState(BOGUS_COMMENT_STATE);
+    }
+  }
+  [TAG_NAME_STATE](cp) {
+    if (isWhitespace(cp)) {
+      this.state = BEFORE_ATTRIBUTE_NAME_STATE;
+    } else if (cp === $$5.SOLIDUS) {
+      this.state = SELF_CLOSING_START_TAG_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (isAsciiUpper(cp)) {
+      this.currentToken.tagName += toAsciiLowerChar(cp);
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentToken.tagName += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInTag);
+      this._emitEOFToken();
+    } else {
+      this.currentToken.tagName += toChar(cp);
+    }
+  }
+  [RCDATA_LESS_THAN_SIGN_STATE](cp) {
+    if (cp === $$5.SOLIDUS) {
+      this.tempBuff = [];
+      this.state = RCDATA_END_TAG_OPEN_STATE;
+    } else {
+      this._emitChars("<");
+      this._reconsumeInState(RCDATA_STATE);
+    }
+  }
+  [RCDATA_END_TAG_OPEN_STATE](cp) {
+    if (isAsciiLetter(cp)) {
+      this._createEndTagToken();
+      this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
+    } else {
+      this._emitChars("</");
+      this._reconsumeInState(RCDATA_STATE);
+    }
+  }
+  [RCDATA_END_TAG_NAME_STATE](cp) {
+    if (isAsciiUpper(cp)) {
+      this.currentToken.tagName += toAsciiLowerChar(cp);
+      this.tempBuff.push(cp);
+    } else if (isAsciiLower(cp)) {
+      this.currentToken.tagName += toChar(cp);
+      this.tempBuff.push(cp);
+    } else {
+      if (this.lastStartTagName === this.currentToken.tagName) {
+        if (isWhitespace(cp)) {
+          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
+          return;
+        }
+        if (cp === $$5.SOLIDUS) {
+          this.state = SELF_CLOSING_START_TAG_STATE;
+          return;
+        }
+        if (cp === $$5.GREATER_THAN_SIGN) {
+          this.state = DATA_STATE;
+          this._emitCurrentToken();
+          return;
+        }
+      }
+      this._emitChars("</");
+      this._emitSeveralCodePoints(this.tempBuff);
+      this._reconsumeInState(RCDATA_STATE);
+    }
+  }
+  [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
+    if (cp === $$5.SOLIDUS) {
+      this.tempBuff = [];
+      this.state = RAWTEXT_END_TAG_OPEN_STATE;
+    } else {
+      this._emitChars("<");
+      this._reconsumeInState(RAWTEXT_STATE);
+    }
+  }
+  [RAWTEXT_END_TAG_OPEN_STATE](cp) {
+    if (isAsciiLetter(cp)) {
+      this._createEndTagToken();
+      this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
+    } else {
+      this._emitChars("</");
+      this._reconsumeInState(RAWTEXT_STATE);
+    }
+  }
+  [RAWTEXT_END_TAG_NAME_STATE](cp) {
+    if (isAsciiUpper(cp)) {
+      this.currentToken.tagName += toAsciiLowerChar(cp);
+      this.tempBuff.push(cp);
+    } else if (isAsciiLower(cp)) {
+      this.currentToken.tagName += toChar(cp);
+      this.tempBuff.push(cp);
+    } else {
+      if (this.lastStartTagName === this.currentToken.tagName) {
+        if (isWhitespace(cp)) {
+          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
+          return;
+        }
+        if (cp === $$5.SOLIDUS) {
+          this.state = SELF_CLOSING_START_TAG_STATE;
+          return;
+        }
+        if (cp === $$5.GREATER_THAN_SIGN) {
+          this._emitCurrentToken();
+          this.state = DATA_STATE;
+          return;
+        }
+      }
+      this._emitChars("</");
+      this._emitSeveralCodePoints(this.tempBuff);
+      this._reconsumeInState(RAWTEXT_STATE);
+    }
+  }
+  [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
+    if (cp === $$5.SOLIDUS) {
+      this.tempBuff = [];
+      this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
+    } else if (cp === $$5.EXCLAMATION_MARK) {
+      this.state = SCRIPT_DATA_ESCAPE_START_STATE;
+      this._emitChars("<!");
+    } else {
+      this._emitChars("<");
+      this._reconsumeInState(SCRIPT_DATA_STATE);
+    }
+  }
+  [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
+    if (isAsciiLetter(cp)) {
+      this._createEndTagToken();
+      this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
+    } else {
+      this._emitChars("</");
+      this._reconsumeInState(SCRIPT_DATA_STATE);
+    }
+  }
+  [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
+    if (isAsciiUpper(cp)) {
+      this.currentToken.tagName += toAsciiLowerChar(cp);
+      this.tempBuff.push(cp);
+    } else if (isAsciiLower(cp)) {
+      this.currentToken.tagName += toChar(cp);
+      this.tempBuff.push(cp);
+    } else {
+      if (this.lastStartTagName === this.currentToken.tagName) {
+        if (isWhitespace(cp)) {
+          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
+          return;
+        } else if (cp === $$5.SOLIDUS) {
+          this.state = SELF_CLOSING_START_TAG_STATE;
+          return;
+        } else if (cp === $$5.GREATER_THAN_SIGN) {
+          this._emitCurrentToken();
+          this.state = DATA_STATE;
+          return;
+        }
+      }
+      this._emitChars("</");
+      this._emitSeveralCodePoints(this.tempBuff);
+      this._reconsumeInState(SCRIPT_DATA_STATE);
+    }
+  }
+  [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
+      this._emitChars("-");
+    } else {
+      this._reconsumeInState(SCRIPT_DATA_STATE);
+    }
+  }
+  [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
+      this._emitChars("-");
+    } else {
+      this._reconsumeInState(SCRIPT_DATA_STATE);
+    }
+  }
+  [SCRIPT_DATA_ESCAPED_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
+      this._emitChars("-");
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInScriptHtmlCommentLikeText);
+      this._emitEOFToken();
+    } else {
+      this._emitCodePoint(cp);
+    }
+  }
+  [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
+      this._emitChars("-");
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.state = SCRIPT_DATA_ESCAPED_STATE;
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInScriptHtmlCommentLikeText);
+      this._emitEOFToken();
+    } else {
+      this.state = SCRIPT_DATA_ESCAPED_STATE;
+      this._emitCodePoint(cp);
+    }
+  }
+  [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this._emitChars("-");
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = SCRIPT_DATA_STATE;
+      this._emitChars(">");
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.state = SCRIPT_DATA_ESCAPED_STATE;
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInScriptHtmlCommentLikeText);
+      this._emitEOFToken();
+    } else {
+      this.state = SCRIPT_DATA_ESCAPED_STATE;
+      this._emitCodePoint(cp);
+    }
+  }
+  [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
+    if (cp === $$5.SOLIDUS) {
+      this.tempBuff = [];
+      this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
+    } else if (isAsciiLetter(cp)) {
+      this.tempBuff = [];
+      this._emitChars("<");
+      this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
+    } else {
+      this._emitChars("<");
+      this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
+    }
+  }
+  [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
+    if (isAsciiLetter(cp)) {
+      this._createEndTagToken();
+      this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
+    } else {
+      this._emitChars("</");
+      this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
+    }
+  }
+  [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
+    if (isAsciiUpper(cp)) {
+      this.currentToken.tagName += toAsciiLowerChar(cp);
+      this.tempBuff.push(cp);
+    } else if (isAsciiLower(cp)) {
+      this.currentToken.tagName += toChar(cp);
+      this.tempBuff.push(cp);
+    } else {
+      if (this.lastStartTagName === this.currentToken.tagName) {
+        if (isWhitespace(cp)) {
+          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
+          return;
+        }
+        if (cp === $$5.SOLIDUS) {
+          this.state = SELF_CLOSING_START_TAG_STATE;
+          return;
+        }
+        if (cp === $$5.GREATER_THAN_SIGN) {
+          this._emitCurrentToken();
+          this.state = DATA_STATE;
+          return;
+        }
+      }
+      this._emitChars("</");
+      this._emitSeveralCodePoints(this.tempBuff);
+      this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
+    }
+  }
+  [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
+    if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN) {
+      this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
+      this._emitCodePoint(cp);
+    } else if (isAsciiUpper(cp)) {
+      this.tempBuff.push(toAsciiLowerCodePoint(cp));
+      this._emitCodePoint(cp);
+    } else if (isAsciiLower(cp)) {
+      this.tempBuff.push(cp);
+      this._emitCodePoint(cp);
+    } else {
+      this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
+    }
+  }
+  [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
+      this._emitChars("-");
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
+      this._emitChars("<");
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInScriptHtmlCommentLikeText);
+      this._emitEOFToken();
+    } else {
+      this._emitCodePoint(cp);
+    }
+  }
+  [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
+      this._emitChars("-");
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
+      this._emitChars("<");
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInScriptHtmlCommentLikeText);
+      this._emitEOFToken();
+    } else {
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
+      this._emitCodePoint(cp);
+    }
+  }
+  [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this._emitChars("-");
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
+      this._emitChars("<");
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = SCRIPT_DATA_STATE;
+      this._emitChars(">");
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
+      this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInScriptHtmlCommentLikeText);
+      this._emitEOFToken();
+    } else {
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
+      this._emitCodePoint(cp);
+    }
+  }
+  [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
+    if (cp === $$5.SOLIDUS) {
+      this.tempBuff = [];
+      this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
+      this._emitChars("/");
+    } else {
+      this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
+    }
+  }
+  [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
+    if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN) {
+      this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
+      this._emitCodePoint(cp);
+    } else if (isAsciiUpper(cp)) {
+      this.tempBuff.push(toAsciiLowerCodePoint(cp));
+      this._emitCodePoint(cp);
+    } else if (isAsciiLower(cp)) {
+      this.tempBuff.push(cp);
+      this._emitCodePoint(cp);
+    } else {
+      this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
+    }
+  }
+  [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN || cp === $$5.EOF) {
+      this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
+    } else if (cp === $$5.EQUALS_SIGN) {
+      this._err(ERR$1.unexpectedEqualsSignBeforeAttributeName);
+      this._createAttr("=");
+      this.state = ATTRIBUTE_NAME_STATE;
+    } else {
+      this._createAttr("");
+      this._reconsumeInState(ATTRIBUTE_NAME_STATE);
+    }
+  }
+  [ATTRIBUTE_NAME_STATE](cp) {
+    if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN || cp === $$5.EOF) {
+      this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
+      this._unconsume();
+    } else if (cp === $$5.EQUALS_SIGN) {
+      this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
+    } else if (isAsciiUpper(cp)) {
+      this.currentAttr.name += toAsciiLowerChar(cp);
+    } else if (cp === $$5.QUOTATION_MARK || cp === $$5.APOSTROPHE || cp === $$5.LESS_THAN_SIGN) {
+      this._err(ERR$1.unexpectedCharacterInAttributeName);
+      this.currentAttr.name += toChar(cp);
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentAttr.name += unicode$1.REPLACEMENT_CHARACTER;
+    } else {
+      this.currentAttr.name += toChar(cp);
+    }
+  }
+  [AFTER_ATTRIBUTE_NAME_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (cp === $$5.SOLIDUS) {
+      this.state = SELF_CLOSING_START_TAG_STATE;
+    } else if (cp === $$5.EQUALS_SIGN) {
+      this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInTag);
+      this._emitEOFToken();
+    } else {
+      this._createAttr("");
+      this._reconsumeInState(ATTRIBUTE_NAME_STATE);
+    }
+  }
+  [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (cp === $$5.QUOTATION_MARK) {
+      this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
+    } else if (cp === $$5.APOSTROPHE) {
+      this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.missingAttributeValue);
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else {
+      this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
+    }
+  }
+  [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
+    if (cp === $$5.QUOTATION_MARK) {
+      this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
+    } else if (cp === $$5.AMPERSAND) {
+      this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
+      this.state = CHARACTER_REFERENCE_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInTag);
+      this._emitEOFToken();
+    } else {
+      this.currentAttr.value += toChar(cp);
+    }
+  }
+  [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
+    if (cp === $$5.APOSTROPHE) {
+      this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
+    } else if (cp === $$5.AMPERSAND) {
+      this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
+      this.state = CHARACTER_REFERENCE_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInTag);
+      this._emitEOFToken();
+    } else {
+      this.currentAttr.value += toChar(cp);
+    }
+  }
+  [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
+    if (isWhitespace(cp)) {
+      this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
+    } else if (cp === $$5.AMPERSAND) {
+      this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
+      this.state = CHARACTER_REFERENCE_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._leaveAttrValue(DATA_STATE);
+      this._emitCurrentToken();
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.QUOTATION_MARK || cp === $$5.APOSTROPHE || cp === $$5.LESS_THAN_SIGN || cp === $$5.EQUALS_SIGN || cp === $$5.GRAVE_ACCENT) {
+      this._err(ERR$1.unexpectedCharacterInUnquotedAttributeValue);
+      this.currentAttr.value += toChar(cp);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInTag);
+      this._emitEOFToken();
+    } else {
+      this.currentAttr.value += toChar(cp);
+    }
+  }
+  [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
+    if (isWhitespace(cp)) {
+      this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
+    } else if (cp === $$5.SOLIDUS) {
+      this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._leaveAttrValue(DATA_STATE);
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInTag);
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.missingWhitespaceBetweenAttributes);
+      this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
+    }
+  }
+  [SELF_CLOSING_START_TAG_STATE](cp) {
+    if (cp === $$5.GREATER_THAN_SIGN) {
+      this.currentToken.selfClosing = true;
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInTag);
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.unexpectedSolidusInTag);
+      this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
+    }
+  }
+  [BOGUS_COMMENT_STATE](cp) {
+    if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
+    } else {
+      this.currentToken.data += toChar(cp);
+    }
+  }
+  [MARKUP_DECLARATION_OPEN_STATE](cp) {
+    if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
+      this._createCommentToken();
+      this.state = COMMENT_START_STATE;
+    } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
+      this.state = DOCTYPE_STATE;
+    } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
+      if (this.allowCDATA) {
+        this.state = CDATA_SECTION_STATE;
+      } else {
+        this._err(ERR$1.cdataInHtmlContent);
+        this._createCommentToken();
+        this.currentToken.data = "[CDATA[";
+        this.state = BOGUS_COMMENT_STATE;
+      }
+    } else if (!this._ensureHibernation()) {
+      this._err(ERR$1.incorrectlyOpenedComment);
+      this._createCommentToken();
+      this._reconsumeInState(BOGUS_COMMENT_STATE);
+    }
+  }
+  [COMMENT_START_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = COMMENT_START_DASH_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.abruptClosingOfEmptyComment);
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else {
+      this._reconsumeInState(COMMENT_STATE);
+    }
+  }
+  [COMMENT_START_DASH_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = COMMENT_END_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.abruptClosingOfEmptyComment);
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInComment);
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.data += "-";
+      this._reconsumeInState(COMMENT_STATE);
+    }
+  }
+  [COMMENT_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = COMMENT_END_DASH_STATE;
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.currentToken.data += "<";
+      this.state = COMMENT_LESS_THAN_SIGN_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInComment);
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.data += toChar(cp);
+    }
+  }
+  [COMMENT_LESS_THAN_SIGN_STATE](cp) {
+    if (cp === $$5.EXCLAMATION_MARK) {
+      this.currentToken.data += "!";
+      this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
+    } else if (cp === $$5.LESS_THAN_SIGN) {
+      this.currentToken.data += "!";
+    } else {
+      this._reconsumeInState(COMMENT_STATE);
+    }
+  }
+  [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
+    } else {
+      this._reconsumeInState(COMMENT_STATE);
+    }
+  }
+  [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
+    } else {
+      this._reconsumeInState(COMMENT_END_DASH_STATE);
+    }
+  }
+  [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
+    if (cp !== $$5.GREATER_THAN_SIGN && cp !== $$5.EOF) {
+      this._err(ERR$1.nestedComment);
+    }
+    this._reconsumeInState(COMMENT_END_STATE);
+  }
+  [COMMENT_END_DASH_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.state = COMMENT_END_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInComment);
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.data += "-";
+      this._reconsumeInState(COMMENT_STATE);
+    }
+  }
+  [COMMENT_END_STATE](cp) {
+    if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EXCLAMATION_MARK) {
+      this.state = COMMENT_END_BANG_STATE;
+    } else if (cp === $$5.HYPHEN_MINUS) {
+      this.currentToken.data += "-";
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInComment);
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.data += "--";
+      this._reconsumeInState(COMMENT_STATE);
+    }
+  }
+  [COMMENT_END_BANG_STATE](cp) {
+    if (cp === $$5.HYPHEN_MINUS) {
+      this.currentToken.data += "--!";
+      this.state = COMMENT_END_DASH_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.incorrectlyClosedComment);
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInComment);
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.data += "--!";
+      this._reconsumeInState(COMMENT_STATE);
+    }
+  }
+  [DOCTYPE_STATE](cp) {
+    if (isWhitespace(cp)) {
+      this.state = BEFORE_DOCTYPE_NAME_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this._createDoctypeToken(null);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.missingWhitespaceBeforeDoctypeName);
+      this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
+    }
+  }
+  [BEFORE_DOCTYPE_NAME_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (isAsciiUpper(cp)) {
+      this._createDoctypeToken(toAsciiLowerChar(cp));
+      this.state = DOCTYPE_NAME_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this._createDoctypeToken(unicode$1.REPLACEMENT_CHARACTER);
+      this.state = DOCTYPE_NAME_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.missingDoctypeName);
+      this._createDoctypeToken(null);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this.state = DATA_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this._createDoctypeToken(null);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._createDoctypeToken(toChar(cp));
+      this.state = DOCTYPE_NAME_STATE;
+    }
+  }
+  [DOCTYPE_NAME_STATE](cp) {
+    if (isWhitespace(cp)) {
+      this.state = AFTER_DOCTYPE_NAME_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (isAsciiUpper(cp)) {
+      this.currentToken.name += toAsciiLowerChar(cp);
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentToken.name += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.name += toChar(cp);
+    }
+  }
+  [AFTER_DOCTYPE_NAME_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
+      this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
+    } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
+      this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
+    } else if (!this._ensureHibernation()) {
+      this._err(ERR$1.invalidCharacterSequenceAfterDoctypeName);
+      this.currentToken.forceQuirks = true;
+      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
+    }
+  }
+  [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
+    if (isWhitespace(cp)) {
+      this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
+    } else if (cp === $$5.QUOTATION_MARK) {
+      this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
+      this.currentToken.publicId = "";
+      this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
+    } else if (cp === $$5.APOSTROPHE) {
+      this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
+      this.currentToken.publicId = "";
+      this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.missingDoctypePublicIdentifier);
+      this.currentToken.forceQuirks = true;
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
+    }
+  }
+  [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (cp === $$5.QUOTATION_MARK) {
+      this.currentToken.publicId = "";
+      this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
+    } else if (cp === $$5.APOSTROPHE) {
+      this.currentToken.publicId = "";
+      this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.missingDoctypePublicIdentifier);
+      this.currentToken.forceQuirks = true;
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
+    }
+  }
+  [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
+    if (cp === $$5.QUOTATION_MARK) {
+      this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.abruptDoctypePublicIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this.state = DATA_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.publicId += toChar(cp);
+    }
+  }
+  [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
+    if (cp === $$5.APOSTROPHE) {
+      this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.abruptDoctypePublicIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this.state = DATA_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.publicId += toChar(cp);
+    }
+  }
+  [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
+    if (isWhitespace(cp)) {
+      this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.QUOTATION_MARK) {
+      this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
+      this.currentToken.systemId = "";
+      this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
+    } else if (cp === $$5.APOSTROPHE) {
+      this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
+      this.currentToken.systemId = "";
+      this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
+    }
+  }
+  [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (cp === $$5.GREATER_THAN_SIGN) {
+      this._emitCurrentToken();
+      this.state = DATA_STATE;
+    } else if (cp === $$5.QUOTATION_MARK) {
+      this.currentToken.systemId = "";
+      this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
+    } else if (cp === $$5.APOSTROPHE) {
+      this.currentToken.systemId = "";
+      this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
+    }
+  }
+  [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
+    if (isWhitespace(cp)) {
+      this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
+    } else if (cp === $$5.QUOTATION_MARK) {
+      this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
+      this.currentToken.systemId = "";
+      this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
+    } else if (cp === $$5.APOSTROPHE) {
+      this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
+      this.currentToken.systemId = "";
+      this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.missingDoctypeSystemIdentifier);
+      this.currentToken.forceQuirks = true;
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
+    }
+  }
+  [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (cp === $$5.QUOTATION_MARK) {
+      this.currentToken.systemId = "";
+      this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
+    } else if (cp === $$5.APOSTROPHE) {
+      this.currentToken.systemId = "";
+      this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.missingDoctypeSystemIdentifier);
+      this.currentToken.forceQuirks = true;
+      this.state = DATA_STATE;
+      this._emitCurrentToken();
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
+    }
+  }
+  [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
+    if (cp === $$5.QUOTATION_MARK) {
+      this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.abruptDoctypeSystemIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this.state = DATA_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.systemId += toChar(cp);
+    }
+  }
+  [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
+    if (cp === $$5.APOSTROPHE) {
+      this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+      this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
+    } else if (cp === $$5.GREATER_THAN_SIGN) {
+      this._err(ERR$1.abruptDoctypeSystemIdentifier);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this.state = DATA_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this.currentToken.systemId += toChar(cp);
+    }
+  }
+  [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
+    if (isWhitespace(cp)) {
+      return;
+    }
+    if (cp === $$5.GREATER_THAN_SIGN) {
+      this._emitCurrentToken();
+      this.state = DATA_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInDoctype);
+      this.currentToken.forceQuirks = true;
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    } else {
+      this._err(ERR$1.unexpectedCharacterAfterDoctypeSystemIdentifier);
+      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
+    }
+  }
+  [BOGUS_DOCTYPE_STATE](cp) {
+    if (cp === $$5.GREATER_THAN_SIGN) {
+      this._emitCurrentToken();
+      this.state = DATA_STATE;
+    } else if (cp === $$5.NULL) {
+      this._err(ERR$1.unexpectedNullCharacter);
+    } else if (cp === $$5.EOF) {
+      this._emitCurrentToken();
+      this._emitEOFToken();
+    }
+  }
+  [CDATA_SECTION_STATE](cp) {
+    if (cp === $$5.RIGHT_SQUARE_BRACKET) {
+      this.state = CDATA_SECTION_BRACKET_STATE;
+    } else if (cp === $$5.EOF) {
+      this._err(ERR$1.eofInCdata);
+      this._emitEOFToken();
+    } else {
+      this._emitCodePoint(cp);
+    }
+  }
+  [CDATA_SECTION_BRACKET_STATE](cp) {
+    if (cp === $$5.RIGHT_SQUARE_BRACKET) {
+      this.state = CDATA_SECTION_END_STATE;
+    } else {
+      this._emitChars("]");
+      this._reconsumeInState(CDATA_SECTION_STATE);
+    }
+  }
+  [CDATA_SECTION_END_STATE](cp) {
+    if (cp === $$5.GREATER_THAN_SIGN) {
+      this.state = DATA_STATE;
+    } else if (cp === $$5.RIGHT_SQUARE_BRACKET) {
+      this._emitChars("]");
+    } else {
+      this._emitChars("]]");
+      this._reconsumeInState(CDATA_SECTION_STATE);
+    }
+  }
+  [CHARACTER_REFERENCE_STATE](cp) {
+    this.tempBuff = [$$5.AMPERSAND];
+    if (cp === $$5.NUMBER_SIGN) {
+      this.tempBuff.push(cp);
+      this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
+    } else if (isAsciiAlphaNumeric(cp)) {
+      this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
+    } else {
+      this._flushCodePointsConsumedAsCharacterReference();
+      this._reconsumeInState(this.returnState);
+    }
+  }
+  [NAMED_CHARACTER_REFERENCE_STATE](cp) {
+    const matchResult = this._matchNamedCharacterReference(cp);
+    if (this._ensureHibernation()) {
+      this.tempBuff = [$$5.AMPERSAND];
+    } else if (matchResult) {
+      const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $$5.SEMICOLON;
+      if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
+        if (!withSemicolon) {
+          this._errOnNextCodePoint(ERR$1.missingSemicolonAfterCharacterReference);
+        }
+        this.tempBuff = matchResult;
+      }
+      this._flushCodePointsConsumedAsCharacterReference();
+      this.state = this.returnState;
+    } else {
+      this._flushCodePointsConsumedAsCharacterReference();
+      this.state = AMBIGUOUS_AMPERSAND_STATE;
+    }
+  }
+  [AMBIGUOUS_AMPERSAND_STATE](cp) {
+    if (isAsciiAlphaNumeric(cp)) {
+      if (this._isCharacterReferenceInAttribute()) {
+        this.currentAttr.value += toChar(cp);
+      } else {
+        this._emitCodePoint(cp);
+      }
+    } else {
+      if (cp === $$5.SEMICOLON) {
+        this._err(ERR$1.unknownNamedCharacterReference);
+      }
+      this._reconsumeInState(this.returnState);
+    }
+  }
+  [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
+    this.charRefCode = 0;
+    if (cp === $$5.LATIN_SMALL_X || cp === $$5.LATIN_CAPITAL_X) {
+      this.tempBuff.push(cp);
+      this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
+    } else {
+      this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
+    }
+  }
+  [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
+    if (isAsciiHexDigit(cp)) {
+      this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
+    } else {
+      this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
+      this._flushCodePointsConsumedAsCharacterReference();
+      this._reconsumeInState(this.returnState);
+    }
+  }
+  [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
+    if (isAsciiDigit(cp)) {
+      this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
+    } else {
+      this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
+      this._flushCodePointsConsumedAsCharacterReference();
+      this._reconsumeInState(this.returnState);
+    }
+  }
+  [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
+    if (isAsciiUpperHexDigit(cp)) {
+      this.charRefCode = this.charRefCode * 16 + cp - 55;
+    } else if (isAsciiLowerHexDigit(cp)) {
+      this.charRefCode = this.charRefCode * 16 + cp - 87;
+    } else if (isAsciiDigit(cp)) {
+      this.charRefCode = this.charRefCode * 16 + cp - 48;
+    } else if (cp === $$5.SEMICOLON) {
+      this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
+    } else {
+      this._err(ERR$1.missingSemicolonAfterCharacterReference);
+      this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
+    }
+  }
+  [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
+    if (isAsciiDigit(cp)) {
+      this.charRefCode = this.charRefCode * 10 + cp - 48;
+    } else if (cp === $$5.SEMICOLON) {
+      this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
+    } else {
+      this._err(ERR$1.missingSemicolonAfterCharacterReference);
+      this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
+    }
+  }
+  [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
+    if (this.charRefCode === $$5.NULL) {
+      this._err(ERR$1.nullCharacterReference);
+      this.charRefCode = $$5.REPLACEMENT_CHARACTER;
+    } else if (this.charRefCode > 1114111) {
+      this._err(ERR$1.characterReferenceOutsideUnicodeRange);
+      this.charRefCode = $$5.REPLACEMENT_CHARACTER;
+    } else if (unicode$1.isSurrogate(this.charRefCode)) {
+      this._err(ERR$1.surrogateCharacterReference);
+      this.charRefCode = $$5.REPLACEMENT_CHARACTER;
+    } else if (unicode$1.isUndefinedCodePoint(this.charRefCode)) {
+      this._err(ERR$1.noncharacterCharacterReference);
+    } else if (unicode$1.isControlCodePoint(this.charRefCode) || this.charRefCode === $$5.CARRIAGE_RETURN) {
+      this._err(ERR$1.controlCharacterReference);
+      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];
+      if (replacement) {
+        this.charRefCode = replacement;
+      }
+    }
+    this.tempBuff = [this.charRefCode];
+    this._flushCodePointsConsumedAsCharacterReference();
+    this._reconsumeInState(this.returnState);
+  }
+};
+Tokenizer$4.CHARACTER_TOKEN = "CHARACTER_TOKEN";
+Tokenizer$4.NULL_CHARACTER_TOKEN = "NULL_CHARACTER_TOKEN";
+Tokenizer$4.WHITESPACE_CHARACTER_TOKEN = "WHITESPACE_CHARACTER_TOKEN";
+Tokenizer$4.START_TAG_TOKEN = "START_TAG_TOKEN";
+Tokenizer$4.END_TAG_TOKEN = "END_TAG_TOKEN";
+Tokenizer$4.COMMENT_TOKEN = "COMMENT_TOKEN";
+Tokenizer$4.DOCTYPE_TOKEN = "DOCTYPE_TOKEN";
+Tokenizer$4.EOF_TOKEN = "EOF_TOKEN";
+Tokenizer$4.HIBERNATION_TOKEN = "HIBERNATION_TOKEN";
+Tokenizer$4.MODE = {
+  DATA: DATA_STATE,
+  RCDATA: RCDATA_STATE,
+  RAWTEXT: RAWTEXT_STATE,
+  SCRIPT_DATA: SCRIPT_DATA_STATE,
+  PLAINTEXT: PLAINTEXT_STATE
+};
+Tokenizer$4.getTokenAttr = function(token, attrName) {
+  for (let i = token.attrs.length - 1; i >= 0; i--) {
+    if (token.attrs[i].name === attrName) {
+      return token.attrs[i].value;
+    }
+  }
+  return null;
+};
+var tokenizer2 = Tokenizer$4;
+var html$2 = {};
+var NS$3 = html$2.NAMESPACES = {
+  HTML: "http://www.w3.org/1999/xhtml",
+  MATHML: "http://www.w3.org/1998/Math/MathML",
+  SVG: "http://www.w3.org/2000/svg",
+  XLINK: "http://www.w3.org/1999/xlink",
+  XML: "http://www.w3.org/XML/1998/namespace",
+  XMLNS: "http://www.w3.org/2000/xmlns/"
+};
+html$2.ATTRS = {
+  TYPE: "type",
+  ACTION: "action",
+  ENCODING: "encoding",
+  PROMPT: "prompt",
+  NAME: "name",
+  COLOR: "color",
+  FACE: "face",
+  SIZE: "size"
+};
+html$2.DOCUMENT_MODE = {
+  NO_QUIRKS: "no-quirks",
+  QUIRKS: "quirks",
+  LIMITED_QUIRKS: "limited-quirks"
+};
+var $$4 = html$2.TAG_NAMES = {
+  A: "a",
+  ADDRESS: "address",
+  ANNOTATION_XML: "annotation-xml",
+  APPLET: "applet",
+  AREA: "area",
+  ARTICLE: "article",
+  ASIDE: "aside",
+  B: "b",
+  BASE: "base",
+  BASEFONT: "basefont",
+  BGSOUND: "bgsound",
+  BIG: "big",
+  BLOCKQUOTE: "blockquote",
+  BODY: "body",
+  BR: "br",
+  BUTTON: "button",
+  CAPTION: "caption",
+  CENTER: "center",
+  CODE: "code",
+  COL: "col",
+  COLGROUP: "colgroup",
+  DD: "dd",
+  DESC: "desc",
+  DETAILS: "details",
+  DIALOG: "dialog",
+  DIR: "dir",
+  DIV: "div",
+  DL: "dl",
+  DT: "dt",
+  EM: "em",
+  EMBED: "embed",
+  FIELDSET: "fieldset",
+  FIGCAPTION: "figcaption",
+  FIGURE: "figure",
+  FONT: "font",
+  FOOTER: "footer",
+  FOREIGN_OBJECT: "foreignObject",
+  FORM: "form",
+  FRAME: "frame",
+  FRAMESET: "frameset",
+  H1: "h1",
+  H2: "h2",
+  H3: "h3",
+  H4: "h4",
+  H5: "h5",
+  H6: "h6",
+  HEAD: "head",
+  HEADER: "header",
+  HGROUP: "hgroup",
+  HR: "hr",
+  HTML: "html",
+  I: "i",
+  IMG: "img",
+  IMAGE: "image",
+  INPUT: "input",
+  IFRAME: "iframe",
+  KEYGEN: "keygen",
+  LABEL: "label",
+  LI: "li",
+  LINK: "link",
+  LISTING: "listing",
+  MAIN: "main",
+  MALIGNMARK: "malignmark",
+  MARQUEE: "marquee",
+  MATH: "math",
+  MENU: "menu",
+  META: "meta",
+  MGLYPH: "mglyph",
+  MI: "mi",
+  MO: "mo",
+  MN: "mn",
+  MS: "ms",
+  MTEXT: "mtext",
+  NAV: "nav",
+  NOBR: "nobr",
+  NOFRAMES: "noframes",
+  NOEMBED: "noembed",
+  NOSCRIPT: "noscript",
+  OBJECT: "object",
+  OL: "ol",
+  OPTGROUP: "optgroup",
+  OPTION: "option",
+  P: "p",
+  PARAM: "param",
+  PLAINTEXT: "plaintext",
+  PRE: "pre",
+  RB: "rb",
+  RP: "rp",
+  RT: "rt",
+  RTC: "rtc",
+  RUBY: "ruby",
+  S: "s",
+  SCRIPT: "script",
+  SECTION: "section",
+  SELECT: "select",
+  SOURCE: "source",
+  SMALL: "small",
+  SPAN: "span",
+  STRIKE: "strike",
+  STRONG: "strong",
+  STYLE: "style",
+  SUB: "sub",
+  SUMMARY: "summary",
+  SUP: "sup",
+  TABLE: "table",
+  TBODY: "tbody",
+  TEMPLATE: "template",
+  TEXTAREA: "textarea",
+  TFOOT: "tfoot",
+  TD: "td",
+  TH: "th",
+  THEAD: "thead",
+  TITLE: "title",
+  TR: "tr",
+  TRACK: "track",
+  TT: "tt",
+  U: "u",
+  UL: "ul",
+  SVG: "svg",
+  VAR: "var",
+  WBR: "wbr",
+  XMP: "xmp"
+};
+html$2.SPECIAL_ELEMENTS = {
+  [NS$3.HTML]: {
+    [$$4.ADDRESS]: true,
+    [$$4.APPLET]: true,
+    [$$4.AREA]: true,
+    [$$4.ARTICLE]: true,
+    [$$4.ASIDE]: true,
+    [$$4.BASE]: true,
+    [$$4.BASEFONT]: true,
+    [$$4.BGSOUND]: true,
+    [$$4.BLOCKQUOTE]: true,
+    [$$4.BODY]: true,
+    [$$4.BR]: true,
+    [$$4.BUTTON]: true,
+    [$$4.CAPTION]: true,
+    [$$4.CENTER]: true,
+    [$$4.COL]: true,
+    [$$4.COLGROUP]: true,
+    [$$4.DD]: true,
+    [$$4.DETAILS]: true,
+    [$$4.DIR]: true,
+    [$$4.DIV]: true,
+    [$$4.DL]: true,
+    [$$4.DT]: true,
+    [$$4.EMBED]: true,
+    [$$4.FIELDSET]: true,
+    [$$4.FIGCAPTION]: true,
+    [$$4.FIGURE]: true,
+    [$$4.FOOTER]: true,
+    [$$4.FORM]: true,
+    [$$4.FRAME]: true,
+    [$$4.FRAMESET]: true,
+    [$$4.H1]: true,
+    [$$4.H2]: true,
+    [$$4.H3]: true,
+    [$$4.H4]: true,
+    [$$4.H5]: true,
+    [$$4.H6]: true,
+    [$$4.HEAD]: true,
+    [$$4.HEADER]: true,
+    [$$4.HGROUP]: true,
+    [$$4.HR]: true,
+    [$$4.HTML]: true,
+    [$$4.IFRAME]: true,
+    [$$4.IMG]: true,
+    [$$4.INPUT]: true,
+    [$$4.LI]: true,
+    [$$4.LINK]: true,
+    [$$4.LISTING]: true,
+    [$$4.MAIN]: true,
+    [$$4.MARQUEE]: true,
+    [$$4.MENU]: true,
+    [$$4.META]: true,
+    [$$4.NAV]: true,
+    [$$4.NOEMBED]: true,
+    [$$4.NOFRAMES]: true,
+    [$$4.NOSCRIPT]: true,
+    [$$4.OBJECT]: true,
+    [$$4.OL]: true,
+    [$$4.P]: true,
+    [$$4.PARAM]: true,
+    [$$4.PLAINTEXT]: true,
+    [$$4.PRE]: true,
+    [$$4.SCRIPT]: true,
+    [$$4.SECTION]: true,
+    [$$4.SELECT]: true,
+    [$$4.SOURCE]: true,
+    [$$4.STYLE]: true,
+    [$$4.SUMMARY]: true,
+    [$$4.TABLE]: true,
+    [$$4.TBODY]: true,
+    [$$4.TD]: true,
+    [$$4.TEMPLATE]: true,
+    [$$4.TEXTAREA]: true,
+    [$$4.TFOOT]: true,
+    [$$4.TH]: true,
+    [$$4.THEAD]: true,
+    [$$4.TITLE]: true,
+    [$$4.TR]: true,
+    [$$4.TRACK]: true,
+    [$$4.UL]: true,
+    [$$4.WBR]: true,
+    [$$4.XMP]: true
+  },
+  [NS$3.MATHML]: {
+    [$$4.MI]: true,
+    [$$4.MO]: true,
+    [$$4.MN]: true,
+    [$$4.MS]: true,
+    [$$4.MTEXT]: true,
+    [$$4.ANNOTATION_XML]: true
+  },
+  [NS$3.SVG]: {
+    [$$4.TITLE]: true,
+    [$$4.FOREIGN_OBJECT]: true,
+    [$$4.DESC]: true
+  }
+};
+var HTML$3 = html$2;
+var $$3 = HTML$3.TAG_NAMES;
+var NS$2 = HTML$3.NAMESPACES;
+function isImpliedEndTagRequired(tn) {
+  switch (tn.length) {
+    case 1:
+      return tn === $$3.P;
+    case 2:
+      return tn === $$3.RB || tn === $$3.RP || tn === $$3.RT || tn === $$3.DD || tn === $$3.DT || tn === $$3.LI;
+    case 3:
+      return tn === $$3.RTC;
+    case 6:
+      return tn === $$3.OPTION;
+    case 8:
+      return tn === $$3.OPTGROUP;
+  }
+  return false;
+}
+function isImpliedEndTagRequiredThoroughly(tn) {
+  switch (tn.length) {
+    case 1:
+      return tn === $$3.P;
+    case 2:
+      return tn === $$3.RB || tn === $$3.RP || tn === $$3.RT || tn === $$3.DD || tn === $$3.DT || tn === $$3.LI || tn === $$3.TD || tn === $$3.TH || tn === $$3.TR;
+    case 3:
+      return tn === $$3.RTC;
+    case 5:
+      return tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD;
+    case 6:
+      return tn === $$3.OPTION;
+    case 7:
+      return tn === $$3.CAPTION;
+    case 8:
+      return tn === $$3.OPTGROUP || tn === $$3.COLGROUP;
+  }
+  return false;
+}
+function isScopingElement(tn, ns) {
+  switch (tn.length) {
+    case 2:
+      if (tn === $$3.TD || tn === $$3.TH) {
+        return ns === NS$2.HTML;
+      } else if (tn === $$3.MI || tn === $$3.MO || tn === $$3.MN || tn === $$3.MS) {
+        return ns === NS$2.MATHML;
+      }
+      break;
+    case 4:
+      if (tn === $$3.HTML) {
+        return ns === NS$2.HTML;
+      } else if (tn === $$3.DESC) {
+        return ns === NS$2.SVG;
+      }
+      break;
+    case 5:
+      if (tn === $$3.TABLE) {
+        return ns === NS$2.HTML;
+      } else if (tn === $$3.MTEXT) {
+        return ns === NS$2.MATHML;
+      } else if (tn === $$3.TITLE) {
+        return ns === NS$2.SVG;
+      }
+      break;
+    case 6:
+      return (tn === $$3.APPLET || tn === $$3.OBJECT) && ns === NS$2.HTML;
+    case 7:
+      return (tn === $$3.CAPTION || tn === $$3.MARQUEE) && ns === NS$2.HTML;
+    case 8:
+      return tn === $$3.TEMPLATE && ns === NS$2.HTML;
+    case 13:
+      return tn === $$3.FOREIGN_OBJECT && ns === NS$2.SVG;
+    case 14:
+      return tn === $$3.ANNOTATION_XML && ns === NS$2.MATHML;
+  }
+  return false;
+}
+var OpenElementStack$1 = class {
+  constructor(document4, treeAdapter) {
+    this.stackTop = -1;
+    this.items = [];
+    this.current = document4;
+    this.currentTagName = null;
+    this.currentTmplContent = null;
+    this.tmplCount = 0;
+    this.treeAdapter = treeAdapter;
+  }
+  _indexOf(element3) {
+    let idx = -1;
+    for (let i = this.stackTop; i >= 0; i--) {
+      if (this.items[i] === element3) {
+        idx = i;
+        break;
+      }
+    }
+    return idx;
+  }
+  _isInTemplate() {
+    return this.currentTagName === $$3.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS$2.HTML;
+  }
+  _updateCurrentElement() {
+    this.current = this.items[this.stackTop];
+    this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);
+    this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
+  }
+  push(element3) {
+    this.items[++this.stackTop] = element3;
+    this._updateCurrentElement();
+    if (this._isInTemplate()) {
+      this.tmplCount++;
+    }
+  }
+  pop() {
+    this.stackTop--;
+    if (this.tmplCount > 0 && this._isInTemplate()) {
+      this.tmplCount--;
+    }
+    this._updateCurrentElement();
+  }
+  replace(oldElement, newElement) {
+    const idx = this._indexOf(oldElement);
+    this.items[idx] = newElement;
+    if (idx === this.stackTop) {
+      this._updateCurrentElement();
+    }
+  }
+  insertAfter(referenceElement, newElement) {
+    const insertionIdx = this._indexOf(referenceElement) + 1;
+    this.items.splice(insertionIdx, 0, newElement);
+    if (insertionIdx === ++this.stackTop) {
+      this._updateCurrentElement();
+    }
+  }
+  popUntilTagNamePopped(tagName) {
+    while (this.stackTop > -1) {
+      const tn = this.currentTagName;
+      const ns = this.treeAdapter.getNamespaceURI(this.current);
+      this.pop();
+      if (tn === tagName && ns === NS$2.HTML) {
+        break;
+      }
+    }
+  }
+  popUntilElementPopped(element3) {
+    while (this.stackTop > -1) {
+      const poppedElement = this.current;
+      this.pop();
+      if (poppedElement === element3) {
+        break;
+      }
+    }
+  }
+  popUntilNumberedHeaderPopped() {
+    while (this.stackTop > -1) {
+      const tn = this.currentTagName;
+      const ns = this.treeAdapter.getNamespaceURI(this.current);
+      this.pop();
+      if (tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6 && ns === NS$2.HTML) {
+        break;
+      }
+    }
+  }
+  popUntilTableCellPopped() {
+    while (this.stackTop > -1) {
+      const tn = this.currentTagName;
+      const ns = this.treeAdapter.getNamespaceURI(this.current);
+      this.pop();
+      if (tn === $$3.TD || tn === $$3.TH && ns === NS$2.HTML) {
+        break;
+      }
+    }
+  }
+  popAllUpToHtmlElement() {
+    this.stackTop = 0;
+    this._updateCurrentElement();
+  }
+  clearBackToTableContext() {
+    while (this.currentTagName !== $$3.TABLE && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
+      this.pop();
+    }
+  }
+  clearBackToTableBodyContext() {
+    while (this.currentTagName !== $$3.TBODY && this.currentTagName !== $$3.TFOOT && this.currentTagName !== $$3.THEAD && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
+      this.pop();
+    }
+  }
+  clearBackToTableRowContext() {
+    while (this.currentTagName !== $$3.TR && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
+      this.pop();
+    }
+  }
+  remove(element3) {
+    for (let i = this.stackTop; i >= 0; i--) {
+      if (this.items[i] === element3) {
+        this.items.splice(i, 1);
+        this.stackTop--;
+        this._updateCurrentElement();
+        break;
+      }
+    }
+  }
+  tryPeekProperlyNestedBodyElement() {
+    const element3 = this.items[1];
+    return element3 && this.treeAdapter.getTagName(element3) === $$3.BODY ? element3 : null;
+  }
+  contains(element3) {
+    return this._indexOf(element3) > -1;
+  }
+  getCommonAncestor(element3) {
+    let elementIdx = this._indexOf(element3);
+    return --elementIdx >= 0 ? this.items[elementIdx] : null;
+  }
+  isRootHtmlElementCurrent() {
+    return this.stackTop === 0 && this.currentTagName === $$3.HTML;
+  }
+  hasInScope(tagName) {
+    for (let i = this.stackTop; i >= 0; i--) {
+      const tn = this.treeAdapter.getTagName(this.items[i]);
+      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
+      if (tn === tagName && ns === NS$2.HTML) {
+        return true;
+      }
+      if (isScopingElement(tn, ns)) {
+        return false;
+      }
+    }
+    return true;
+  }
+  hasNumberedHeaderInScope() {
+    for (let i = this.stackTop; i >= 0; i--) {
+      const tn = this.treeAdapter.getTagName(this.items[i]);
+      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
+      if ((tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6) && ns === NS$2.HTML) {
+        return true;
+      }
+      if (isScopingElement(tn, ns)) {
+        return false;
+      }
+    }
+    return true;
+  }
+  hasInListItemScope(tagName) {
+    for (let i = this.stackTop; i >= 0; i--) {
+      const tn = this.treeAdapter.getTagName(this.items[i]);
+      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
+      if (tn === tagName && ns === NS$2.HTML) {
+        return true;
+      }
+      if ((tn === $$3.UL || tn === $$3.OL) && ns === NS$2.HTML || isScopingElement(tn, ns)) {
+        return false;
+      }
+    }
+    return true;
+  }
+  hasInButtonScope(tagName) {
+    for (let i = this.stackTop; i >= 0; i--) {
+      const tn = this.treeAdapter.getTagName(this.items[i]);
+      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
+      if (tn === tagName && ns === NS$2.HTML) {
+        return true;
+      }
+      if (tn === $$3.BUTTON && ns === NS$2.HTML || isScopingElement(tn, ns)) {
+        return false;
+      }
+    }
+    return true;
+  }
+  hasInTableScope(tagName) {
+    for (let i = this.stackTop; i >= 0; i--) {
+      const tn = this.treeAdapter.getTagName(this.items[i]);
+      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
+      if (ns !== NS$2.HTML) {
+        continue;
+      }
+      if (tn === tagName) {
+        return true;
+      }
+      if (tn === $$3.TABLE || tn === $$3.TEMPLATE || tn === $$3.HTML) {
+        return false;
+      }
+    }
+    return true;
+  }
+  hasTableBodyContextInTableScope() {
+    for (let i = this.stackTop; i >= 0; i--) {
+      const tn = this.treeAdapter.getTagName(this.items[i]);
+      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
+      if (ns !== NS$2.HTML) {
+        continue;
+      }
+      if (tn === $$3.TBODY || tn === $$3.THEAD || tn === $$3.TFOOT) {
+        return true;
+      }
+      if (tn === $$3.TABLE || tn === $$3.HTML) {
+        return false;
+      }
+    }
+    return true;
+  }
+  hasInSelectScope(tagName) {
+    for (let i = this.stackTop; i >= 0; i--) {
+      const tn = this.treeAdapter.getTagName(this.items[i]);
+      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
+      if (ns !== NS$2.HTML) {
+        continue;
+      }
+      if (tn === tagName) {
+        return true;
+      }
+      if (tn !== $$3.OPTION && tn !== $$3.OPTGROUP) {
+        return false;
+      }
+    }
+    return true;
+  }
+  generateImpliedEndTags() {
+    while (isImpliedEndTagRequired(this.currentTagName)) {
+      this.pop();
+    }
+  }
+  generateImpliedEndTagsThoroughly() {
+    while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
+      this.pop();
+    }
+  }
+  generateImpliedEndTagsWithExclusion(exclusionTagName) {
+    while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
+      this.pop();
+    }
+  }
+};
+var openElementStack = OpenElementStack$1;
+var NOAH_ARK_CAPACITY = 3;
+var FormattingElementList$1 = class {
+  constructor(treeAdapter) {
+    this.length = 0;
+    this.entries = [];
+    this.treeAdapter = treeAdapter;
+    this.bookmark = null;
+  }
+  _getNoahArkConditionCandidates(newElement) {
+    const candidates = [];
+    if (this.length >= NOAH_ARK_CAPACITY) {
+      const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
+      const neTagName = this.treeAdapter.getTagName(newElement);
+      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
+      for (let i = this.length - 1; i >= 0; i--) {
+        const entry = this.entries[i];
+        if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
+          break;
+        }
+        const element3 = entry.element;
+        const elementAttrs = this.treeAdapter.getAttrList(element3);
+        const isCandidate = this.treeAdapter.getTagName(element3) === neTagName && this.treeAdapter.getNamespaceURI(element3) === neNamespaceURI && elementAttrs.length === neAttrsLength;
+        if (isCandidate) {
+          candidates.push({ idx: i, attrs: elementAttrs });
+        }
+      }
+    }
+    return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
+  }
+  _ensureNoahArkCondition(newElement) {
+    const candidates = this._getNoahArkConditionCandidates(newElement);
+    let cLength = candidates.length;
+    if (cLength) {
+      const neAttrs = this.treeAdapter.getAttrList(newElement);
+      const neAttrsLength = neAttrs.length;
+      const neAttrsMap = /* @__PURE__ */ Object.create(null);
+      for (let i = 0; i < neAttrsLength; i++) {
+        const neAttr = neAttrs[i];
+        neAttrsMap[neAttr.name] = neAttr.value;
+      }
+      for (let i = 0; i < neAttrsLength; i++) {
+        for (let j = 0; j < cLength; j++) {
+          const cAttr = candidates[j].attrs[i];
+          if (neAttrsMap[cAttr.name] !== cAttr.value) {
+            candidates.splice(j, 1);
+            cLength--;
+          }
+          if (candidates.length < NOAH_ARK_CAPACITY) {
+            return;
+          }
+        }
+      }
+      for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
+        this.entries.splice(candidates[i].idx, 1);
+        this.length--;
+      }
+    }
+  }
+  insertMarker() {
+    this.entries.push({ type: FormattingElementList$1.MARKER_ENTRY });
+    this.length++;
+  }
+  pushElement(element3, token) {
+    this._ensureNoahArkCondition(element3);
+    this.entries.push({
+      type: FormattingElementList$1.ELEMENT_ENTRY,
+      element: element3,
+      token
+    });
+    this.length++;
+  }
+  insertElementAfterBookmark(element3, token) {
+    let bookmarkIdx = this.length - 1;
+    for (; bookmarkIdx >= 0; bookmarkIdx--) {
+      if (this.entries[bookmarkIdx] === this.bookmark) {
+        break;
+      }
+    }
+    this.entries.splice(bookmarkIdx + 1, 0, {
+      type: FormattingElementList$1.ELEMENT_ENTRY,
+      element: element3,
+      token
+    });
+    this.length++;
+  }
+  removeEntry(entry) {
+    for (let i = this.length - 1; i >= 0; i--) {
+      if (this.entries[i] === entry) {
+        this.entries.splice(i, 1);
+        this.length--;
+        break;
+      }
+    }
+  }
+  clearToLastMarker() {
+    while (this.length) {
+      const entry = this.entries.pop();
+      this.length--;
+      if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
+        break;
+      }
+    }
+  }
+  getElementEntryInScopeWithTagName(tagName) {
+    for (let i = this.length - 1; i >= 0; i--) {
+      const entry = this.entries[i];
+      if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
+        return null;
+      }
+      if (this.treeAdapter.getTagName(entry.element) === tagName) {
+        return entry;
+      }
+    }
+    return null;
+  }
+  getElementEntry(element3) {
+    for (let i = this.length - 1; i >= 0; i--) {
+      const entry = this.entries[i];
+      if (entry.type === FormattingElementList$1.ELEMENT_ENTRY && entry.element === element3) {
+        return entry;
+      }
+    }
+    return null;
+  }
+};
+FormattingElementList$1.MARKER_ENTRY = "MARKER_ENTRY";
+FormattingElementList$1.ELEMENT_ENTRY = "ELEMENT_ENTRY";
+var formattingElementList = FormattingElementList$1;
+var Mixin$9 = class {
+  constructor(host) {
+    const originalMethods = {};
+    const overriddenMethods = this._getOverriddenMethods(this, originalMethods);
+    for (const key of Object.keys(overriddenMethods)) {
+      if (typeof overriddenMethods[key] === "function") {
+        originalMethods[key] = host[key];
+        host[key] = overriddenMethods[key];
+      }
+    }
+  }
+  _getOverriddenMethods() {
+    throw new Error("Not implemented");
+  }
+};
+Mixin$9.install = function(host, Ctor, opts) {
+  if (!host.__mixins) {
+    host.__mixins = [];
+  }
+  for (let i = 0; i < host.__mixins.length; i++) {
+    if (host.__mixins[i].constructor === Ctor) {
+      return host.__mixins[i];
+    }
+  }
+  const mixin2 = new Ctor(host, opts);
+  host.__mixins.push(mixin2);
+  return mixin2;
+};
+var mixin = Mixin$9;
+var Mixin$8 = mixin;
+var PositionTrackingPreprocessorMixin$2 = class extends Mixin$8 {
+  constructor(preprocessor2) {
+    super(preprocessor2);
+    this.preprocessor = preprocessor2;
+    this.isEol = false;
+    this.lineStartPos = 0;
+    this.droppedBufferSize = 0;
+    this.offset = 0;
+    this.col = 0;
+    this.line = 1;
+  }
+  _getOverriddenMethods(mxn, orig) {
+    return {
+      advance() {
+        const pos = this.pos + 1;
+        const ch = this.html[pos];
+        if (mxn.isEol) {
+          mxn.isEol = false;
+          mxn.line++;
+          mxn.lineStartPos = pos;
+        }
+        if (ch === "\n" || ch === "\r" && this.html[pos + 1] !== "\n") {
+          mxn.isEol = true;
+        }
+        mxn.col = pos - mxn.lineStartPos + 1;
+        mxn.offset = mxn.droppedBufferSize + pos;
+        return orig.advance.call(this);
+      },
+      retreat() {
+        orig.retreat.call(this);
+        mxn.isEol = false;
+        mxn.col = this.pos - mxn.lineStartPos + 1;
+      },
+      dropParsedChunk() {
+        const prevPos = this.pos;
+        orig.dropParsedChunk.call(this);
+        const reduction = prevPos - this.pos;
+        mxn.lineStartPos -= reduction;
+        mxn.droppedBufferSize += reduction;
+        mxn.offset = mxn.droppedBufferSize + this.pos;
+      }
+    };
+  }
+};
+var preprocessorMixin$1 = PositionTrackingPreprocessorMixin$2;
+var Mixin$7 = mixin;
+var Tokenizer$3 = tokenizer2;
+var PositionTrackingPreprocessorMixin$1 = preprocessorMixin$1;
+var LocationInfoTokenizerMixin$2 = class extends Mixin$7 {
+  constructor(tokenizer3) {
+    super(tokenizer3);
+    this.tokenizer = tokenizer3;
+    this.posTracker = Mixin$7.install(tokenizer3.preprocessor, PositionTrackingPreprocessorMixin$1);
+    this.currentAttrLocation = null;
+    this.ctLoc = null;
+  }
+  _getCurrentLocation() {
+    return {
+      startLine: this.posTracker.line,
+      startCol: this.posTracker.col,
+      startOffset: this.posTracker.offset,
+      endLine: -1,
+      endCol: -1,
+      endOffset: -1
+    };
+  }
+  _attachCurrentAttrLocationInfo() {
+    this.currentAttrLocation.endLine = this.posTracker.line;
+    this.currentAttrLocation.endCol = this.posTracker.col;
+    this.currentAttrLocation.endOffset = this.posTracker.offset;
+    const currentToken = this.tokenizer.currentToken;
+    const currentAttr = this.tokenizer.currentAttr;
+    if (!currentToken.location.attrs) {
+      currentToken.location.attrs = /* @__PURE__ */ Object.create(null);
+    }
+    currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
+  }
+  _getOverriddenMethods(mxn, orig) {
+    const methods = {
+      _createStartTagToken() {
+        orig._createStartTagToken.call(this);
+        this.currentToken.location = mxn.ctLoc;
+      },
+      _createEndTagToken() {
+        orig._createEndTagToken.call(this);
+        this.currentToken.location = mxn.ctLoc;
+      },
+      _createCommentToken() {
+        orig._createCommentToken.call(this);
+        this.currentToken.location = mxn.ctLoc;
+      },
+      _createDoctypeToken(initialName) {
+        orig._createDoctypeToken.call(this, initialName);
+        this.currentToken.location = mxn.ctLoc;
+      },
+      _createCharacterToken(type2, ch) {
+        orig._createCharacterToken.call(this, type2, ch);
+        this.currentCharacterToken.location = mxn.ctLoc;
+      },
+      _createEOFToken() {
+        orig._createEOFToken.call(this);
+        this.currentToken.location = mxn._getCurrentLocation();
+      },
+      _createAttr(attrNameFirstCh) {
+        orig._createAttr.call(this, attrNameFirstCh);
+        mxn.currentAttrLocation = mxn._getCurrentLocation();
+      },
+      _leaveAttrName(toState) {
+        orig._leaveAttrName.call(this, toState);
+        mxn._attachCurrentAttrLocationInfo();
+      },
+      _leaveAttrValue(toState) {
+        orig._leaveAttrValue.call(this, toState);
+        mxn._attachCurrentAttrLocationInfo();
+      },
+      _emitCurrentToken() {
+        const ctLoc = this.currentToken.location;
+        if (this.currentCharacterToken) {
+          this.currentCharacterToken.location.endLine = ctLoc.startLine;
+          this.currentCharacterToken.location.endCol = ctLoc.startCol;
+          this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
+        }
+        if (this.currentToken.type === Tokenizer$3.EOF_TOKEN) {
+          ctLoc.endLine = ctLoc.startLine;
+          ctLoc.endCol = ctLoc.startCol;
+          ctLoc.endOffset = ctLoc.startOffset;
+        } else {
+          ctLoc.endLine = mxn.posTracker.line;
+          ctLoc.endCol = mxn.posTracker.col + 1;
+          ctLoc.endOffset = mxn.posTracker.offset + 1;
+        }
+        orig._emitCurrentToken.call(this);
+      },
+      _emitCurrentCharacterToken() {
+        const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;
+        if (ctLoc && ctLoc.endOffset === -1) {
+          ctLoc.endLine = mxn.posTracker.line;
+          ctLoc.endCol = mxn.posTracker.col;
+          ctLoc.endOffset = mxn.posTracker.offset;
+        }
+        orig._emitCurrentCharacterToken.call(this);
+      }
+    };
+    Object.keys(Tokenizer$3.MODE).forEach((modeName) => {
+      const state = Tokenizer$3.MODE[modeName];
+      methods[state] = function(cp) {
+        mxn.ctLoc = mxn._getCurrentLocation();
+        orig[state].call(this, cp);
+      };
+    });
+    return methods;
+  }
+};
+var tokenizerMixin$1 = LocationInfoTokenizerMixin$2;
+var Mixin$6 = mixin;
+var LocationInfoOpenElementStackMixin$1 = class extends Mixin$6 {
+  constructor(stack, opts) {
+    super(stack);
+    this.onItemPop = opts.onItemPop;
+  }
+  _getOverriddenMethods(mxn, orig) {
+    return {
+      pop() {
+        mxn.onItemPop(this.current);
+        orig.pop.call(this);
+      },
+      popAllUpToHtmlElement() {
+        for (let i = this.stackTop; i > 0; i--) {
+          mxn.onItemPop(this.items[i]);
+        }
+        orig.popAllUpToHtmlElement.call(this);
+      },
+      remove(element3) {
+        mxn.onItemPop(this.current);
+        orig.remove.call(this, element3);
+      }
+    };
+  }
+};
+var openElementStackMixin = LocationInfoOpenElementStackMixin$1;
+var Mixin$5 = mixin;
+var Tokenizer$2 = tokenizer2;
+var LocationInfoTokenizerMixin$1 = tokenizerMixin$1;
+var LocationInfoOpenElementStackMixin = openElementStackMixin;
+var HTML$2 = html$2;
+var $$2 = HTML$2.TAG_NAMES;
+var LocationInfoParserMixin$1 = class extends Mixin$5 {
+  constructor(parser2) {
+    super(parser2);
+    this.parser = parser2;
+    this.treeAdapter = this.parser.treeAdapter;
+    this.posTracker = null;
+    this.lastStartTagToken = null;
+    this.lastFosterParentingLocation = null;
+    this.currentToken = null;
+  }
+  _setStartLocation(element3) {
+    let loc = null;
+    if (this.lastStartTagToken) {
+      loc = Object.assign({}, this.lastStartTagToken.location);
+      loc.startTag = this.lastStartTagToken.location;
+    }
+    this.treeAdapter.setNodeSourceCodeLocation(element3, loc);
+  }
+  _setEndLocation(element3, closingToken) {
+    const loc = this.treeAdapter.getNodeSourceCodeLocation(element3);
+    if (loc) {
+      if (closingToken.location) {
+        const ctLoc = closingToken.location;
+        const tn = this.treeAdapter.getTagName(element3);
+        const isClosingEndTag = closingToken.type === Tokenizer$2.END_TAG_TOKEN && tn === closingToken.tagName;
+        const endLoc = {};
+        if (isClosingEndTag) {
+          endLoc.endTag = Object.assign({}, ctLoc);
+          endLoc.endLine = ctLoc.endLine;
+          endLoc.endCol = ctLoc.endCol;
+          endLoc.endOffset = ctLoc.endOffset;
+        } else {
+          endLoc.endLine = ctLoc.startLine;
+          endLoc.endCol = ctLoc.startCol;
+          endLoc.endOffset = ctLoc.startOffset;
+        }
+        this.treeAdapter.updateNodeSourceCodeLocation(element3, endLoc);
+      }
+    }
+  }
+  _getOverriddenMethods(mxn, orig) {
+    return {
+      _bootstrap(document4, fragmentContext) {
+        orig._bootstrap.call(this, document4, fragmentContext);
+        mxn.lastStartTagToken = null;
+        mxn.lastFosterParentingLocation = null;
+        mxn.currentToken = null;
+        const tokenizerMixin2 = Mixin$5.install(this.tokenizer, LocationInfoTokenizerMixin$1);
+        mxn.posTracker = tokenizerMixin2.posTracker;
+        Mixin$5.install(this.openElements, LocationInfoOpenElementStackMixin, {
+          onItemPop: function(element3) {
+            mxn._setEndLocation(element3, mxn.currentToken);
+          }
+        });
+      },
+      _runParsingLoop(scriptHandler) {
+        orig._runParsingLoop.call(this, scriptHandler);
+        for (let i = this.openElements.stackTop; i >= 0; i--) {
+          mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
+        }
+      },
+      _processTokenInForeignContent(token) {
+        mxn.currentToken = token;
+        orig._processTokenInForeignContent.call(this, token);
+      },
+      _processToken(token) {
+        mxn.currentToken = token;
+        orig._processToken.call(this, token);
+        const requireExplicitUpdate = token.type === Tokenizer$2.END_TAG_TOKEN && (token.tagName === $$2.HTML || token.tagName === $$2.BODY && this.openElements.hasInScope($$2.BODY));
+        if (requireExplicitUpdate) {
+          for (let i = this.openElements.stackTop; i >= 0; i--) {
+            const element3 = this.openElements.items[i];
+            if (this.treeAdapter.getTagName(element3) === token.tagName) {
+              mxn._setEndLocation(element3, token);
+              break;
+            }
+          }
+        }
+      },
+      _setDocumentType(token) {
+        orig._setDocumentType.call(this, token);
+        const documentChildren = this.treeAdapter.getChildNodes(this.document);
+        const cnLength = documentChildren.length;
+        for (let i = 0; i < cnLength; i++) {
+          const node = documentChildren[i];
+          if (this.treeAdapter.isDocumentTypeNode(node)) {
+            this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
+            break;
+          }
+        }
+      },
+      _attachElementToTree(element3) {
+        mxn._setStartLocation(element3);
+        mxn.lastStartTagToken = null;
+        orig._attachElementToTree.call(this, element3);
+      },
+      _appendElement(token, namespaceURI) {
+        mxn.lastStartTagToken = token;
+        orig._appendElement.call(this, token, namespaceURI);
+      },
+      _insertElement(token, namespaceURI) {
+        mxn.lastStartTagToken = token;
+        orig._insertElement.call(this, token, namespaceURI);
+      },
+      _insertTemplate(token) {
+        mxn.lastStartTagToken = token;
+        orig._insertTemplate.call(this, token);
+        const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
+        this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
+      },
+      _insertFakeRootElement() {
+        orig._insertFakeRootElement.call(this);
+        this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
+      },
+      _appendCommentNode(token, parent) {
+        orig._appendCommentNode.call(this, token, parent);
+        const children = this.treeAdapter.getChildNodes(parent);
+        const commentNode = children[children.length - 1];
+        this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
+      },
+      _findFosterParentingLocation() {
+        mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
+        return mxn.lastFosterParentingLocation;
+      },
+      _insertCharacters(token) {
+        orig._insertCharacters.call(this, token);
+        const hasFosterParent = this._shouldFosterParentOnInsertion();
+        const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;
+        const siblings = this.treeAdapter.getChildNodes(parent);
+        const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;
+        const textNode = siblings[textNodeIdx];
+        const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
+        if (tnLoc) {
+          const { endLine, endCol, endOffset } = token.location;
+          this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
+        } else {
+          this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
+        }
+      }
+    };
+  }
+};
+var parserMixin$1 = LocationInfoParserMixin$1;
+var Mixin$4 = mixin;
+var ErrorReportingMixinBase$3 = class extends Mixin$4 {
+  constructor(host, opts) {
+    super(host);
+    this.posTracker = null;
+    this.onParseError = opts.onParseError;
+  }
+  _setErrorLocation(err) {
+    err.startLine = err.endLine = this.posTracker.line;
+    err.startCol = err.endCol = this.posTracker.col;
+    err.startOffset = err.endOffset = this.posTracker.offset;
+  }
+  _reportError(code3) {
+    const err = {
+      code: code3,
+      startLine: -1,
+      startCol: -1,
+      startOffset: -1,
+      endLine: -1,
+      endCol: -1,
+      endOffset: -1
+    };
+    this._setErrorLocation(err);
+    this.onParseError(err);
+  }
+  _getOverriddenMethods(mxn) {
+    return {
+      _err(code3) {
+        mxn._reportError(code3);
+      }
+    };
+  }
+};
+var mixinBase = ErrorReportingMixinBase$3;
+var ErrorReportingMixinBase$2 = mixinBase;
+var PositionTrackingPreprocessorMixin = preprocessorMixin$1;
+var Mixin$3 = mixin;
+var ErrorReportingPreprocessorMixin$1 = class extends ErrorReportingMixinBase$2 {
+  constructor(preprocessor2, opts) {
+    super(preprocessor2, opts);
+    this.posTracker = Mixin$3.install(preprocessor2, PositionTrackingPreprocessorMixin);
+    this.lastErrOffset = -1;
+  }
+  _reportError(code3) {
+    if (this.lastErrOffset !== this.posTracker.offset) {
+      this.lastErrOffset = this.posTracker.offset;
+      super._reportError(code3);
+    }
+  }
+};
+var preprocessorMixin = ErrorReportingPreprocessorMixin$1;
+var ErrorReportingMixinBase$1 = mixinBase;
+var ErrorReportingPreprocessorMixin = preprocessorMixin;
+var Mixin$2 = mixin;
+var ErrorReportingTokenizerMixin$1 = class extends ErrorReportingMixinBase$1 {
+  constructor(tokenizer3, opts) {
+    super(tokenizer3, opts);
+    const preprocessorMixin2 = Mixin$2.install(tokenizer3.preprocessor, ErrorReportingPreprocessorMixin, opts);
+    this.posTracker = preprocessorMixin2.posTracker;
+  }
+};
+var tokenizerMixin = ErrorReportingTokenizerMixin$1;
+var ErrorReportingMixinBase = mixinBase;
+var ErrorReportingTokenizerMixin = tokenizerMixin;
+var LocationInfoTokenizerMixin = tokenizerMixin$1;
+var Mixin$1 = mixin;
+var ErrorReportingParserMixin$1 = class extends ErrorReportingMixinBase {
+  constructor(parser2, opts) {
+    super(parser2, opts);
+    this.opts = opts;
+    this.ctLoc = null;
+    this.locBeforeToken = false;
+  }
+  _setErrorLocation(err) {
+    if (this.ctLoc) {
+      err.startLine = this.ctLoc.startLine;
+      err.startCol = this.ctLoc.startCol;
+      err.startOffset = this.ctLoc.startOffset;
+      err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
+      err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
+      err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
+    }
+  }
+  _getOverriddenMethods(mxn, orig) {
+    return {
+      _bootstrap(document4, fragmentContext) {
+        orig._bootstrap.call(this, document4, fragmentContext);
+        Mixin$1.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
+        Mixin$1.install(this.tokenizer, LocationInfoTokenizerMixin);
+      },
+      _processInputToken(token) {
+        mxn.ctLoc = token.location;
+        orig._processInputToken.call(this, token);
+      },
+      _err(code3, options) {
+        mxn.locBeforeToken = options && options.beforeToken;
+        mxn._reportError(code3);
+      }
+    };
+  }
+};
+var parserMixin = ErrorReportingParserMixin$1;
+var _default = {};
+var { DOCUMENT_MODE: DOCUMENT_MODE$1 } = html$2;
+_default.createDocument = function() {
+  return {
+    nodeName: "#document",
+    mode: DOCUMENT_MODE$1.NO_QUIRKS,
+    childNodes: []
+  };
+};
+_default.createDocumentFragment = function() {
+  return {
+    nodeName: "#document-fragment",
+    childNodes: []
+  };
+};
+_default.createElement = function(tagName, namespaceURI, attrs) {
+  return {
+    nodeName: tagName,
+    tagName,
+    attrs,
+    namespaceURI,
+    childNodes: [],
+    parentNode: null
+  };
+};
+_default.createCommentNode = function(data2) {
+  return {
+    nodeName: "#comment",
+    data: data2,
+    parentNode: null
+  };
+};
+var createTextNode = function(value) {
+  return {
+    nodeName: "#text",
+    value,
+    parentNode: null
+  };
+};
+var appendChild = _default.appendChild = function(parentNode, newNode) {
+  parentNode.childNodes.push(newNode);
+  newNode.parentNode = parentNode;
+};
+var insertBefore = _default.insertBefore = function(parentNode, newNode, referenceNode) {
+  const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
+  parentNode.childNodes.splice(insertionIdx, 0, newNode);
+  newNode.parentNode = parentNode;
+};
+_default.setTemplateContent = function(templateElement, contentElement) {
+  templateElement.content = contentElement;
+};
+_default.getTemplateContent = function(templateElement) {
+  return templateElement.content;
+};
+_default.setDocumentType = function(document4, name3, publicId, systemId) {
+  let doctypeNode = null;
+  for (let i = 0; i < document4.childNodes.length; i++) {
+    if (document4.childNodes[i].nodeName === "#documentType") {
+      doctypeNode = document4.childNodes[i];
+      break;
+    }
+  }
+  if (doctypeNode) {
+    doctypeNode.name = name3;
+    doctypeNode.publicId = publicId;
+    doctypeNode.systemId = systemId;
+  } else {
+    appendChild(document4, {
+      nodeName: "#documentType",
+      name: name3,
+      publicId,
+      systemId
+    });
+  }
+};
+_default.setDocumentMode = function(document4, mode) {
+  document4.mode = mode;
+};
+_default.getDocumentMode = function(document4) {
+  return document4.mode;
+};
+_default.detachNode = function(node) {
+  if (node.parentNode) {
+    const idx = node.parentNode.childNodes.indexOf(node);
+    node.parentNode.childNodes.splice(idx, 1);
+    node.parentNode = null;
+  }
+};
+_default.insertText = function(parentNode, text7) {
+  if (parentNode.childNodes.length) {
+    const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
+    if (prevNode.nodeName === "#text") {
+      prevNode.value += text7;
+      return;
+    }
+  }
+  appendChild(parentNode, createTextNode(text7));
+};
+_default.insertTextBefore = function(parentNode, text7, referenceNode) {
+  const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
+  if (prevNode && prevNode.nodeName === "#text") {
+    prevNode.value += text7;
+  } else {
+    insertBefore(parentNode, createTextNode(text7), referenceNode);
+  }
+};
+_default.adoptAttributes = function(recipient, attrs) {
+  const recipientAttrsMap = [];
+  for (let i = 0; i < recipient.attrs.length; i++) {
+    recipientAttrsMap.push(recipient.attrs[i].name);
+  }
+  for (let j = 0; j < attrs.length; j++) {
+    if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
+      recipient.attrs.push(attrs[j]);
+    }
+  }
+};
+_default.getFirstChild = function(node) {
+  return node.childNodes[0];
+};
+_default.getChildNodes = function(node) {
+  return node.childNodes;
+};
+_default.getParentNode = function(node) {
+  return node.parentNode;
+};
+_default.getAttrList = function(element3) {
+  return element3.attrs;
+};
+_default.getTagName = function(element3) {
+  return element3.tagName;
+};
+_default.getNamespaceURI = function(element3) {
+  return element3.namespaceURI;
+};
+_default.getTextNodeContent = function(textNode) {
+  return textNode.value;
+};
+_default.getCommentNodeContent = function(commentNode) {
+  return commentNode.data;
+};
+_default.getDocumentTypeNodeName = function(doctypeNode) {
+  return doctypeNode.name;
+};
+_default.getDocumentTypeNodePublicId = function(doctypeNode) {
+  return doctypeNode.publicId;
+};
+_default.getDocumentTypeNodeSystemId = function(doctypeNode) {
+  return doctypeNode.systemId;
+};
+_default.isTextNode = function(node) {
+  return node.nodeName === "#text";
+};
+_default.isCommentNode = function(node) {
+  return node.nodeName === "#comment";
+};
+_default.isDocumentTypeNode = function(node) {
+  return node.nodeName === "#documentType";
+};
+_default.isElementNode = function(node) {
+  return !!node.tagName;
+};
+_default.setNodeSourceCodeLocation = function(node, location2) {
+  node.sourceCodeLocation = location2;
+};
+_default.getNodeSourceCodeLocation = function(node) {
+  return node.sourceCodeLocation;
+};
+_default.updateNodeSourceCodeLocation = function(node, endLocation) {
+  node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);
+};
+var mergeOptions$1 = function mergeOptions(defaults, options) {
+  options = options || /* @__PURE__ */ Object.create(null);
+  return [defaults, options].reduce((merged, optObj) => {
+    Object.keys(optObj).forEach((key) => {
+      merged[key] = optObj[key];
+    });
+    return merged;
+  }, /* @__PURE__ */ Object.create(null));
+};
+var doctype$2 = {};
+var { DOCUMENT_MODE } = html$2;
+var VALID_DOCTYPE_NAME = "html";
+var VALID_SYSTEM_ID = "about:legacy-compat";
+var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
+var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
+  "+//silmaril//dtd html pro v0r11 19970101//",
+  "-//as//dtd html 3.0 aswedit + extensions//",
+  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
+  "-//ietf//dtd html 2.0 level 1//",
+  "-//ietf//dtd html 2.0 level 2//",
+  "-//ietf//dtd html 2.0 strict level 1//",
+  "-//ietf//dtd html 2.0 strict level 2//",
+  "-//ietf//dtd html 2.0 strict//",
+  "-//ietf//dtd html 2.0//",
+  "-//ietf//dtd html 2.1e//",
+  "-//ietf//dtd html 3.0//",
+  "-//ietf//dtd html 3.2 final//",
+  "-//ietf//dtd html 3.2//",
+  "-//ietf//dtd html 3//",
+  "-//ietf//dtd html level 0//",
+  "-//ietf//dtd html level 1//",
+  "-//ietf//dtd html level 2//",
+  "-//ietf//dtd html level 3//",
+  "-//ietf//dtd html strict level 0//",
+  "-//ietf//dtd html strict level 1//",
+  "-//ietf//dtd html strict level 2//",
+  "-//ietf//dtd html strict level 3//",
+  "-//ietf//dtd html strict//",
+  "-//ietf//dtd html//",
+  "-//metrius//dtd metrius presentational//",
+  "-//microsoft//dtd internet explorer 2.0 html strict//",
+  "-//microsoft//dtd internet explorer 2.0 html//",
+  "-//microsoft//dtd internet explorer 2.0 tables//",
+  "-//microsoft//dtd internet explorer 3.0 html strict//",
+  "-//microsoft//dtd internet explorer 3.0 html//",
+  "-//microsoft//dtd internet explorer 3.0 tables//",
+  "-//netscape comm. corp.//dtd html//",
+  "-//netscape comm. corp.//dtd strict html//",
+  "-//o'reilly and associates//dtd html 2.0//",
+  "-//o'reilly and associates//dtd html extended 1.0//",
+  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
+  "-//sq//dtd html 2.0 hotmetal + extensions//",
+  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
+  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
+  "-//spyglass//dtd html 2.0 extended//",
+  "-//sun microsystems corp.//dtd hotjava html//",
+  "-//sun microsystems corp.//dtd hotjava strict html//",
+  "-//w3c//dtd html 3 1995-03-24//",
+  "-//w3c//dtd html 3.2 draft//",
+  "-//w3c//dtd html 3.2 final//",
+  "-//w3c//dtd html 3.2//",
+  "-//w3c//dtd html 3.2s draft//",
+  "-//w3c//dtd html 4.0 frameset//",
+  "-//w3c//dtd html 4.0 transitional//",
+  "-//w3c//dtd html experimental 19960712//",
+  "-//w3c//dtd html experimental 970421//",
+  "-//w3c//dtd w3 html//",
+  "-//w3o//dtd w3 html 3.0//",
+  "-//webtechs//dtd mozilla html 2.0//",
+  "-//webtechs//dtd mozilla html//"
+];
+var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
+  "-//w3c//dtd html 4.01 frameset//",
+  "-//w3c//dtd html 4.01 transitional//"
+]);
+var QUIRKS_MODE_PUBLIC_IDS = ["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"];
+var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
+var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
+  "-//w3c//dtd html 4.01 frameset//",
+  "-//w3c//dtd html 4.01 transitional//"
+]);
+function enquoteDoctypeId(id) {
+  const quote = id.indexOf('"') !== -1 ? "'" : '"';
+  return quote + id + quote;
+}
+function hasPrefix(publicId, prefixes) {
+  for (let i = 0; i < prefixes.length; i++) {
+    if (publicId.indexOf(prefixes[i]) === 0) {
+      return true;
+    }
+  }
+  return false;
+}
+doctype$2.isConforming = function(token) {
+  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
+};
+doctype$2.getDocumentMode = function(token) {
+  if (token.name !== VALID_DOCTYPE_NAME) {
+    return DOCUMENT_MODE.QUIRKS;
+  }
+  const systemId = token.systemId;
+  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
+    return DOCUMENT_MODE.QUIRKS;
+  }
+  let publicId = token.publicId;
+  if (publicId !== null) {
+    publicId = publicId.toLowerCase();
+    if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
+      return DOCUMENT_MODE.QUIRKS;
+    }
+    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
+    if (hasPrefix(publicId, prefixes)) {
+      return DOCUMENT_MODE.QUIRKS;
+    }
+    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
+    if (hasPrefix(publicId, prefixes)) {
+      return DOCUMENT_MODE.LIMITED_QUIRKS;
+    }
+  }
+  return DOCUMENT_MODE.NO_QUIRKS;
+};
+doctype$2.serializeContent = function(name3, publicId, systemId) {
+  let str = "!DOCTYPE ";
+  if (name3) {
+    str += name3;
+  }
+  if (publicId) {
+    str += " PUBLIC " + enquoteDoctypeId(publicId);
+  } else if (systemId) {
+    str += " SYSTEM";
+  }
+  if (systemId !== null) {
+    str += " " + enquoteDoctypeId(systemId);
+  }
+  return str;
+};
+var foreignContent$1 = {};
+var Tokenizer$1 = tokenizer2;
+var HTML$1 = html$2;
+var $$1 = HTML$1.TAG_NAMES;
+var NS$1 = HTML$1.NAMESPACES;
+var ATTRS$1 = HTML$1.ATTRS;
+var MIME_TYPES = {
+  TEXT_HTML: "text/html",
+  APPLICATION_XML: "application/xhtml+xml"
+};
+var DEFINITION_URL_ATTR = "definitionurl";
+var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
+var SVG_ATTRS_ADJUSTMENT_MAP = {
+  attributename: "attributeName",
+  attributetype: "attributeType",
+  basefrequency: "baseFrequency",
+  baseprofile: "baseProfile",
+  calcmode: "calcMode",
+  clippathunits: "clipPathUnits",
+  diffuseconstant: "diffuseConstant",
+  edgemode: "edgeMode",
+  filterunits: "filterUnits",
+  glyphref: "glyphRef",
+  gradienttransform: "gradientTransform",
+  gradientunits: "gradientUnits",
+  kernelmatrix: "kernelMatrix",
+  kernelunitlength: "kernelUnitLength",
+  keypoints: "keyPoints",
+  keysplines: "keySplines",
+  keytimes: "keyTimes",
+  lengthadjust: "lengthAdjust",
+  limitingconeangle: "limitingConeAngle",
+  markerheight: "markerHeight",
+  markerunits: "markerUnits",
+  markerwidth: "markerWidth",
+  maskcontentunits: "maskContentUnits",
+  maskunits: "maskUnits",
+  numoctaves: "numOctaves",
+  pathlength: "pathLength",
+  patterncontentunits: "patternContentUnits",
+  patterntransform: "patternTransform",
+  patternunits: "patternUnits",
+  pointsatx: "pointsAtX",
+  pointsaty: "pointsAtY",
+  pointsatz: "pointsAtZ",
+  preservealpha: "preserveAlpha",
+  preserveaspectratio: "preserveAspectRatio",
+  primitiveunits: "primitiveUnits",
+  refx: "refX",
+  refy: "refY",
+  repeatcount: "repeatCount",
+  repeatdur: "repeatDur",
+  requiredextensions: "requiredExtensions",
+  requiredfeatures: "requiredFeatures",
+  specularconstant: "specularConstant",
+  specularexponent: "specularExponent",
+  spreadmethod: "spreadMethod",
+  startoffset: "startOffset",
+  stddeviation: "stdDeviation",
+  stitchtiles: "stitchTiles",
+  surfacescale: "surfaceScale",
+  systemlanguage: "systemLanguage",
+  tablevalues: "tableValues",
+  targetx: "targetX",
+  targety: "targetY",
+  textlength: "textLength",
+  viewbox: "viewBox",
+  viewtarget: "viewTarget",
+  xchannelselector: "xChannelSelector",
+  ychannelselector: "yChannelSelector",
+  zoomandpan: "zoomAndPan"
+};
+var XML_ATTRS_ADJUSTMENT_MAP = {
+  "xlink:actuate": { prefix: "xlink", name: "actuate", namespace: NS$1.XLINK },
+  "xlink:arcrole": { prefix: "xlink", name: "arcrole", namespace: NS$1.XLINK },
+  "xlink:href": { prefix: "xlink", name: "href", namespace: NS$1.XLINK },
+  "xlink:role": { prefix: "xlink", name: "role", namespace: NS$1.XLINK },
+  "xlink:show": { prefix: "xlink", name: "show", namespace: NS$1.XLINK },
+  "xlink:title": { prefix: "xlink", name: "title", namespace: NS$1.XLINK },
+  "xlink:type": { prefix: "xlink", name: "type", namespace: NS$1.XLINK },
+  "xml:base": { prefix: "xml", name: "base", namespace: NS$1.XML },
+  "xml:lang": { prefix: "xml", name: "lang", namespace: NS$1.XML },
+  "xml:space": { prefix: "xml", name: "space", namespace: NS$1.XML },
+  xmlns: { prefix: "", name: "xmlns", namespace: NS$1.XMLNS },
+  "xmlns:xlink": { prefix: "xmlns", name: "xlink", namespace: NS$1.XMLNS }
+};
+var SVG_TAG_NAMES_ADJUSTMENT_MAP = foreignContent$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
+  altglyph: "altGlyph",
+  altglyphdef: "altGlyphDef",
+  altglyphitem: "altGlyphItem",
+  animatecolor: "animateColor",
+  animatemotion: "animateMotion",
+  animatetransform: "animateTransform",
+  clippath: "clipPath",
+  feblend: "feBlend",
+  fecolormatrix: "feColorMatrix",
+  fecomponenttransfer: "feComponentTransfer",
+  fecomposite: "feComposite",
+  feconvolvematrix: "feConvolveMatrix",
+  fediffuselighting: "feDiffuseLighting",
+  fedisplacementmap: "feDisplacementMap",
+  fedistantlight: "feDistantLight",
+  feflood: "feFlood",
+  fefunca: "feFuncA",
+  fefuncb: "feFuncB",
+  fefuncg: "feFuncG",
+  fefuncr: "feFuncR",
+  fegaussianblur: "feGaussianBlur",
+  feimage: "feImage",
+  femerge: "feMerge",
+  femergenode: "feMergeNode",
+  femorphology: "feMorphology",
+  feoffset: "feOffset",
+  fepointlight: "fePointLight",
+  fespecularlighting: "feSpecularLighting",
+  fespotlight: "feSpotLight",
+  fetile: "feTile",
+  feturbulence: "feTurbulence",
+  foreignobject: "foreignObject",
+  glyphref: "glyphRef",
+  lineargradient: "linearGradient",
+  radialgradient: "radialGradient",
+  textpath: "textPath"
+};
+var EXITS_FOREIGN_CONTENT = {
+  [$$1.B]: true,
+  [$$1.BIG]: true,
+  [$$1.BLOCKQUOTE]: true,
+  [$$1.BODY]: true,
+  [$$1.BR]: true,
+  [$$1.CENTER]: true,
+  [$$1.CODE]: true,
+  [$$1.DD]: true,
+  [$$1.DIV]: true,
+  [$$1.DL]: true,
+  [$$1.DT]: true,
+  [$$1.EM]: true,
+  [$$1.EMBED]: true,
+  [$$1.H1]: true,
+  [$$1.H2]: true,
+  [$$1.H3]: true,
+  [$$1.H4]: true,
+  [$$1.H5]: true,
+  [$$1.H6]: true,
+  [$$1.HEAD]: true,
+  [$$1.HR]: true,
+  [$$1.I]: true,
+  [$$1.IMG]: true,
+  [$$1.LI]: true,
+  [$$1.LISTING]: true,
+  [$$1.MENU]: true,
+  [$$1.META]: true,
+  [$$1.NOBR]: true,
+  [$$1.OL]: true,
+  [$$1.P]: true,
+  [$$1.PRE]: true,
+  [$$1.RUBY]: true,
+  [$$1.S]: true,
+  [$$1.SMALL]: true,
+  [$$1.SPAN]: true,
+  [$$1.STRONG]: true,
+  [$$1.STRIKE]: true,
+  [$$1.SUB]: true,
+  [$$1.SUP]: true,
+  [$$1.TABLE]: true,
+  [$$1.TT]: true,
+  [$$1.U]: true,
+  [$$1.UL]: true,
+  [$$1.VAR]: true
+};
+foreignContent$1.causesExit = function(startTagToken) {
+  const tn = startTagToken.tagName;
+  const isFontWithAttrs = tn === $$1.FONT && (Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.COLOR) !== null || Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.SIZE) !== null || Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.FACE) !== null);
+  return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
+};
+foreignContent$1.adjustTokenMathMLAttrs = function(token) {
+  for (let i = 0; i < token.attrs.length; i++) {
+    if (token.attrs[i].name === DEFINITION_URL_ATTR) {
+      token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
+      break;
+    }
+  }
+};
+foreignContent$1.adjustTokenSVGAttrs = function(token) {
+  for (let i = 0; i < token.attrs.length; i++) {
+    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];
+    if (adjustedAttrName) {
+      token.attrs[i].name = adjustedAttrName;
+    }
+  }
+};
+foreignContent$1.adjustTokenXMLAttrs = function(token) {
+  for (let i = 0; i < token.attrs.length; i++) {
+    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];
+    if (adjustedAttrEntry) {
+      token.attrs[i].prefix = adjustedAttrEntry.prefix;
+      token.attrs[i].name = adjustedAttrEntry.name;
+      token.attrs[i].namespace = adjustedAttrEntry.namespace;
+    }
+  }
+};
+foreignContent$1.adjustTokenSVGTagName = function(token) {
+  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];
+  if (adjustedTagName) {
+    token.tagName = adjustedTagName;
+  }
+};
+function isMathMLTextIntegrationPoint(tn, ns) {
+  return ns === NS$1.MATHML && (tn === $$1.MI || tn === $$1.MO || tn === $$1.MN || tn === $$1.MS || tn === $$1.MTEXT);
+}
+function isHtmlIntegrationPoint(tn, ns, attrs) {
+  if (ns === NS$1.MATHML && tn === $$1.ANNOTATION_XML) {
+    for (let i = 0; i < attrs.length; i++) {
+      if (attrs[i].name === ATTRS$1.ENCODING) {
+        const value = attrs[i].value.toLowerCase();
+        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
+      }
+    }
+  }
+  return ns === NS$1.SVG && (tn === $$1.FOREIGN_OBJECT || tn === $$1.DESC || tn === $$1.TITLE);
+}
+foreignContent$1.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {
+  if ((!foreignNS || foreignNS === NS$1.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
+    return true;
+  }
+  if ((!foreignNS || foreignNS === NS$1.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
+    return true;
+  }
+  return false;
+};
+var Tokenizer = tokenizer2;
+var OpenElementStack = openElementStack;
+var FormattingElementList = formattingElementList;
+var LocationInfoParserMixin = parserMixin$1;
+var ErrorReportingParserMixin = parserMixin;
+var Mixin = mixin;
+var defaultTreeAdapter = _default;
+var mergeOptions2 = mergeOptions$1;
+var doctype$1 = doctype$2;
+var foreignContent = foreignContent$1;
+var ERR = errorCodes;
+var unicode = unicode$3;
+var HTML = html$2;
+var $ = HTML.TAG_NAMES;
+var NS = HTML.NAMESPACES;
+var ATTRS = HTML.ATTRS;
+var DEFAULT_OPTIONS = {
+  scriptingEnabled: true,
+  sourceCodeLocationInfo: false,
+  onParseError: null,
+  treeAdapter: defaultTreeAdapter
+};
+var HIDDEN_INPUT_TYPE = "hidden";
+var AA_OUTER_LOOP_ITER = 8;
+var AA_INNER_LOOP_ITER = 3;
+var INITIAL_MODE = "INITIAL_MODE";
+var BEFORE_HTML_MODE = "BEFORE_HTML_MODE";
+var BEFORE_HEAD_MODE = "BEFORE_HEAD_MODE";
+var IN_HEAD_MODE = "IN_HEAD_MODE";
+var IN_HEAD_NO_SCRIPT_MODE = "IN_HEAD_NO_SCRIPT_MODE";
+var AFTER_HEAD_MODE = "AFTER_HEAD_MODE";
+var IN_BODY_MODE = "IN_BODY_MODE";
+var TEXT_MODE = "TEXT_MODE";
+var IN_TABLE_MODE = "IN_TABLE_MODE";
+var IN_TABLE_TEXT_MODE = "IN_TABLE_TEXT_MODE";
+var IN_CAPTION_MODE = "IN_CAPTION_MODE";
+var IN_COLUMN_GROUP_MODE = "IN_COLUMN_GROUP_MODE";
+var IN_TABLE_BODY_MODE = "IN_TABLE_BODY_MODE";
+var IN_ROW_MODE = "IN_ROW_MODE";
+var IN_CELL_MODE = "IN_CELL_MODE";
+var IN_SELECT_MODE = "IN_SELECT_MODE";
+var IN_SELECT_IN_TABLE_MODE = "IN_SELECT_IN_TABLE_MODE";
+var IN_TEMPLATE_MODE = "IN_TEMPLATE_MODE";
+var AFTER_BODY_MODE = "AFTER_BODY_MODE";
+var IN_FRAMESET_MODE = "IN_FRAMESET_MODE";
+var AFTER_FRAMESET_MODE = "AFTER_FRAMESET_MODE";
+var AFTER_AFTER_BODY_MODE = "AFTER_AFTER_BODY_MODE";
+var AFTER_AFTER_FRAMESET_MODE = "AFTER_AFTER_FRAMESET_MODE";
+var INSERTION_MODE_RESET_MAP = {
+  [$.TR]: IN_ROW_MODE,
+  [$.TBODY]: IN_TABLE_BODY_MODE,
+  [$.THEAD]: IN_TABLE_BODY_MODE,
+  [$.TFOOT]: IN_TABLE_BODY_MODE,
+  [$.CAPTION]: IN_CAPTION_MODE,
+  [$.COLGROUP]: IN_COLUMN_GROUP_MODE,
+  [$.TABLE]: IN_TABLE_MODE,
+  [$.BODY]: IN_BODY_MODE,
+  [$.FRAMESET]: IN_FRAMESET_MODE
+};
+var TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
+  [$.CAPTION]: IN_TABLE_MODE,
+  [$.COLGROUP]: IN_TABLE_MODE,
+  [$.TBODY]: IN_TABLE_MODE,
+  [$.TFOOT]: IN_TABLE_MODE,
+  [$.THEAD]: IN_TABLE_MODE,
+  [$.COL]: IN_COLUMN_GROUP_MODE,
+  [$.TR]: IN_TABLE_BODY_MODE,
+  [$.TD]: IN_ROW_MODE,
+  [$.TH]: IN_ROW_MODE
+};
+var TOKEN_HANDLERS = {
+  [INITIAL_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
+    [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
+    [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
+    [Tokenizer.EOF_TOKEN]: tokenInInitialMode
+  },
+  [BEFORE_HTML_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
+    [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
+    [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
+  },
+  [BEFORE_HEAD_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
+    [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
+    [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
+    [Tokenizer.EOF_TOKEN]: tokenBeforeHead
+  },
+  [IN_HEAD_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
+    [Tokenizer.START_TAG_TOKEN]: startTagInHead,
+    [Tokenizer.END_TAG_TOKEN]: endTagInHead,
+    [Tokenizer.EOF_TOKEN]: tokenInHead
+  },
+  [IN_HEAD_NO_SCRIPT_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
+    [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
+    [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
+    [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
+  },
+  [AFTER_HEAD_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
+    [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
+    [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
+    [Tokenizer.EOF_TOKEN]: tokenAfterHead
+  },
+  [IN_BODY_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: characterInBody,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInBody,
+    [Tokenizer.END_TAG_TOKEN]: endTagInBody,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [TEXT_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: ignoreToken,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: ignoreToken,
+    [Tokenizer.END_TAG_TOKEN]: endTagInText,
+    [Tokenizer.EOF_TOKEN]: eofInText
+  },
+  [IN_TABLE_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInTable,
+    [Tokenizer.END_TAG_TOKEN]: endTagInTable,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [IN_TABLE_TEXT_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
+    [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
+    [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
+    [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
+    [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
+    [Tokenizer.EOF_TOKEN]: tokenInTableText
+  },
+  [IN_CAPTION_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: characterInBody,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
+    [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [IN_COLUMN_GROUP_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
+    [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [IN_TABLE_BODY_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
+    [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [IN_ROW_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInRow,
+    [Tokenizer.END_TAG_TOKEN]: endTagInRow,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [IN_CELL_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: characterInBody,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInCell,
+    [Tokenizer.END_TAG_TOKEN]: endTagInCell,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [IN_SELECT_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
+    [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [IN_SELECT_IN_TABLE_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
+    [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
+    [Tokenizer.EOF_TOKEN]: eofInBody
+  },
+  [IN_TEMPLATE_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: characterInBody,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
+    [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
+    [Tokenizer.EOF_TOKEN]: eofInTemplate
+  },
+  [AFTER_BODY_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
+    [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
+    [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
+    [Tokenizer.EOF_TOKEN]: stopParsing
+  },
+  [IN_FRAMESET_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
+    [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
+    [Tokenizer.EOF_TOKEN]: stopParsing
+  },
+  [AFTER_FRAMESET_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
+    [Tokenizer.COMMENT_TOKEN]: appendComment,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
+    [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
+    [Tokenizer.EOF_TOKEN]: stopParsing
+  },
+  [AFTER_AFTER_BODY_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
+    [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
+    [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
+    [Tokenizer.EOF_TOKEN]: stopParsing
+  },
+  [AFTER_AFTER_FRAMESET_MODE]: {
+    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
+    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
+    [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
+    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
+    [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
+    [Tokenizer.END_TAG_TOKEN]: ignoreToken,
+    [Tokenizer.EOF_TOKEN]: stopParsing
+  }
+};
+var Parser3 = class {
+  constructor(options) {
+    this.options = mergeOptions2(DEFAULT_OPTIONS, options);
+    this.treeAdapter = this.options.treeAdapter;
+    this.pendingScript = null;
+    if (this.options.sourceCodeLocationInfo) {
+      Mixin.install(this, LocationInfoParserMixin);
+    }
+    if (this.options.onParseError) {
+      Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
+    }
+  }
+  parse(html5) {
+    const document4 = this.treeAdapter.createDocument();
+    this._bootstrap(document4, null);
+    this.tokenizer.write(html5, true);
+    this._runParsingLoop(null);
+    return document4;
+  }
+  parseFragment(html5, fragmentContext) {
+    if (!fragmentContext) {
+      fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
+    }
+    const documentMock = this.treeAdapter.createElement("documentmock", NS.HTML, []);
+    this._bootstrap(documentMock, fragmentContext);
+    if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
+      this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
+    }
+    this._initTokenizerForFragmentParsing();
+    this._insertFakeRootElement();
+    this._resetInsertionMode();
+    this._findFormInFragmentContext();
+    this.tokenizer.write(html5, true);
+    this._runParsingLoop(null);
+    const rootElement = this.treeAdapter.getFirstChild(documentMock);
+    const fragment = this.treeAdapter.createDocumentFragment();
+    this._adoptNodes(rootElement, fragment);
+    return fragment;
+  }
+  _bootstrap(document4, fragmentContext) {
+    this.tokenizer = new Tokenizer(this.options);
+    this.stopped = false;
+    this.insertionMode = INITIAL_MODE;
+    this.originalInsertionMode = "";
+    this.document = document4;
+    this.fragmentContext = fragmentContext;
+    this.headElement = null;
+    this.formElement = null;
+    this.openElements = new OpenElementStack(this.document, this.treeAdapter);
+    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
+    this.tmplInsertionModeStack = [];
+    this.tmplInsertionModeStackTop = -1;
+    this.currentTmplInsertionMode = null;
+    this.pendingCharacterTokens = [];
+    this.hasNonWhitespacePendingCharacterToken = false;
+    this.framesetOk = true;
+    this.skipNextNewLine = false;
+    this.fosterParentingEnabled = false;
+  }
+  _err() {
+  }
+  _runParsingLoop(scriptHandler) {
+    while (!this.stopped) {
+      this._setupTokenizerCDATAMode();
+      const token = this.tokenizer.getNextToken();
+      if (token.type === Tokenizer.HIBERNATION_TOKEN) {
+        break;
+      }
+      if (this.skipNextNewLine) {
+        this.skipNextNewLine = false;
+        if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === "\n") {
+          if (token.chars.length === 1) {
+            continue;
+          }
+          token.chars = token.chars.substr(1);
+        }
+      }
+      this._processInputToken(token);
+      if (scriptHandler && this.pendingScript) {
+        break;
+      }
+    }
+  }
+  runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
+    this._runParsingLoop(scriptHandler);
+    if (scriptHandler && this.pendingScript) {
+      const script = this.pendingScript;
+      this.pendingScript = null;
+      scriptHandler(script);
+      return;
+    }
+    if (writeCallback) {
+      writeCallback();
+    }
+  }
+  _setupTokenizerCDATAMode() {
+    const current2 = this._getAdjustedCurrentElement();
+    this.tokenizer.allowCDATA = current2 && current2 !== this.document && this.treeAdapter.getNamespaceURI(current2) !== NS.HTML && !this._isIntegrationPoint(current2);
+  }
+  _switchToTextParsing(currentToken, nextTokenizerState) {
+    this._insertElement(currentToken, NS.HTML);
+    this.tokenizer.state = nextTokenizerState;
+    this.originalInsertionMode = this.insertionMode;
+    this.insertionMode = TEXT_MODE;
+  }
+  switchToPlaintextParsing() {
+    this.insertionMode = TEXT_MODE;
+    this.originalInsertionMode = IN_BODY_MODE;
+    this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
+  }
+  _getAdjustedCurrentElement() {
+    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
+  }
+  _findFormInFragmentContext() {
+    let node = this.fragmentContext;
+    do {
+      if (this.treeAdapter.getTagName(node) === $.FORM) {
+        this.formElement = node;
+        break;
+      }
+      node = this.treeAdapter.getParentNode(node);
+    } while (node);
+  }
+  _initTokenizerForFragmentParsing() {
+    if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
+      const tn = this.treeAdapter.getTagName(this.fragmentContext);
+      if (tn === $.TITLE || tn === $.TEXTAREA) {
+        this.tokenizer.state = Tokenizer.MODE.RCDATA;
+      } else if (tn === $.STYLE || tn === $.XMP || tn === $.IFRAME || tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT) {
+        this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
+      } else if (tn === $.SCRIPT) {
+        this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
+      } else if (tn === $.PLAINTEXT) {
+        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
+      }
+    }
+  }
+  _setDocumentType(token) {
+    const name3 = token.name || "";
+    const publicId = token.publicId || "";
+    const systemId = token.systemId || "";
+    this.treeAdapter.setDocumentType(this.document, name3, publicId, systemId);
+  }
+  _attachElementToTree(element3) {
+    if (this._shouldFosterParentOnInsertion()) {
+      this._fosterParentElement(element3);
+    } else {
+      const parent = this.openElements.currentTmplContent || this.openElements.current;
+      this.treeAdapter.appendChild(parent, element3);
+    }
+  }
+  _appendElement(token, namespaceURI) {
+    const element3 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
+    this._attachElementToTree(element3);
+  }
+  _insertElement(token, namespaceURI) {
+    const element3 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
+    this._attachElementToTree(element3);
+    this.openElements.push(element3);
+  }
+  _insertFakeElement(tagName) {
+    const element3 = this.treeAdapter.createElement(tagName, NS.HTML, []);
+    this._attachElementToTree(element3);
+    this.openElements.push(element3);
+  }
+  _insertTemplate(token) {
+    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
+    const content3 = this.treeAdapter.createDocumentFragment();
+    this.treeAdapter.setTemplateContent(tmpl, content3);
+    this._attachElementToTree(tmpl);
+    this.openElements.push(tmpl);
+  }
+  _insertFakeRootElement() {
+    const element3 = this.treeAdapter.createElement($.HTML, NS.HTML, []);
+    this.treeAdapter.appendChild(this.openElements.current, element3);
+    this.openElements.push(element3);
+  }
+  _appendCommentNode(token, parent) {
+    const commentNode = this.treeAdapter.createCommentNode(token.data);
+    this.treeAdapter.appendChild(parent, commentNode);
+  }
+  _insertCharacters(token) {
+    if (this._shouldFosterParentOnInsertion()) {
+      this._fosterParentText(token.chars);
+    } else {
+      const parent = this.openElements.currentTmplContent || this.openElements.current;
+      this.treeAdapter.insertText(parent, token.chars);
+    }
+  }
+  _adoptNodes(donor, recipient) {
+    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
+      this.treeAdapter.detachNode(child);
+      this.treeAdapter.appendChild(recipient, child);
+    }
+  }
+  _shouldProcessTokenInForeignContent(token) {
+    const current2 = this._getAdjustedCurrentElement();
+    if (!current2 || current2 === this.document) {
+      return false;
+    }
+    const ns = this.treeAdapter.getNamespaceURI(current2);
+    if (ns === NS.HTML) {
+      return false;
+    }
+    if (this.treeAdapter.getTagName(current2) === $.ANNOTATION_XML && ns === NS.MATHML && token.type === Tokenizer.START_TAG_TOKEN && token.tagName === $.SVG) {
+      return false;
+    }
+    const isCharacterToken = token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;
+    const isMathMLTextStartTag = token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;
+    if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current2, NS.MATHML)) {
+      return false;
+    }
+    if ((token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current2, NS.HTML)) {
+      return false;
+    }
+    return token.type !== Tokenizer.EOF_TOKEN;
+  }
+  _processToken(token) {
+    TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
+  }
+  _processTokenInBodyMode(token) {
+    TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
+  }
+  _processTokenInForeignContent(token) {
+    if (token.type === Tokenizer.CHARACTER_TOKEN) {
+      characterInForeignContent(this, token);
+    } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
+      nullCharacterInForeignContent(this, token);
+    } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
+      insertCharacters(this, token);
+    } else if (token.type === Tokenizer.COMMENT_TOKEN) {
+      appendComment(this, token);
+    } else if (token.type === Tokenizer.START_TAG_TOKEN) {
+      startTagInForeignContent(this, token);
+    } else if (token.type === Tokenizer.END_TAG_TOKEN) {
+      endTagInForeignContent(this, token);
+    }
+  }
+  _processInputToken(token) {
+    if (this._shouldProcessTokenInForeignContent(token)) {
+      this._processTokenInForeignContent(token);
+    } else {
+      this._processToken(token);
+    }
+    if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
+      this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
+    }
+  }
+  _isIntegrationPoint(element3, foreignNS) {
+    const tn = this.treeAdapter.getTagName(element3);
+    const ns = this.treeAdapter.getNamespaceURI(element3);
+    const attrs = this.treeAdapter.getAttrList(element3);
+    return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
+  }
+  _reconstructActiveFormattingElements() {
+    const listLength = this.activeFormattingElements.length;
+    if (listLength) {
+      let unopenIdx = listLength;
+      let entry = null;
+      do {
+        unopenIdx--;
+        entry = this.activeFormattingElements.entries[unopenIdx];
+        if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
+          unopenIdx++;
+          break;
+        }
+      } while (unopenIdx > 0);
+      for (let i = unopenIdx; i < listLength; i++) {
+        entry = this.activeFormattingElements.entries[i];
+        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
+        entry.element = this.openElements.current;
+      }
+    }
+  }
+  _closeTableCell() {
+    this.openElements.generateImpliedEndTags();
+    this.openElements.popUntilTableCellPopped();
+    this.activeFormattingElements.clearToLastMarker();
+    this.insertionMode = IN_ROW_MODE;
+  }
+  _closePElement() {
+    this.openElements.generateImpliedEndTagsWithExclusion($.P);
+    this.openElements.popUntilTagNamePopped($.P);
+  }
+  _resetInsertionMode() {
+    for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {
+      let element3 = this.openElements.items[i];
+      if (i === 0) {
+        last = true;
+        if (this.fragmentContext) {
+          element3 = this.fragmentContext;
+        }
+      }
+      const tn = this.treeAdapter.getTagName(element3);
+      const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];
+      if (newInsertionMode) {
+        this.insertionMode = newInsertionMode;
+        break;
+      } else if (!last && (tn === $.TD || tn === $.TH)) {
+        this.insertionMode = IN_CELL_MODE;
+        break;
+      } else if (!last && tn === $.HEAD) {
+        this.insertionMode = IN_HEAD_MODE;
+        break;
+      } else if (tn === $.SELECT) {
+        this._resetInsertionModeForSelect(i);
+        break;
+      } else if (tn === $.TEMPLATE) {
+        this.insertionMode = this.currentTmplInsertionMode;
+        break;
+      } else if (tn === $.HTML) {
+        this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
+        break;
+      } else if (last) {
+        this.insertionMode = IN_BODY_MODE;
+        break;
+      }
+    }
+  }
+  _resetInsertionModeForSelect(selectIdx) {
+    if (selectIdx > 0) {
+      for (let i = selectIdx - 1; i > 0; i--) {
+        const ancestor = this.openElements.items[i];
+        const tn = this.treeAdapter.getTagName(ancestor);
+        if (tn === $.TEMPLATE) {
+          break;
+        } else if (tn === $.TABLE) {
+          this.insertionMode = IN_SELECT_IN_TABLE_MODE;
+          return;
+        }
+      }
+    }
+    this.insertionMode = IN_SELECT_MODE;
+  }
+  _pushTmplInsertionMode(mode) {
+    this.tmplInsertionModeStack.push(mode);
+    this.tmplInsertionModeStackTop++;
+    this.currentTmplInsertionMode = mode;
+  }
+  _popTmplInsertionMode() {
+    this.tmplInsertionModeStack.pop();
+    this.tmplInsertionModeStackTop--;
+    this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
+  }
+  _isElementCausesFosterParenting(element3) {
+    const tn = this.treeAdapter.getTagName(element3);
+    return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
+  }
+  _shouldFosterParentOnInsertion() {
+    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
+  }
+  _findFosterParentingLocation() {
+    const location2 = {
+      parent: null,
+      beforeElement: null
+    };
+    for (let i = this.openElements.stackTop; i >= 0; i--) {
+      const openElement = this.openElements.items[i];
+      const tn = this.treeAdapter.getTagName(openElement);
+      const ns = this.treeAdapter.getNamespaceURI(openElement);
+      if (tn === $.TEMPLATE && ns === NS.HTML) {
+        location2.parent = this.treeAdapter.getTemplateContent(openElement);
+        break;
+      } else if (tn === $.TABLE) {
+        location2.parent = this.treeAdapter.getParentNode(openElement);
+        if (location2.parent) {
+          location2.beforeElement = openElement;
+        } else {
+          location2.parent = this.openElements.items[i - 1];
+        }
+        break;
+      }
+    }
+    if (!location2.parent) {
+      location2.parent = this.openElements.items[0];
+    }
+    return location2;
+  }
+  _fosterParentElement(element3) {
+    const location2 = this._findFosterParentingLocation();
+    if (location2.beforeElement) {
+      this.treeAdapter.insertBefore(location2.parent, element3, location2.beforeElement);
+    } else {
+      this.treeAdapter.appendChild(location2.parent, element3);
+    }
+  }
+  _fosterParentText(chars) {
+    const location2 = this._findFosterParentingLocation();
+    if (location2.beforeElement) {
+      this.treeAdapter.insertTextBefore(location2.parent, chars, location2.beforeElement);
+    } else {
+      this.treeAdapter.insertText(location2.parent, chars);
+    }
+  }
+  _isSpecialElement(element3) {
+    const tn = this.treeAdapter.getTagName(element3);
+    const ns = this.treeAdapter.getNamespaceURI(element3);
+    return HTML.SPECIAL_ELEMENTS[ns][tn];
+  }
+};
+var parser = Parser3;
+function aaObtainFormattingElementEntry(p, token) {
+  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
+  if (formattingElementEntry) {
+    if (!p.openElements.contains(formattingElementEntry.element)) {
+      p.activeFormattingElements.removeEntry(formattingElementEntry);
+      formattingElementEntry = null;
+    } else if (!p.openElements.hasInScope(token.tagName)) {
+      formattingElementEntry = null;
+    }
+  } else {
+    genericEndTagInBody(p, token);
+  }
+  return formattingElementEntry;
+}
+function aaObtainFurthestBlock(p, formattingElementEntry) {
+  let furthestBlock = null;
+  for (let i = p.openElements.stackTop; i >= 0; i--) {
+    const element3 = p.openElements.items[i];
+    if (element3 === formattingElementEntry.element) {
+      break;
+    }
+    if (p._isSpecialElement(element3)) {
+      furthestBlock = element3;
+    }
+  }
+  if (!furthestBlock) {
+    p.openElements.popUntilElementPopped(formattingElementEntry.element);
+    p.activeFormattingElements.removeEntry(formattingElementEntry);
+  }
+  return furthestBlock;
+}
+function aaInnerLoop(p, furthestBlock, formattingElement) {
+  let lastElement = furthestBlock;
+  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
+  for (let i = 0, element3 = nextElement; element3 !== formattingElement; i++, element3 = nextElement) {
+    nextElement = p.openElements.getCommonAncestor(element3);
+    const elementEntry = p.activeFormattingElements.getElementEntry(element3);
+    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
+    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
+    if (shouldRemoveFromOpenElements) {
+      if (counterOverflow) {
+        p.activeFormattingElements.removeEntry(elementEntry);
+      }
+      p.openElements.remove(element3);
+    } else {
+      element3 = aaRecreateElementFromEntry(p, elementEntry);
+      if (lastElement === furthestBlock) {
+        p.activeFormattingElements.bookmark = elementEntry;
+      }
+      p.treeAdapter.detachNode(lastElement);
+      p.treeAdapter.appendChild(element3, lastElement);
+      lastElement = element3;
+    }
+  }
+  return lastElement;
+}
+function aaRecreateElementFromEntry(p, elementEntry) {
+  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
+  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
+  p.openElements.replace(elementEntry.element, newElement);
+  elementEntry.element = newElement;
+  return newElement;
+}
+function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
+  if (p._isElementCausesFosterParenting(commonAncestor)) {
+    p._fosterParentElement(lastElement);
+  } else {
+    const tn = p.treeAdapter.getTagName(commonAncestor);
+    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
+    if (tn === $.TEMPLATE && ns === NS.HTML) {
+      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
+    }
+    p.treeAdapter.appendChild(commonAncestor, lastElement);
+  }
+}
+function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
+  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
+  const token = formattingElementEntry.token;
+  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
+  p._adoptNodes(furthestBlock, newElement);
+  p.treeAdapter.appendChild(furthestBlock, newElement);
+  p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
+  p.activeFormattingElements.removeEntry(formattingElementEntry);
+  p.openElements.remove(formattingElementEntry.element);
+  p.openElements.insertAfter(furthestBlock, newElement);
+}
+function callAdoptionAgency(p, token) {
+  let formattingElementEntry;
+  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
+    formattingElementEntry = aaObtainFormattingElementEntry(p, token);
+    if (!formattingElementEntry) {
+      break;
+    }
+    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
+    if (!furthestBlock) {
+      break;
+    }
+    p.activeFormattingElements.bookmark = formattingElementEntry;
+    const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
+    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
+    p.treeAdapter.detachNode(lastElement);
+    aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
+    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
+  }
+}
+function ignoreToken() {
+}
+function misplacedDoctype(p) {
+  p._err(ERR.misplacedDoctype);
+}
+function appendComment(p, token) {
+  p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);
+}
+function appendCommentToRootHtmlElement(p, token) {
+  p._appendCommentNode(token, p.openElements.items[0]);
+}
+function appendCommentToDocument(p, token) {
+  p._appendCommentNode(token, p.document);
+}
+function insertCharacters(p, token) {
+  p._insertCharacters(token);
+}
+function stopParsing(p) {
+  p.stopped = true;
+}
+function doctypeInInitialMode(p, token) {
+  p._setDocumentType(token);
+  const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype$1.getDocumentMode(token);
+  if (!doctype$1.isConforming(token)) {
+    p._err(ERR.nonConformingDoctype);
+  }
+  p.treeAdapter.setDocumentMode(p.document, mode);
+  p.insertionMode = BEFORE_HTML_MODE;
+}
+function tokenInInitialMode(p, token) {
+  p._err(ERR.missingDoctype, { beforeToken: true });
+  p.treeAdapter.setDocumentMode(p.document, HTML.DOCUMENT_MODE.QUIRKS);
+  p.insertionMode = BEFORE_HTML_MODE;
+  p._processToken(token);
+}
+function startTagBeforeHtml(p, token) {
+  if (token.tagName === $.HTML) {
+    p._insertElement(token, NS.HTML);
+    p.insertionMode = BEFORE_HEAD_MODE;
+  } else {
+    tokenBeforeHtml(p, token);
+  }
+}
+function endTagBeforeHtml(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {
+    tokenBeforeHtml(p, token);
+  }
+}
+function tokenBeforeHtml(p, token) {
+  p._insertFakeRootElement();
+  p.insertionMode = BEFORE_HEAD_MODE;
+  p._processToken(token);
+}
+function startTagBeforeHead(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.HEAD) {
+    p._insertElement(token, NS.HTML);
+    p.headElement = p.openElements.current;
+    p.insertionMode = IN_HEAD_MODE;
+  } else {
+    tokenBeforeHead(p, token);
+  }
+}
+function endTagBeforeHead(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {
+    tokenBeforeHead(p, token);
+  } else {
+    p._err(ERR.endTagWithoutMatchingOpenElement);
+  }
+}
+function tokenBeforeHead(p, token) {
+  p._insertFakeElement($.HEAD);
+  p.headElement = p.openElements.current;
+  p.insertionMode = IN_HEAD_MODE;
+  p._processToken(token);
+}
+function startTagInHead(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {
+    p._appendElement(token, NS.HTML);
+    token.ackSelfClosing = true;
+  } else if (tn === $.TITLE) {
+    p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
+  } else if (tn === $.NOSCRIPT) {
+    if (p.options.scriptingEnabled) {
+      p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
+    } else {
+      p._insertElement(token, NS.HTML);
+      p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
+    }
+  } else if (tn === $.NOFRAMES || tn === $.STYLE) {
+    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
+  } else if (tn === $.SCRIPT) {
+    p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
+  } else if (tn === $.TEMPLATE) {
+    p._insertTemplate(token, NS.HTML);
+    p.activeFormattingElements.insertMarker();
+    p.framesetOk = false;
+    p.insertionMode = IN_TEMPLATE_MODE;
+    p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
+  } else if (tn === $.HEAD) {
+    p._err(ERR.misplacedStartTagForHeadElement);
+  } else {
+    tokenInHead(p, token);
+  }
+}
+function endTagInHead(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HEAD) {
+    p.openElements.pop();
+    p.insertionMode = AFTER_HEAD_MODE;
+  } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {
+    tokenInHead(p, token);
+  } else if (tn === $.TEMPLATE) {
+    if (p.openElements.tmplCount > 0) {
+      p.openElements.generateImpliedEndTagsThoroughly();
+      if (p.openElements.currentTagName !== $.TEMPLATE) {
+        p._err(ERR.closingOfElementWithOpenChildElements);
+      }
+      p.openElements.popUntilTagNamePopped($.TEMPLATE);
+      p.activeFormattingElements.clearToLastMarker();
+      p._popTmplInsertionMode();
+      p._resetInsertionMode();
+    } else {
+      p._err(ERR.endTagWithoutMatchingOpenElement);
+    }
+  } else {
+    p._err(ERR.endTagWithoutMatchingOpenElement);
+  }
+}
+function tokenInHead(p, token) {
+  p.openElements.pop();
+  p.insertionMode = AFTER_HEAD_MODE;
+  p._processToken(token);
+}
+function startTagInHeadNoScript(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.BASEFONT || tn === $.BGSOUND || tn === $.HEAD || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.STYLE) {
+    startTagInHead(p, token);
+  } else if (tn === $.NOSCRIPT) {
+    p._err(ERR.nestedNoscriptInHead);
+  } else {
+    tokenInHeadNoScript(p, token);
+  }
+}
+function endTagInHeadNoScript(p, token) {
+  const tn = token.tagName;
+  if (tn === $.NOSCRIPT) {
+    p.openElements.pop();
+    p.insertionMode = IN_HEAD_MODE;
+  } else if (tn === $.BR) {
+    tokenInHeadNoScript(p, token);
+  } else {
+    p._err(ERR.endTagWithoutMatchingOpenElement);
+  }
+}
+function tokenInHeadNoScript(p, token) {
+  const errCode = token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
+  p._err(errCode);
+  p.openElements.pop();
+  p.insertionMode = IN_HEAD_MODE;
+  p._processToken(token);
+}
+function startTagAfterHead(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.BODY) {
+    p._insertElement(token, NS.HTML);
+    p.framesetOk = false;
+    p.insertionMode = IN_BODY_MODE;
+  } else if (tn === $.FRAMESET) {
+    p._insertElement(token, NS.HTML);
+    p.insertionMode = IN_FRAMESET_MODE;
+  } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
+    p._err(ERR.abandonedHeadElementChild);
+    p.openElements.push(p.headElement);
+    startTagInHead(p, token);
+    p.openElements.remove(p.headElement);
+  } else if (tn === $.HEAD) {
+    p._err(ERR.misplacedStartTagForHeadElement);
+  } else {
+    tokenAfterHead(p, token);
+  }
+}
+function endTagAfterHead(p, token) {
+  const tn = token.tagName;
+  if (tn === $.BODY || tn === $.HTML || tn === $.BR) {
+    tokenAfterHead(p, token);
+  } else if (tn === $.TEMPLATE) {
+    endTagInHead(p, token);
+  } else {
+    p._err(ERR.endTagWithoutMatchingOpenElement);
+  }
+}
+function tokenAfterHead(p, token) {
+  p._insertFakeElement($.BODY);
+  p.insertionMode = IN_BODY_MODE;
+  p._processToken(token);
+}
+function whitespaceCharacterInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  p._insertCharacters(token);
+}
+function characterInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  p._insertCharacters(token);
+  p.framesetOk = false;
+}
+function htmlStartTagInBody(p, token) {
+  if (p.openElements.tmplCount === 0) {
+    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
+  }
+}
+function bodyStartTagInBody(p, token) {
+  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
+  if (bodyElement && p.openElements.tmplCount === 0) {
+    p.framesetOk = false;
+    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
+  }
+}
+function framesetStartTagInBody(p, token) {
+  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
+  if (p.framesetOk && bodyElement) {
+    p.treeAdapter.detachNode(bodyElement);
+    p.openElements.popAllUpToHtmlElement();
+    p._insertElement(token, NS.HTML);
+    p.insertionMode = IN_FRAMESET_MODE;
+  }
+}
+function addressStartTagInBody(p, token) {
+  if (p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  p._insertElement(token, NS.HTML);
+}
+function numberedHeaderStartTagInBody(p, token) {
+  if (p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  const tn = p.openElements.currentTagName;
+  if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
+    p.openElements.pop();
+  }
+  p._insertElement(token, NS.HTML);
+}
+function preStartTagInBody(p, token) {
+  if (p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  p._insertElement(token, NS.HTML);
+  p.skipNextNewLine = true;
+  p.framesetOk = false;
+}
+function formStartTagInBody(p, token) {
+  const inTemplate = p.openElements.tmplCount > 0;
+  if (!p.formElement || inTemplate) {
+    if (p.openElements.hasInButtonScope($.P)) {
+      p._closePElement();
+    }
+    p._insertElement(token, NS.HTML);
+    if (!inTemplate) {
+      p.formElement = p.openElements.current;
+    }
+  }
+}
+function listItemStartTagInBody(p, token) {
+  p.framesetOk = false;
+  const tn = token.tagName;
+  for (let i = p.openElements.stackTop; i >= 0; i--) {
+    const element3 = p.openElements.items[i];
+    const elementTn = p.treeAdapter.getTagName(element3);
+    let closeTn = null;
+    if (tn === $.LI && elementTn === $.LI) {
+      closeTn = $.LI;
+    } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
+      closeTn = elementTn;
+    }
+    if (closeTn) {
+      p.openElements.generateImpliedEndTagsWithExclusion(closeTn);
+      p.openElements.popUntilTagNamePopped(closeTn);
+      break;
+    }
+    if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p._isSpecialElement(element3)) {
+      break;
+    }
+  }
+  if (p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  p._insertElement(token, NS.HTML);
+}
+function plaintextStartTagInBody(p, token) {
+  if (p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  p._insertElement(token, NS.HTML);
+  p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
+}
+function buttonStartTagInBody(p, token) {
+  if (p.openElements.hasInScope($.BUTTON)) {
+    p.openElements.generateImpliedEndTags();
+    p.openElements.popUntilTagNamePopped($.BUTTON);
+  }
+  p._reconstructActiveFormattingElements();
+  p._insertElement(token, NS.HTML);
+  p.framesetOk = false;
+}
+function aStartTagInBody(p, token) {
+  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);
+  if (activeElementEntry) {
+    callAdoptionAgency(p, token);
+    p.openElements.remove(activeElementEntry.element);
+    p.activeFormattingElements.removeEntry(activeElementEntry);
+  }
+  p._reconstructActiveFormattingElements();
+  p._insertElement(token, NS.HTML);
+  p.activeFormattingElements.pushElement(p.openElements.current, token);
+}
+function bStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  p._insertElement(token, NS.HTML);
+  p.activeFormattingElements.pushElement(p.openElements.current, token);
+}
+function nobrStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  if (p.openElements.hasInScope($.NOBR)) {
+    callAdoptionAgency(p, token);
+    p._reconstructActiveFormattingElements();
+  }
+  p._insertElement(token, NS.HTML);
+  p.activeFormattingElements.pushElement(p.openElements.current, token);
+}
+function appletStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  p._insertElement(token, NS.HTML);
+  p.activeFormattingElements.insertMarker();
+  p.framesetOk = false;
+}
+function tableStartTagInBody(p, token) {
+  if (p.treeAdapter.getDocumentMode(p.document) !== HTML.DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  p._insertElement(token, NS.HTML);
+  p.framesetOk = false;
+  p.insertionMode = IN_TABLE_MODE;
+}
+function areaStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  p._appendElement(token, NS.HTML);
+  p.framesetOk = false;
+  token.ackSelfClosing = true;
+}
+function inputStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  p._appendElement(token, NS.HTML);
+  const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
+  if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
+    p.framesetOk = false;
+  }
+  token.ackSelfClosing = true;
+}
+function paramStartTagInBody(p, token) {
+  p._appendElement(token, NS.HTML);
+  token.ackSelfClosing = true;
+}
+function hrStartTagInBody(p, token) {
+  if (p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  p._appendElement(token, NS.HTML);
+  p.framesetOk = false;
+  token.ackSelfClosing = true;
+}
+function imageStartTagInBody(p, token) {
+  token.tagName = $.IMG;
+  areaStartTagInBody(p, token);
+}
+function textareaStartTagInBody(p, token) {
+  p._insertElement(token, NS.HTML);
+  p.skipNextNewLine = true;
+  p.tokenizer.state = Tokenizer.MODE.RCDATA;
+  p.originalInsertionMode = p.insertionMode;
+  p.framesetOk = false;
+  p.insertionMode = TEXT_MODE;
+}
+function xmpStartTagInBody(p, token) {
+  if (p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  p._reconstructActiveFormattingElements();
+  p.framesetOk = false;
+  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
+}
+function iframeStartTagInBody(p, token) {
+  p.framesetOk = false;
+  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
+}
+function noembedStartTagInBody(p, token) {
+  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
+}
+function selectStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  p._insertElement(token, NS.HTML);
+  p.framesetOk = false;
+  if (p.insertionMode === IN_TABLE_MODE || p.insertionMode === IN_CAPTION_MODE || p.insertionMode === IN_TABLE_BODY_MODE || p.insertionMode === IN_ROW_MODE || p.insertionMode === IN_CELL_MODE) {
+    p.insertionMode = IN_SELECT_IN_TABLE_MODE;
+  } else {
+    p.insertionMode = IN_SELECT_MODE;
+  }
+}
+function optgroupStartTagInBody(p, token) {
+  if (p.openElements.currentTagName === $.OPTION) {
+    p.openElements.pop();
+  }
+  p._reconstructActiveFormattingElements();
+  p._insertElement(token, NS.HTML);
+}
+function rbStartTagInBody(p, token) {
+  if (p.openElements.hasInScope($.RUBY)) {
+    p.openElements.generateImpliedEndTags();
+  }
+  p._insertElement(token, NS.HTML);
+}
+function rtStartTagInBody(p, token) {
+  if (p.openElements.hasInScope($.RUBY)) {
+    p.openElements.generateImpliedEndTagsWithExclusion($.RTC);
+  }
+  p._insertElement(token, NS.HTML);
+}
+function menuStartTagInBody(p, token) {
+  if (p.openElements.hasInButtonScope($.P)) {
+    p._closePElement();
+  }
+  p._insertElement(token, NS.HTML);
+}
+function mathStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  foreignContent.adjustTokenMathMLAttrs(token);
+  foreignContent.adjustTokenXMLAttrs(token);
+  if (token.selfClosing) {
+    p._appendElement(token, NS.MATHML);
+  } else {
+    p._insertElement(token, NS.MATHML);
+  }
+  token.ackSelfClosing = true;
+}
+function svgStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  foreignContent.adjustTokenSVGAttrs(token);
+  foreignContent.adjustTokenXMLAttrs(token);
+  if (token.selfClosing) {
+    p._appendElement(token, NS.SVG);
+  } else {
+    p._insertElement(token, NS.SVG);
+  }
+  token.ackSelfClosing = true;
+}
+function genericStartTagInBody(p, token) {
+  p._reconstructActiveFormattingElements();
+  p._insertElement(token, NS.HTML);
+}
+function startTagInBody(p, token) {
+  const tn = token.tagName;
+  switch (tn.length) {
+    case 1:
+      if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {
+        bStartTagInBody(p, token);
+      } else if (tn === $.P) {
+        addressStartTagInBody(p, token);
+      } else if (tn === $.A) {
+        aStartTagInBody(p, token);
+      } else {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 2:
+      if (tn === $.DL || tn === $.OL || tn === $.UL) {
+        addressStartTagInBody(p, token);
+      } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
+        numberedHeaderStartTagInBody(p, token);
+      } else if (tn === $.LI || tn === $.DD || tn === $.DT) {
+        listItemStartTagInBody(p, token);
+      } else if (tn === $.EM || tn === $.TT) {
+        bStartTagInBody(p, token);
+      } else if (tn === $.BR) {
+        areaStartTagInBody(p, token);
+      } else if (tn === $.HR) {
+        hrStartTagInBody(p, token);
+      } else if (tn === $.RB) {
+        rbStartTagInBody(p, token);
+      } else if (tn === $.RT || tn === $.RP) {
+        rtStartTagInBody(p, token);
+      } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 3:
+      if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {
+        addressStartTagInBody(p, token);
+      } else if (tn === $.PRE) {
+        preStartTagInBody(p, token);
+      } else if (tn === $.BIG) {
+        bStartTagInBody(p, token);
+      } else if (tn === $.IMG || tn === $.WBR) {
+        areaStartTagInBody(p, token);
+      } else if (tn === $.XMP) {
+        xmpStartTagInBody(p, token);
+      } else if (tn === $.SVG) {
+        svgStartTagInBody(p, token);
+      } else if (tn === $.RTC) {
+        rbStartTagInBody(p, token);
+      } else if (tn !== $.COL) {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 4:
+      if (tn === $.HTML) {
+        htmlStartTagInBody(p, token);
+      } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {
+        startTagInHead(p, token);
+      } else if (tn === $.BODY) {
+        bodyStartTagInBody(p, token);
+      } else if (tn === $.MAIN || tn === $.MENU) {
+        addressStartTagInBody(p, token);
+      } else if (tn === $.FORM) {
+        formStartTagInBody(p, token);
+      } else if (tn === $.CODE || tn === $.FONT) {
+        bStartTagInBody(p, token);
+      } else if (tn === $.NOBR) {
+        nobrStartTagInBody(p, token);
+      } else if (tn === $.AREA) {
+        areaStartTagInBody(p, token);
+      } else if (tn === $.MATH) {
+        mathStartTagInBody(p, token);
+      } else if (tn === $.MENU) {
+        menuStartTagInBody(p, token);
+      } else if (tn !== $.HEAD) {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 5:
+      if (tn === $.STYLE || tn === $.TITLE) {
+        startTagInHead(p, token);
+      } else if (tn === $.ASIDE) {
+        addressStartTagInBody(p, token);
+      } else if (tn === $.SMALL) {
+        bStartTagInBody(p, token);
+      } else if (tn === $.TABLE) {
+        tableStartTagInBody(p, token);
+      } else if (tn === $.EMBED) {
+        areaStartTagInBody(p, token);
+      } else if (tn === $.INPUT) {
+        inputStartTagInBody(p, token);
+      } else if (tn === $.PARAM || tn === $.TRACK) {
+        paramStartTagInBody(p, token);
+      } else if (tn === $.IMAGE) {
+        imageStartTagInBody(p, token);
+      } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 6:
+      if (tn === $.SCRIPT) {
+        startTagInHead(p, token);
+      } else if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
+        addressStartTagInBody(p, token);
+      } else if (tn === $.BUTTON) {
+        buttonStartTagInBody(p, token);
+      } else if (tn === $.STRIKE || tn === $.STRONG) {
+        bStartTagInBody(p, token);
+      } else if (tn === $.APPLET || tn === $.OBJECT) {
+        appletStartTagInBody(p, token);
+      } else if (tn === $.KEYGEN) {
+        areaStartTagInBody(p, token);
+      } else if (tn === $.SOURCE) {
+        paramStartTagInBody(p, token);
+      } else if (tn === $.IFRAME) {
+        iframeStartTagInBody(p, token);
+      } else if (tn === $.SELECT) {
+        selectStartTagInBody(p, token);
+      } else if (tn === $.OPTION) {
+        optgroupStartTagInBody(p, token);
+      } else {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 7:
+      if (tn === $.BGSOUND) {
+        startTagInHead(p, token);
+      } else if (tn === $.DETAILS || tn === $.ADDRESS || tn === $.ARTICLE || tn === $.SECTION || tn === $.SUMMARY) {
+        addressStartTagInBody(p, token);
+      } else if (tn === $.LISTING) {
+        preStartTagInBody(p, token);
+      } else if (tn === $.MARQUEE) {
+        appletStartTagInBody(p, token);
+      } else if (tn === $.NOEMBED) {
+        noembedStartTagInBody(p, token);
+      } else if (tn !== $.CAPTION) {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 8:
+      if (tn === $.BASEFONT) {
+        startTagInHead(p, token);
+      } else if (tn === $.FRAMESET) {
+        framesetStartTagInBody(p, token);
+      } else if (tn === $.FIELDSET) {
+        addressStartTagInBody(p, token);
+      } else if (tn === $.TEXTAREA) {
+        textareaStartTagInBody(p, token);
+      } else if (tn === $.TEMPLATE) {
+        startTagInHead(p, token);
+      } else if (tn === $.NOSCRIPT) {
+        if (p.options.scriptingEnabled) {
+          noembedStartTagInBody(p, token);
+        } else {
+          genericStartTagInBody(p, token);
+        }
+      } else if (tn === $.OPTGROUP) {
+        optgroupStartTagInBody(p, token);
+      } else if (tn !== $.COLGROUP) {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 9:
+      if (tn === $.PLAINTEXT) {
+        plaintextStartTagInBody(p, token);
+      } else {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    case 10:
+      if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
+        addressStartTagInBody(p, token);
+      } else {
+        genericStartTagInBody(p, token);
+      }
+      break;
+    default:
+      genericStartTagInBody(p, token);
+  }
+}
+function bodyEndTagInBody(p) {
+  if (p.openElements.hasInScope($.BODY)) {
+    p.insertionMode = AFTER_BODY_MODE;
+  }
+}
+function htmlEndTagInBody(p, token) {
+  if (p.openElements.hasInScope($.BODY)) {
+    p.insertionMode = AFTER_BODY_MODE;
+    p._processToken(token);
+  }
+}
+function addressEndTagInBody(p, token) {
+  const tn = token.tagName;
+  if (p.openElements.hasInScope(tn)) {
+    p.openElements.generateImpliedEndTags();
+    p.openElements.popUntilTagNamePopped(tn);
+  }
+}
+function formEndTagInBody(p) {
+  const inTemplate = p.openElements.tmplCount > 0;
+  const formElement = p.formElement;
+  if (!inTemplate) {
+    p.formElement = null;
+  }
+  if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {
+    p.openElements.generateImpliedEndTags();
+    if (inTemplate) {
+      p.openElements.popUntilTagNamePopped($.FORM);
+    } else {
+      p.openElements.remove(formElement);
+    }
+  }
+}
+function pEndTagInBody(p) {
+  if (!p.openElements.hasInButtonScope($.P)) {
+    p._insertFakeElement($.P);
+  }
+  p._closePElement();
+}
+function liEndTagInBody(p) {
+  if (p.openElements.hasInListItemScope($.LI)) {
+    p.openElements.generateImpliedEndTagsWithExclusion($.LI);
+    p.openElements.popUntilTagNamePopped($.LI);
+  }
+}
+function ddEndTagInBody(p, token) {
+  const tn = token.tagName;
+  if (p.openElements.hasInScope(tn)) {
+    p.openElements.generateImpliedEndTagsWithExclusion(tn);
+    p.openElements.popUntilTagNamePopped(tn);
+  }
+}
+function numberedHeaderEndTagInBody(p) {
+  if (p.openElements.hasNumberedHeaderInScope()) {
+    p.openElements.generateImpliedEndTags();
+    p.openElements.popUntilNumberedHeaderPopped();
+  }
+}
+function appletEndTagInBody(p, token) {
+  const tn = token.tagName;
+  if (p.openElements.hasInScope(tn)) {
+    p.openElements.generateImpliedEndTags();
+    p.openElements.popUntilTagNamePopped(tn);
+    p.activeFormattingElements.clearToLastMarker();
+  }
+}
+function brEndTagInBody(p) {
+  p._reconstructActiveFormattingElements();
+  p._insertFakeElement($.BR);
+  p.openElements.pop();
+  p.framesetOk = false;
+}
+function genericEndTagInBody(p, token) {
+  const tn = token.tagName;
+  for (let i = p.openElements.stackTop; i > 0; i--) {
+    const element3 = p.openElements.items[i];
+    if (p.treeAdapter.getTagName(element3) === tn) {
+      p.openElements.generateImpliedEndTagsWithExclusion(tn);
+      p.openElements.popUntilElementPopped(element3);
+      break;
+    }
+    if (p._isSpecialElement(element3)) {
+      break;
+    }
+  }
+}
+function endTagInBody(p, token) {
+  const tn = token.tagName;
+  switch (tn.length) {
+    case 1:
+      if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {
+        callAdoptionAgency(p, token);
+      } else if (tn === $.P) {
+        pEndTagInBody(p);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    case 2:
+      if (tn === $.DL || tn === $.UL || tn === $.OL) {
+        addressEndTagInBody(p, token);
+      } else if (tn === $.LI) {
+        liEndTagInBody(p);
+      } else if (tn === $.DD || tn === $.DT) {
+        ddEndTagInBody(p, token);
+      } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
+        numberedHeaderEndTagInBody(p);
+      } else if (tn === $.BR) {
+        brEndTagInBody(p);
+      } else if (tn === $.EM || tn === $.TT) {
+        callAdoptionAgency(p, token);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    case 3:
+      if (tn === $.BIG) {
+        callAdoptionAgency(p, token);
+      } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {
+        addressEndTagInBody(p, token);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    case 4:
+      if (tn === $.BODY) {
+        bodyEndTagInBody(p);
+      } else if (tn === $.HTML) {
+        htmlEndTagInBody(p, token);
+      } else if (tn === $.FORM) {
+        formEndTagInBody(p);
+      } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {
+        callAdoptionAgency(p, token);
+      } else if (tn === $.MAIN || tn === $.MENU) {
+        addressEndTagInBody(p, token);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    case 5:
+      if (tn === $.ASIDE) {
+        addressEndTagInBody(p, token);
+      } else if (tn === $.SMALL) {
+        callAdoptionAgency(p, token);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    case 6:
+      if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
+        addressEndTagInBody(p, token);
+      } else if (tn === $.APPLET || tn === $.OBJECT) {
+        appletEndTagInBody(p, token);
+      } else if (tn === $.STRIKE || tn === $.STRONG) {
+        callAdoptionAgency(p, token);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    case 7:
+      if (tn === $.ADDRESS || tn === $.ARTICLE || tn === $.DETAILS || tn === $.SECTION || tn === $.SUMMARY || tn === $.LISTING) {
+        addressEndTagInBody(p, token);
+      } else if (tn === $.MARQUEE) {
+        appletEndTagInBody(p, token);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    case 8:
+      if (tn === $.FIELDSET) {
+        addressEndTagInBody(p, token);
+      } else if (tn === $.TEMPLATE) {
+        endTagInHead(p, token);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    case 10:
+      if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
+        addressEndTagInBody(p, token);
+      } else {
+        genericEndTagInBody(p, token);
+      }
+      break;
+    default:
+      genericEndTagInBody(p, token);
+  }
+}
+function eofInBody(p, token) {
+  if (p.tmplInsertionModeStackTop > -1) {
+    eofInTemplate(p, token);
+  } else {
+    p.stopped = true;
+  }
+}
+function endTagInText(p, token) {
+  if (token.tagName === $.SCRIPT) {
+    p.pendingScript = p.openElements.current;
+  }
+  p.openElements.pop();
+  p.insertionMode = p.originalInsertionMode;
+}
+function eofInText(p, token) {
+  p._err(ERR.eofInElementThatCanContainOnlyText);
+  p.openElements.pop();
+  p.insertionMode = p.originalInsertionMode;
+  p._processToken(token);
+}
+function characterInTable(p, token) {
+  const curTn = p.openElements.currentTagName;
+  if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
+    p.pendingCharacterTokens = [];
+    p.hasNonWhitespacePendingCharacterToken = false;
+    p.originalInsertionMode = p.insertionMode;
+    p.insertionMode = IN_TABLE_TEXT_MODE;
+    p._processToken(token);
+  } else {
+    tokenInTable(p, token);
+  }
+}
+function captionStartTagInTable(p, token) {
+  p.openElements.clearBackToTableContext();
+  p.activeFormattingElements.insertMarker();
+  p._insertElement(token, NS.HTML);
+  p.insertionMode = IN_CAPTION_MODE;
+}
+function colgroupStartTagInTable(p, token) {
+  p.openElements.clearBackToTableContext();
+  p._insertElement(token, NS.HTML);
+  p.insertionMode = IN_COLUMN_GROUP_MODE;
+}
+function colStartTagInTable(p, token) {
+  p.openElements.clearBackToTableContext();
+  p._insertFakeElement($.COLGROUP);
+  p.insertionMode = IN_COLUMN_GROUP_MODE;
+  p._processToken(token);
+}
+function tbodyStartTagInTable(p, token) {
+  p.openElements.clearBackToTableContext();
+  p._insertElement(token, NS.HTML);
+  p.insertionMode = IN_TABLE_BODY_MODE;
+}
+function tdStartTagInTable(p, token) {
+  p.openElements.clearBackToTableContext();
+  p._insertFakeElement($.TBODY);
+  p.insertionMode = IN_TABLE_BODY_MODE;
+  p._processToken(token);
+}
+function tableStartTagInTable(p, token) {
+  if (p.openElements.hasInTableScope($.TABLE)) {
+    p.openElements.popUntilTagNamePopped($.TABLE);
+    p._resetInsertionMode();
+    p._processToken(token);
+  }
+}
+function inputStartTagInTable(p, token) {
+  const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
+  if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
+    p._appendElement(token, NS.HTML);
+  } else {
+    tokenInTable(p, token);
+  }
+  token.ackSelfClosing = true;
+}
+function formStartTagInTable(p, token) {
+  if (!p.formElement && p.openElements.tmplCount === 0) {
+    p._insertElement(token, NS.HTML);
+    p.formElement = p.openElements.current;
+    p.openElements.pop();
+  }
+}
+function startTagInTable(p, token) {
+  const tn = token.tagName;
+  switch (tn.length) {
+    case 2:
+      if (tn === $.TD || tn === $.TH || tn === $.TR) {
+        tdStartTagInTable(p, token);
+      } else {
+        tokenInTable(p, token);
+      }
+      break;
+    case 3:
+      if (tn === $.COL) {
+        colStartTagInTable(p, token);
+      } else {
+        tokenInTable(p, token);
+      }
+      break;
+    case 4:
+      if (tn === $.FORM) {
+        formStartTagInTable(p, token);
+      } else {
+        tokenInTable(p, token);
+      }
+      break;
+    case 5:
+      if (tn === $.TABLE) {
+        tableStartTagInTable(p, token);
+      } else if (tn === $.STYLE) {
+        startTagInHead(p, token);
+      } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
+        tbodyStartTagInTable(p, token);
+      } else if (tn === $.INPUT) {
+        inputStartTagInTable(p, token);
+      } else {
+        tokenInTable(p, token);
+      }
+      break;
+    case 6:
+      if (tn === $.SCRIPT) {
+        startTagInHead(p, token);
+      } else {
+        tokenInTable(p, token);
+      }
+      break;
+    case 7:
+      if (tn === $.CAPTION) {
+        captionStartTagInTable(p, token);
+      } else {
+        tokenInTable(p, token);
+      }
+      break;
+    case 8:
+      if (tn === $.COLGROUP) {
+        colgroupStartTagInTable(p, token);
+      } else if (tn === $.TEMPLATE) {
+        startTagInHead(p, token);
+      } else {
+        tokenInTable(p, token);
+      }
+      break;
+    default:
+      tokenInTable(p, token);
+  }
+}
+function endTagInTable(p, token) {
+  const tn = token.tagName;
+  if (tn === $.TABLE) {
+    if (p.openElements.hasInTableScope($.TABLE)) {
+      p.openElements.popUntilTagNamePopped($.TABLE);
+      p._resetInsertionMode();
+    }
+  } else if (tn === $.TEMPLATE) {
+    endTagInHead(p, token);
+  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
+    tokenInTable(p, token);
+  }
+}
+function tokenInTable(p, token) {
+  const savedFosterParentingState = p.fosterParentingEnabled;
+  p.fosterParentingEnabled = true;
+  p._processTokenInBodyMode(token);
+  p.fosterParentingEnabled = savedFosterParentingState;
+}
+function whitespaceCharacterInTableText(p, token) {
+  p.pendingCharacterTokens.push(token);
+}
+function characterInTableText(p, token) {
+  p.pendingCharacterTokens.push(token);
+  p.hasNonWhitespacePendingCharacterToken = true;
+}
+function tokenInTableText(p, token) {
+  let i = 0;
+  if (p.hasNonWhitespacePendingCharacterToken) {
+    for (; i < p.pendingCharacterTokens.length; i++) {
+      tokenInTable(p, p.pendingCharacterTokens[i]);
+    }
+  } else {
+    for (; i < p.pendingCharacterTokens.length; i++) {
+      p._insertCharacters(p.pendingCharacterTokens[i]);
+    }
+  }
+  p.insertionMode = p.originalInsertionMode;
+  p._processToken(token);
+}
+function startTagInCaption(p, token) {
+  const tn = token.tagName;
+  if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
+    if (p.openElements.hasInTableScope($.CAPTION)) {
+      p.openElements.generateImpliedEndTags();
+      p.openElements.popUntilTagNamePopped($.CAPTION);
+      p.activeFormattingElements.clearToLastMarker();
+      p.insertionMode = IN_TABLE_MODE;
+      p._processToken(token);
+    }
+  } else {
+    startTagInBody(p, token);
+  }
+}
+function endTagInCaption(p, token) {
+  const tn = token.tagName;
+  if (tn === $.CAPTION || tn === $.TABLE) {
+    if (p.openElements.hasInTableScope($.CAPTION)) {
+      p.openElements.generateImpliedEndTags();
+      p.openElements.popUntilTagNamePopped($.CAPTION);
+      p.activeFormattingElements.clearToLastMarker();
+      p.insertionMode = IN_TABLE_MODE;
+      if (tn === $.TABLE) {
+        p._processToken(token);
+      }
+    }
+  } else if (tn !== $.BODY && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
+    endTagInBody(p, token);
+  }
+}
+function startTagInColumnGroup(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.COL) {
+    p._appendElement(token, NS.HTML);
+    token.ackSelfClosing = true;
+  } else if (tn === $.TEMPLATE) {
+    startTagInHead(p, token);
+  } else {
+    tokenInColumnGroup(p, token);
+  }
+}
+function endTagInColumnGroup(p, token) {
+  const tn = token.tagName;
+  if (tn === $.COLGROUP) {
+    if (p.openElements.currentTagName === $.COLGROUP) {
+      p.openElements.pop();
+      p.insertionMode = IN_TABLE_MODE;
+    }
+  } else if (tn === $.TEMPLATE) {
+    endTagInHead(p, token);
+  } else if (tn !== $.COL) {
+    tokenInColumnGroup(p, token);
+  }
+}
+function tokenInColumnGroup(p, token) {
+  if (p.openElements.currentTagName === $.COLGROUP) {
+    p.openElements.pop();
+    p.insertionMode = IN_TABLE_MODE;
+    p._processToken(token);
+  }
+}
+function startTagInTableBody(p, token) {
+  const tn = token.tagName;
+  if (tn === $.TR) {
+    p.openElements.clearBackToTableBodyContext();
+    p._insertElement(token, NS.HTML);
+    p.insertionMode = IN_ROW_MODE;
+  } else if (tn === $.TH || tn === $.TD) {
+    p.openElements.clearBackToTableBodyContext();
+    p._insertFakeElement($.TR);
+    p.insertionMode = IN_ROW_MODE;
+    p._processToken(token);
+  } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
+    if (p.openElements.hasTableBodyContextInTableScope()) {
+      p.openElements.clearBackToTableBodyContext();
+      p.openElements.pop();
+      p.insertionMode = IN_TABLE_MODE;
+      p._processToken(token);
+    }
+  } else {
+    startTagInTable(p, token);
+  }
+}
+function endTagInTableBody(p, token) {
+  const tn = token.tagName;
+  if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
+    if (p.openElements.hasInTableScope(tn)) {
+      p.openElements.clearBackToTableBodyContext();
+      p.openElements.pop();
+      p.insertionMode = IN_TABLE_MODE;
+    }
+  } else if (tn === $.TABLE) {
+    if (p.openElements.hasTableBodyContextInTableScope()) {
+      p.openElements.clearBackToTableBodyContext();
+      p.openElements.pop();
+      p.insertionMode = IN_TABLE_MODE;
+      p._processToken(token);
+    }
+  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR) {
+    endTagInTable(p, token);
+  }
+}
+function startTagInRow(p, token) {
+  const tn = token.tagName;
+  if (tn === $.TH || tn === $.TD) {
+    p.openElements.clearBackToTableRowContext();
+    p._insertElement(token, NS.HTML);
+    p.insertionMode = IN_CELL_MODE;
+    p.activeFormattingElements.insertMarker();
+  } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
+    if (p.openElements.hasInTableScope($.TR)) {
+      p.openElements.clearBackToTableRowContext();
+      p.openElements.pop();
+      p.insertionMode = IN_TABLE_BODY_MODE;
+      p._processToken(token);
+    }
+  } else {
+    startTagInTable(p, token);
+  }
+}
+function endTagInRow(p, token) {
+  const tn = token.tagName;
+  if (tn === $.TR) {
+    if (p.openElements.hasInTableScope($.TR)) {
+      p.openElements.clearBackToTableRowContext();
+      p.openElements.pop();
+      p.insertionMode = IN_TABLE_BODY_MODE;
+    }
+  } else if (tn === $.TABLE) {
+    if (p.openElements.hasInTableScope($.TR)) {
+      p.openElements.clearBackToTableRowContext();
+      p.openElements.pop();
+      p.insertionMode = IN_TABLE_BODY_MODE;
+      p._processToken(token);
+    }
+  } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
+    if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($.TR)) {
+      p.openElements.clearBackToTableRowContext();
+      p.openElements.pop();
+      p.insertionMode = IN_TABLE_BODY_MODE;
+      p._processToken(token);
+    }
+  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH) {
+    endTagInTable(p, token);
+  }
+}
+function startTagInCell(p, token) {
+  const tn = token.tagName;
+  if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
+    if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {
+      p._closeTableCell();
+      p._processToken(token);
+    }
+  } else {
+    startTagInBody(p, token);
+  }
+}
+function endTagInCell(p, token) {
+  const tn = token.tagName;
+  if (tn === $.TD || tn === $.TH) {
+    if (p.openElements.hasInTableScope(tn)) {
+      p.openElements.generateImpliedEndTags();
+      p.openElements.popUntilTagNamePopped(tn);
+      p.activeFormattingElements.clearToLastMarker();
+      p.insertionMode = IN_ROW_MODE;
+    }
+  } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
+    if (p.openElements.hasInTableScope(tn)) {
+      p._closeTableCell();
+      p._processToken(token);
+    }
+  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {
+    endTagInBody(p, token);
+  }
+}
+function startTagInSelect(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.OPTION) {
+    if (p.openElements.currentTagName === $.OPTION) {
+      p.openElements.pop();
+    }
+    p._insertElement(token, NS.HTML);
+  } else if (tn === $.OPTGROUP) {
+    if (p.openElements.currentTagName === $.OPTION) {
+      p.openElements.pop();
+    }
+    if (p.openElements.currentTagName === $.OPTGROUP) {
+      p.openElements.pop();
+    }
+    p._insertElement(token, NS.HTML);
+  } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
+    if (p.openElements.hasInSelectScope($.SELECT)) {
+      p.openElements.popUntilTagNamePopped($.SELECT);
+      p._resetInsertionMode();
+      if (tn !== $.SELECT) {
+        p._processToken(token);
+      }
+    }
+  } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {
+    startTagInHead(p, token);
+  }
+}
+function endTagInSelect(p, token) {
+  const tn = token.tagName;
+  if (tn === $.OPTGROUP) {
+    const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];
+    const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);
+    if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
+      p.openElements.pop();
+    }
+    if (p.openElements.currentTagName === $.OPTGROUP) {
+      p.openElements.pop();
+    }
+  } else if (tn === $.OPTION) {
+    if (p.openElements.currentTagName === $.OPTION) {
+      p.openElements.pop();
+    }
+  } else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {
+    p.openElements.popUntilTagNamePopped($.SELECT);
+    p._resetInsertionMode();
+  } else if (tn === $.TEMPLATE) {
+    endTagInHead(p, token);
+  }
+}
+function startTagInSelectInTable(p, token) {
+  const tn = token.tagName;
+  if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
+    p.openElements.popUntilTagNamePopped($.SELECT);
+    p._resetInsertionMode();
+    p._processToken(token);
+  } else {
+    startTagInSelect(p, token);
+  }
+}
+function endTagInSelectInTable(p, token) {
+  const tn = token.tagName;
+  if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
+    if (p.openElements.hasInTableScope(tn)) {
+      p.openElements.popUntilTagNamePopped($.SELECT);
+      p._resetInsertionMode();
+      p._processToken(token);
+    }
+  } else {
+    endTagInSelect(p, token);
+  }
+}
+function startTagInTemplate(p, token) {
+  const tn = token.tagName;
+  if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
+    startTagInHead(p, token);
+  } else {
+    const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
+    p._popTmplInsertionMode();
+    p._pushTmplInsertionMode(newInsertionMode);
+    p.insertionMode = newInsertionMode;
+    p._processToken(token);
+  }
+}
+function endTagInTemplate(p, token) {
+  if (token.tagName === $.TEMPLATE) {
+    endTagInHead(p, token);
+  }
+}
+function eofInTemplate(p, token) {
+  if (p.openElements.tmplCount > 0) {
+    p.openElements.popUntilTagNamePopped($.TEMPLATE);
+    p.activeFormattingElements.clearToLastMarker();
+    p._popTmplInsertionMode();
+    p._resetInsertionMode();
+    p._processToken(token);
+  } else {
+    p.stopped = true;
+  }
+}
+function startTagAfterBody(p, token) {
+  if (token.tagName === $.HTML) {
+    startTagInBody(p, token);
+  } else {
+    tokenAfterBody(p, token);
+  }
+}
+function endTagAfterBody(p, token) {
+  if (token.tagName === $.HTML) {
+    if (!p.fragmentContext) {
+      p.insertionMode = AFTER_AFTER_BODY_MODE;
+    }
+  } else {
+    tokenAfterBody(p, token);
+  }
+}
+function tokenAfterBody(p, token) {
+  p.insertionMode = IN_BODY_MODE;
+  p._processToken(token);
+}
+function startTagInFrameset(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.FRAMESET) {
+    p._insertElement(token, NS.HTML);
+  } else if (tn === $.FRAME) {
+    p._appendElement(token, NS.HTML);
+    token.ackSelfClosing = true;
+  } else if (tn === $.NOFRAMES) {
+    startTagInHead(p, token);
+  }
+}
+function endTagInFrameset(p, token) {
+  if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
+    p.openElements.pop();
+    if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET) {
+      p.insertionMode = AFTER_FRAMESET_MODE;
+    }
+  }
+}
+function startTagAfterFrameset(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.NOFRAMES) {
+    startTagInHead(p, token);
+  }
+}
+function endTagAfterFrameset(p, token) {
+  if (token.tagName === $.HTML) {
+    p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
+  }
+}
+function startTagAfterAfterBody(p, token) {
+  if (token.tagName === $.HTML) {
+    startTagInBody(p, token);
+  } else {
+    tokenAfterAfterBody(p, token);
+  }
+}
+function tokenAfterAfterBody(p, token) {
+  p.insertionMode = IN_BODY_MODE;
+  p._processToken(token);
+}
+function startTagAfterAfterFrameset(p, token) {
+  const tn = token.tagName;
+  if (tn === $.HTML) {
+    startTagInBody(p, token);
+  } else if (tn === $.NOFRAMES) {
+    startTagInHead(p, token);
+  }
+}
+function nullCharacterInForeignContent(p, token) {
+  token.chars = unicode.REPLACEMENT_CHARACTER;
+  p._insertCharacters(token);
+}
+function characterInForeignContent(p, token) {
+  p._insertCharacters(token);
+  p.framesetOk = false;
+}
+function startTagInForeignContent(p, token) {
+  if (foreignContent.causesExit(token) && !p.fragmentContext) {
+    while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.current)) {
+      p.openElements.pop();
+    }
+    p._processToken(token);
+  } else {
+    const current2 = p._getAdjustedCurrentElement();
+    const currentNs = p.treeAdapter.getNamespaceURI(current2);
+    if (currentNs === NS.MATHML) {
+      foreignContent.adjustTokenMathMLAttrs(token);
+    } else if (currentNs === NS.SVG) {
+      foreignContent.adjustTokenSVGTagName(token);
+      foreignContent.adjustTokenSVGAttrs(token);
+    }
+    foreignContent.adjustTokenXMLAttrs(token);
+    if (token.selfClosing) {
+      p._appendElement(token, currentNs);
+    } else {
+      p._insertElement(token, currentNs);
+    }
+    token.ackSelfClosing = true;
+  }
+}
+function endTagInForeignContent(p, token) {
+  for (let i = p.openElements.stackTop; i > 0; i--) {
+    const element3 = p.openElements.items[i];
+    if (p.treeAdapter.getNamespaceURI(element3) === NS.HTML) {
+      p._processToken(token);
+      break;
+    }
+    if (p.treeAdapter.getTagName(element3).toLowerCase() === token.tagName) {
+      p.openElements.popUntilElementPopped(element3);
+      break;
+    }
+  }
+}
+var Parser5 = parser;
+var Schema2 = class {
+  constructor(property, normal, space) {
+    this.property = property;
+    this.normal = normal;
+    if (space) {
+      this.space = space;
+    }
+  }
+};
+Schema2.prototype.property = {};
+Schema2.prototype.normal = {};
+Schema2.prototype.space = null;
+function merge2(definitions2, space) {
+  const property = {};
+  const normal = {};
+  let index3 = -1;
+  while (++index3 < definitions2.length) {
+    Object.assign(property, definitions2[index3].property);
+    Object.assign(normal, definitions2[index3].normal);
+  }
+  return new Schema2(property, normal, space);
+}
+function normalize6(value) {
+  return value.toLowerCase();
+}
+var Info2 = class {
+  constructor(property, attribute) {
+    this.property = property;
+    this.attribute = attribute;
+  }
+};
+Info2.prototype.space = null;
+Info2.prototype.boolean = false;
+Info2.prototype.booleanish = false;
+Info2.prototype.overloadedBoolean = false;
+Info2.prototype.number = false;
+Info2.prototype.commaSeparated = false;
+Info2.prototype.spaceSeparated = false;
+Info2.prototype.commaOrSpaceSeparated = false;
+Info2.prototype.mustUseProperty = false;
+Info2.prototype.defined = false;
+var powers2 = 0;
+var boolean2 = increment2();
+var booleanish2 = increment2();
+var overloadedBoolean2 = increment2();
+var number2 = increment2();
+var spaceSeparated2 = increment2();
+var commaSeparated2 = increment2();
+var commaOrSpaceSeparated2 = increment2();
+function increment2() {
+  return 2 ** ++powers2;
+}
+var types2 = /* @__PURE__ */ Object.freeze({
+  __proto__: null,
+  boolean: boolean2,
+  booleanish: booleanish2,
+  overloadedBoolean: overloadedBoolean2,
+  number: number2,
+  spaceSeparated: spaceSeparated2,
+  commaSeparated: commaSeparated2,
+  commaOrSpaceSeparated: commaOrSpaceSeparated2
+});
+var checks2 = Object.keys(types2);
+var DefinedInfo2 = class extends Info2 {
+  constructor(property, attribute, mask, space) {
+    let index3 = -1;
+    super(property, attribute);
+    mark2(this, "space", space);
+    if (typeof mask === "number") {
+      while (++index3 < checks2.length) {
+        const check = checks2[index3];
+        mark2(this, checks2[index3], (mask & types2[check]) === types2[check]);
+      }
+    }
+  }
+};
+DefinedInfo2.prototype.defined = true;
+function mark2(values, key, value) {
+  if (value) {
+    values[key] = value;
+  }
+}
+var own$2 = {}.hasOwnProperty;
+function create5(definition2) {
+  const property = {};
+  const normal = {};
+  let prop;
+  for (prop in definition2.properties) {
+    if (own$2.call(definition2.properties, prop)) {
+      const value = definition2.properties[prop];
+      const info = new DefinedInfo2(prop, definition2.transform(definition2.attributes || {}, prop), value, definition2.space);
+      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
+        info.mustUseProperty = true;
+      }
+      property[prop] = info;
+      normal[normalize6(prop)] = prop;
+      normal[normalize6(info.attribute)] = prop;
+    }
+  }
+  return new Schema2(property, normal, definition2.space);
+}
+var xlink2 = create5({
+  space: "xlink",
+  transform(_, prop) {
+    return "xlink:" + prop.slice(5).toLowerCase();
+  },
+  properties: {
+    xLinkActuate: null,
+    xLinkArcRole: null,
+    xLinkHref: null,
+    xLinkRole: null,
+    xLinkShow: null,
+    xLinkTitle: null,
+    xLinkType: null
+  }
+});
+var xml2 = create5({
+  space: "xml",
+  transform(_, prop) {
+    return "xml:" + prop.slice(3).toLowerCase();
+  },
+  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
+});
+function caseSensitiveTransform2(attributes, attribute) {
+  return attribute in attributes ? attributes[attribute] : attribute;
+}
+function caseInsensitiveTransform2(attributes, property) {
+  return caseSensitiveTransform2(attributes, property.toLowerCase());
+}
+var xmlns2 = create5({
+  space: "xmlns",
+  attributes: { xmlnsxlink: "xmlns:xlink" },
+  transform: caseInsensitiveTransform2,
+  properties: { xmlns: null, xmlnsXLink: null }
+});
+var aria2 = create5({
+  transform(_, prop) {
+    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
+  },
+  properties: {
+    ariaActiveDescendant: null,
+    ariaAtomic: booleanish2,
+    ariaAutoComplete: null,
+    ariaBusy: booleanish2,
+    ariaChecked: booleanish2,
+    ariaColCount: number2,
+    ariaColIndex: number2,
+    ariaColSpan: number2,
+    ariaControls: spaceSeparated2,
+    ariaCurrent: null,
+    ariaDescribedBy: spaceSeparated2,
+    ariaDetails: null,
+    ariaDisabled: booleanish2,
+    ariaDropEffect: spaceSeparated2,
+    ariaErrorMessage: null,
+    ariaExpanded: booleanish2,
+    ariaFlowTo: spaceSeparated2,
+    ariaGrabbed: booleanish2,
+    ariaHasPopup: null,
+    ariaHidden: booleanish2,
+    ariaInvalid: null,
+    ariaKeyShortcuts: null,
+    ariaLabel: null,
+    ariaLabelledBy: spaceSeparated2,
+    ariaLevel: number2,
+    ariaLive: null,
+    ariaModal: booleanish2,
+    ariaMultiLine: booleanish2,
+    ariaMultiSelectable: booleanish2,
+    ariaOrientation: null,
+    ariaOwns: spaceSeparated2,
+    ariaPlaceholder: null,
+    ariaPosInSet: number2,
+    ariaPressed: booleanish2,
+    ariaReadOnly: booleanish2,
+    ariaRelevant: null,
+    ariaRequired: booleanish2,
+    ariaRoleDescription: spaceSeparated2,
+    ariaRowCount: number2,
+    ariaRowIndex: number2,
+    ariaRowSpan: number2,
+    ariaSelected: booleanish2,
+    ariaSetSize: number2,
+    ariaSort: null,
+    ariaValueMax: number2,
+    ariaValueMin: number2,
+    ariaValueNow: number2,
+    ariaValueText: null,
+    role: null
+  }
+});
+var html$1 = create5({
+  space: "html",
+  attributes: {
+    acceptcharset: "accept-charset",
+    classname: "class",
+    htmlfor: "for",
+    httpequiv: "http-equiv"
+  },
+  transform: caseInsensitiveTransform2,
+  mustUseProperty: ["checked", "multiple", "muted", "selected"],
+  properties: {
+    abbr: null,
+    accept: commaSeparated2,
+    acceptCharset: spaceSeparated2,
+    accessKey: spaceSeparated2,
+    action: null,
+    allow: null,
+    allowFullScreen: boolean2,
+    allowPaymentRequest: boolean2,
+    allowUserMedia: boolean2,
+    alt: null,
+    as: null,
+    async: boolean2,
+    autoCapitalize: null,
+    autoComplete: spaceSeparated2,
+    autoFocus: boolean2,
+    autoPlay: boolean2,
+    capture: boolean2,
+    charSet: null,
+    checked: boolean2,
+    cite: null,
+    className: spaceSeparated2,
+    cols: number2,
+    colSpan: null,
+    content: null,
+    contentEditable: booleanish2,
+    controls: boolean2,
+    controlsList: spaceSeparated2,
+    coords: number2 | commaSeparated2,
+    crossOrigin: null,
+    data: null,
+    dateTime: null,
+    decoding: null,
+    default: boolean2,
+    defer: boolean2,
+    dir: null,
+    dirName: null,
+    disabled: boolean2,
+    download: overloadedBoolean2,
+    draggable: booleanish2,
+    encType: null,
+    enterKeyHint: null,
+    form: null,
+    formAction: null,
+    formEncType: null,
+    formMethod: null,
+    formNoValidate: boolean2,
+    formTarget: null,
+    headers: spaceSeparated2,
+    height: number2,
+    hidden: boolean2,
+    high: number2,
+    href: null,
+    hrefLang: null,
+    htmlFor: spaceSeparated2,
+    httpEquiv: spaceSeparated2,
+    id: null,
+    imageSizes: null,
+    imageSrcSet: null,
+    inputMode: null,
+    integrity: null,
+    is: null,
+    isMap: boolean2,
+    itemId: null,
+    itemProp: spaceSeparated2,
+    itemRef: spaceSeparated2,
+    itemScope: boolean2,
+    itemType: spaceSeparated2,
+    kind: null,
+    label: null,
+    lang: null,
+    language: null,
+    list: null,
+    loading: null,
+    loop: boolean2,
+    low: number2,
+    manifest: null,
+    max: null,
+    maxLength: number2,
+    media: null,
+    method: null,
+    min: null,
+    minLength: number2,
+    multiple: boolean2,
+    muted: boolean2,
+    name: null,
+    nonce: null,
+    noModule: boolean2,
+    noValidate: boolean2,
+    onAbort: null,
+    onAfterPrint: null,
+    onAuxClick: null,
+    onBeforePrint: null,
+    onBeforeUnload: null,
+    onBlur: null,
+    onCancel: null,
+    onCanPlay: null,
+    onCanPlayThrough: null,
+    onChange: null,
+    onClick: null,
+    onClose: null,
+    onContextLost: null,
+    onContextMenu: null,
+    onContextRestored: null,
+    onCopy: null,
+    onCueChange: null,
+    onCut: null,
+    onDblClick: null,
+    onDrag: null,
+    onDragEnd: null,
+    onDragEnter: null,
+    onDragExit: null,
+    onDragLeave: null,
+    onDragOver: null,
+    onDragStart: null,
+    onDrop: null,
+    onDurationChange: null,
+    onEmptied: null,
+    onEnded: null,
+    onError: null,
+    onFocus: null,
+    onFormData: null,
+    onHashChange: null,
+    onInput: null,
+    onInvalid: null,
+    onKeyDown: null,
+    onKeyPress: null,
+    onKeyUp: null,
+    onLanguageChange: null,
+    onLoad: null,
+    onLoadedData: null,
+    onLoadedMetadata: null,
+    onLoadEnd: null,
+    onLoadStart: null,
+    onMessage: null,
+    onMessageError: null,
+    onMouseDown: null,
+    onMouseEnter: null,
+    onMouseLeave: null,
+    onMouseMove: null,
+    onMouseOut: null,
+    onMouseOver: null,
+    onMouseUp: null,
+    onOffline: null,
+    onOnline: null,
+    onPageHide: null,
+    onPageShow: null,
+    onPaste: null,
+    onPause: null,
+    onPlay: null,
+    onPlaying: null,
+    onPopState: null,
+    onProgress: null,
+    onRateChange: null,
+    onRejectionHandled: null,
+    onReset: null,
+    onResize: null,
+    onScroll: null,
+    onSecurityPolicyViolation: null,
+    onSeeked: null,
+    onSeeking: null,
+    onSelect: null,
+    onSlotChange: null,
+    onStalled: null,
+    onStorage: null,
+    onSubmit: null,
+    onSuspend: null,
+    onTimeUpdate: null,
+    onToggle: null,
+    onUnhandledRejection: null,
+    onUnload: null,
+    onVolumeChange: null,
+    onWaiting: null,
+    onWheel: null,
+    open: boolean2,
+    optimum: number2,
+    pattern: null,
+    ping: spaceSeparated2,
+    placeholder: null,
+    playsInline: boolean2,
+    poster: null,
+    preload: null,
+    readOnly: boolean2,
+    referrerPolicy: null,
+    rel: spaceSeparated2,
+    required: boolean2,
+    reversed: boolean2,
+    rows: number2,
+    rowSpan: number2,
+    sandbox: spaceSeparated2,
+    scope: null,
+    scoped: boolean2,
+    seamless: boolean2,
+    selected: boolean2,
+    shape: null,
+    size: number2,
+    sizes: null,
+    slot: null,
+    span: number2,
+    spellCheck: booleanish2,
+    src: null,
+    srcDoc: null,
+    srcLang: null,
+    srcSet: null,
+    start: number2,
+    step: null,
+    style: null,
+    tabIndex: number2,
+    target: null,
+    title: null,
+    translate: null,
+    type: null,
+    typeMustMatch: boolean2,
+    useMap: null,
+    value: booleanish2,
+    width: number2,
+    wrap: null,
+    align: null,
+    aLink: null,
+    archive: spaceSeparated2,
+    axis: null,
+    background: null,
+    bgColor: null,
+    border: number2,
+    borderColor: null,
+    bottomMargin: number2,
+    cellPadding: null,
+    cellSpacing: null,
+    char: null,
+    charOff: null,
+    classId: null,
+    clear: null,
+    code: null,
+    codeBase: null,
+    codeType: null,
+    color: null,
+    compact: boolean2,
+    declare: boolean2,
+    event: null,
+    face: null,
+    frame: null,
+    frameBorder: null,
+    hSpace: number2,
+    leftMargin: number2,
+    link: null,
+    longDesc: null,
+    lowSrc: null,
+    marginHeight: number2,
+    marginWidth: number2,
+    noResize: boolean2,
+    noHref: boolean2,
+    noShade: boolean2,
+    noWrap: boolean2,
+    object: null,
+    profile: null,
+    prompt: null,
+    rev: null,
+    rightMargin: number2,
+    rules: null,
+    scheme: null,
+    scrolling: booleanish2,
+    standby: null,
+    summary: null,
+    text: null,
+    topMargin: number2,
+    valueType: null,
+    version: null,
+    vAlign: null,
+    vLink: null,
+    vSpace: number2,
+    allowTransparency: null,
+    autoCorrect: null,
+    autoSave: null,
+    disablePictureInPicture: boolean2,
+    disableRemotePlayback: boolean2,
+    prefix: null,
+    property: null,
+    results: number2,
+    security: null,
+    unselectable: null
+  }
+});
+var svg$1 = create5({
+  space: "svg",
+  attributes: {
+    accentHeight: "accent-height",
+    alignmentBaseline: "alignment-baseline",
+    arabicForm: "arabic-form",
+    baselineShift: "baseline-shift",
+    capHeight: "cap-height",
+    className: "class",
+    clipPath: "clip-path",
+    clipRule: "clip-rule",
+    colorInterpolation: "color-interpolation",
+    colorInterpolationFilters: "color-interpolation-filters",
+    colorProfile: "color-profile",
+    colorRendering: "color-rendering",
+    crossOrigin: "crossorigin",
+    dataType: "datatype",
+    dominantBaseline: "dominant-baseline",
+    enableBackground: "enable-background",
+    fillOpacity: "fill-opacity",
+    fillRule: "fill-rule",
+    floodColor: "flood-color",
+    floodOpacity: "flood-opacity",
+    fontFamily: "font-family",
+    fontSize: "font-size",
+    fontSizeAdjust: "font-size-adjust",
+    fontStretch: "font-stretch",
+    fontStyle: "font-style",
+    fontVariant: "font-variant",
+    fontWeight: "font-weight",
+    glyphName: "glyph-name",
+    glyphOrientationHorizontal: "glyph-orientation-horizontal",
+    glyphOrientationVertical: "glyph-orientation-vertical",
+    hrefLang: "hreflang",
+    horizAdvX: "horiz-adv-x",
+    horizOriginX: "horiz-origin-x",
+    horizOriginY: "horiz-origin-y",
+    imageRendering: "image-rendering",
+    letterSpacing: "letter-spacing",
+    lightingColor: "lighting-color",
+    markerEnd: "marker-end",
+    markerMid: "marker-mid",
+    markerStart: "marker-start",
+    navDown: "nav-down",
+    navDownLeft: "nav-down-left",
+    navDownRight: "nav-down-right",
+    navLeft: "nav-left",
+    navNext: "nav-next",
+    navPrev: "nav-prev",
+    navRight: "nav-right",
+    navUp: "nav-up",
+    navUpLeft: "nav-up-left",
+    navUpRight: "nav-up-right",
+    onAbort: "onabort",
+    onActivate: "onactivate",
+    onAfterPrint: "onafterprint",
+    onBeforePrint: "onbeforeprint",
+    onBegin: "onbegin",
+    onCancel: "oncancel",
+    onCanPlay: "oncanplay",
+    onCanPlayThrough: "oncanplaythrough",
+    onChange: "onchange",
+    onClick: "onclick",
+    onClose: "onclose",
+    onCopy: "oncopy",
+    onCueChange: "oncuechange",
+    onCut: "oncut",
+    onDblClick: "ondblclick",
+    onDrag: "ondrag",
+    onDragEnd: "ondragend",
+    onDragEnter: "ondragenter",
+    onDragExit: "ondragexit",
+    onDragLeave: "ondragleave",
+    onDragOver: "ondragover",
+    onDragStart: "ondragstart",
+    onDrop: "ondrop",
+    onDurationChange: "ondurationchange",
+    onEmptied: "onemptied",
+    onEnd: "onend",
+    onEnded: "onended",
+    onError: "onerror",
+    onFocus: "onfocus",
+    onFocusIn: "onfocusin",
+    onFocusOut: "onfocusout",
+    onHashChange: "onhashchange",
+    onInput: "oninput",
+    onInvalid: "oninvalid",
+    onKeyDown: "onkeydown",
+    onKeyPress: "onkeypress",
+    onKeyUp: "onkeyup",
+    onLoad: "onload",
+    onLoadedData: "onloadeddata",
+    onLoadedMetadata: "onloadedmetadata",
+    onLoadStart: "onloadstart",
+    onMessage: "onmessage",
+    onMouseDown: "onmousedown",
+    onMouseEnter: "onmouseenter",
+    onMouseLeave: "onmouseleave",
+    onMouseMove: "onmousemove",
+    onMouseOut: "onmouseout",
+    onMouseOver: "onmouseover",
+    onMouseUp: "onmouseup",
+    onMouseWheel: "onmousewheel",
+    onOffline: "onoffline",
+    onOnline: "ononline",
+    onPageHide: "onpagehide",
+    onPageShow: "onpageshow",
+    onPaste: "onpaste",
+    onPause: "onpause",
+    onPlay: "onplay",
+    onPlaying: "onplaying",
+    onPopState: "onpopstate",
+    onProgress: "onprogress",
+    onRateChange: "onratechange",
+    onRepeat: "onrepeat",
+    onReset: "onreset",
+    onResize: "onresize",
+    onScroll: "onscroll",
+    onSeeked: "onseeked",
+    onSeeking: "onseeking",
+    onSelect: "onselect",
+    onShow: "onshow",
+    onStalled: "onstalled",
+    onStorage: "onstorage",
+    onSubmit: "onsubmit",
+    onSuspend: "onsuspend",
+    onTimeUpdate: "ontimeupdate",
+    onToggle: "ontoggle",
+    onUnload: "onunload",
+    onVolumeChange: "onvolumechange",
+    onWaiting: "onwaiting",
+    onZoom: "onzoom",
+    overlinePosition: "overline-position",
+    overlineThickness: "overline-thickness",
+    paintOrder: "paint-order",
+    panose1: "panose-1",
+    pointerEvents: "pointer-events",
+    referrerPolicy: "referrerpolicy",
+    renderingIntent: "rendering-intent",
+    shapeRendering: "shape-rendering",
+    stopColor: "stop-color",
+    stopOpacity: "stop-opacity",
+    strikethroughPosition: "strikethrough-position",
+    strikethroughThickness: "strikethrough-thickness",
+    strokeDashArray: "stroke-dasharray",
+    strokeDashOffset: "stroke-dashoffset",
+    strokeLineCap: "stroke-linecap",
+    strokeLineJoin: "stroke-linejoin",
+    strokeMiterLimit: "stroke-miterlimit",
+    strokeOpacity: "stroke-opacity",
+    strokeWidth: "stroke-width",
+    tabIndex: "tabindex",
+    textAnchor: "text-anchor",
+    textDecoration: "text-decoration",
+    textRendering: "text-rendering",
+    typeOf: "typeof",
+    underlinePosition: "underline-position",
+    underlineThickness: "underline-thickness",
+    unicodeBidi: "unicode-bidi",
+    unicodeRange: "unicode-range",
+    unitsPerEm: "units-per-em",
+    vAlphabetic: "v-alphabetic",
+    vHanging: "v-hanging",
+    vIdeographic: "v-ideographic",
+    vMathematical: "v-mathematical",
+    vectorEffect: "vector-effect",
+    vertAdvY: "vert-adv-y",
+    vertOriginX: "vert-origin-x",
+    vertOriginY: "vert-origin-y",
+    wordSpacing: "word-spacing",
+    writingMode: "writing-mode",
+    xHeight: "x-height",
+    playbackOrder: "playbackorder",
+    timelineBegin: "timelinebegin"
+  },
+  transform: caseSensitiveTransform2,
+  properties: {
+    about: commaOrSpaceSeparated2,
+    accentHeight: number2,
+    accumulate: null,
+    additive: null,
+    alignmentBaseline: null,
+    alphabetic: number2,
+    amplitude: number2,
+    arabicForm: null,
+    ascent: number2,
+    attributeName: null,
+    attributeType: null,
+    azimuth: number2,
+    bandwidth: null,
+    baselineShift: null,
+    baseFrequency: null,
+    baseProfile: null,
+    bbox: null,
+    begin: null,
+    bias: number2,
+    by: null,
+    calcMode: null,
+    capHeight: number2,
+    className: spaceSeparated2,
+    clip: null,
+    clipPath: null,
+    clipPathUnits: null,
+    clipRule: null,
+    color: null,
+    colorInterpolation: null,
+    colorInterpolationFilters: null,
+    colorProfile: null,
+    colorRendering: null,
+    content: null,
+    contentScriptType: null,
+    contentStyleType: null,
+    crossOrigin: null,
+    cursor: null,
+    cx: null,
+    cy: null,
+    d: null,
+    dataType: null,
+    defaultAction: null,
+    descent: number2,
+    diffuseConstant: number2,
+    direction: null,
+    display: null,
+    dur: null,
+    divisor: number2,
+    dominantBaseline: null,
+    download: boolean2,
+    dx: null,
+    dy: null,
+    edgeMode: null,
+    editable: null,
+    elevation: number2,
+    enableBackground: null,
+    end: null,
+    event: null,
+    exponent: number2,
+    externalResourcesRequired: null,
+    fill: null,
+    fillOpacity: number2,
+    fillRule: null,
+    filter: null,
+    filterRes: null,
+    filterUnits: null,
+    floodColor: null,
+    floodOpacity: null,
+    focusable: null,
+    focusHighlight: null,
+    fontFamily: null,
+    fontSize: null,
+    fontSizeAdjust: null,
+    fontStretch: null,
+    fontStyle: null,
+    fontVariant: null,
+    fontWeight: null,
+    format: null,
+    fr: null,
+    from: null,
+    fx: null,
+    fy: null,
+    g1: commaSeparated2,
+    g2: commaSeparated2,
+    glyphName: commaSeparated2,
+    glyphOrientationHorizontal: null,
+    glyphOrientationVertical: null,
+    glyphRef: null,
+    gradientTransform: null,
+    gradientUnits: null,
+    handler: null,
+    hanging: number2,
+    hatchContentUnits: null,
+    hatchUnits: null,
+    height: null,
+    href: null,
+    hrefLang: null,
+    horizAdvX: number2,
+    horizOriginX: number2,
+    horizOriginY: number2,
+    id: null,
+    ideographic: number2,
+    imageRendering: null,
+    initialVisibility: null,
+    in: null,
+    in2: null,
+    intercept: number2,
+    k: number2,
+    k1: number2,
+    k2: number2,
+    k3: number2,
+    k4: number2,
+    kernelMatrix: commaOrSpaceSeparated2,
+    kernelUnitLength: null,
+    keyPoints: null,
+    keySplines: null,
+    keyTimes: null,
+    kerning: null,
+    lang: null,
+    lengthAdjust: null,
+    letterSpacing: null,
+    lightingColor: null,
+    limitingConeAngle: number2,
+    local: null,
+    markerEnd: null,
+    markerMid: null,
+    markerStart: null,
+    markerHeight: null,
+    markerUnits: null,
+    markerWidth: null,
+    mask: null,
+    maskContentUnits: null,
+    maskUnits: null,
+    mathematical: null,
+    max: null,
+    media: null,
+    mediaCharacterEncoding: null,
+    mediaContentEncodings: null,
+    mediaSize: number2,
+    mediaTime: null,
+    method: null,
+    min: null,
+    mode: null,
+    name: null,
+    navDown: null,
+    navDownLeft: null,
+    navDownRight: null,
+    navLeft: null,
+    navNext: null,
+    navPrev: null,
+    navRight: null,
+    navUp: null,
+    navUpLeft: null,
+    navUpRight: null,
+    numOctaves: null,
+    observer: null,
+    offset: null,
+    onAbort: null,
+    onActivate: null,
+    onAfterPrint: null,
+    onBeforePrint: null,
+    onBegin: null,
+    onCancel: null,
+    onCanPlay: null,
+    onCanPlayThrough: null,
+    onChange: null,
+    onClick: null,
+    onClose: null,
+    onCopy: null,
+    onCueChange: null,
+    onCut: null,
+    onDblClick: null,
+    onDrag: null,
+    onDragEnd: null,
+    onDragEnter: null,
+    onDragExit: null,
+    onDragLeave: null,
+    onDragOver: null,
+    onDragStart: null,
+    onDrop: null,
+    onDurationChange: null,
+    onEmptied: null,
+    onEnd: null,
+    onEnded: null,
+    onError: null,
+    onFocus: null,
+    onFocusIn: null,
+    onFocusOut: null,
+    onHashChange: null,
+    onInput: null,
+    onInvalid: null,
+    onKeyDown: null,
+    onKeyPress: null,
+    onKeyUp: null,
+    onLoad: null,
+    onLoadedData: null,
+    onLoadedMetadata: null,
+    onLoadStart: null,
+    onMessage: null,
+    onMouseDown: null,
+    onMouseEnter: null,
+    onMouseLeave: null,
+    onMouseMove: null,
+    onMouseOut: null,
+    onMouseOver: null,
+    onMouseUp: null,
+    onMouseWheel: null,
+    onOffline: null,
+    onOnline: null,
+    onPageHide: null,
+    onPageShow: null,
+    onPaste: null,
+    onPause: null,
+    onPlay: null,
+    onPlaying: null,
+    onPopState: null,
+    onProgress: null,
+    onRateChange: null,
+    onRepeat: null,
+    onReset: null,
+    onResize: null,
+    onScroll: null,
+    onSeeked: null,
+    onSeeking: null,
+    onSelect: null,
+    onShow: null,
+    onStalled: null,
+    onStorage: null,
+    onSubmit: null,
+    onSuspend: null,
+    onTimeUpdate: null,
+    onToggle: null,
+    onUnload: null,
+    onVolumeChange: null,
+    onWaiting: null,
+    onZoom: null,
+    opacity: null,
+    operator: null,
+    order: null,
+    orient: null,
+    orientation: null,
+    origin: null,
+    overflow: null,
+    overlay: null,
+    overlinePosition: number2,
+    overlineThickness: number2,
+    paintOrder: null,
+    panose1: null,
+    path: null,
+    pathLength: number2,
+    patternContentUnits: null,
+    patternTransform: null,
+    patternUnits: null,
+    phase: null,
+    ping: spaceSeparated2,
+    pitch: null,
+    playbackOrder: null,
+    pointerEvents: null,
+    points: null,
+    pointsAtX: number2,
+    pointsAtY: number2,
+    pointsAtZ: number2,
+    preserveAlpha: null,
+    preserveAspectRatio: null,
+    primitiveUnits: null,
+    propagate: null,
+    property: commaOrSpaceSeparated2,
+    r: null,
+    radius: null,
+    referrerPolicy: null,
+    refX: null,
+    refY: null,
+    rel: commaOrSpaceSeparated2,
+    rev: commaOrSpaceSeparated2,
+    renderingIntent: null,
+    repeatCount: null,
+    repeatDur: null,
+    requiredExtensions: commaOrSpaceSeparated2,
+    requiredFeatures: commaOrSpaceSeparated2,
+    requiredFonts: commaOrSpaceSeparated2,
+    requiredFormats: commaOrSpaceSeparated2,
+    resource: null,
+    restart: null,
+    result: null,
+    rotate: null,
+    rx: null,
+    ry: null,
+    scale: null,
+    seed: null,
+    shapeRendering: null,
+    side: null,
+    slope: null,
+    snapshotTime: null,
+    specularConstant: number2,
+    specularExponent: number2,
+    spreadMethod: null,
+    spacing: null,
+    startOffset: null,
+    stdDeviation: null,
+    stemh: null,
+    stemv: null,
+    stitchTiles: null,
+    stopColor: null,
+    stopOpacity: null,
+    strikethroughPosition: number2,
+    strikethroughThickness: number2,
+    string: null,
+    stroke: null,
+    strokeDashArray: commaOrSpaceSeparated2,
+    strokeDashOffset: null,
+    strokeLineCap: null,
+    strokeLineJoin: null,
+    strokeMiterLimit: number2,
+    strokeOpacity: number2,
+    strokeWidth: null,
+    style: null,
+    surfaceScale: number2,
+    syncBehavior: null,
+    syncBehaviorDefault: null,
+    syncMaster: null,
+    syncTolerance: null,
+    syncToleranceDefault: null,
+    systemLanguage: commaOrSpaceSeparated2,
+    tabIndex: number2,
+    tableValues: null,
+    target: null,
+    targetX: number2,
+    targetY: number2,
+    textAnchor: null,
+    textDecoration: null,
+    textRendering: null,
+    textLength: null,
+    timelineBegin: null,
+    title: null,
+    transformBehavior: null,
+    type: null,
+    typeOf: commaOrSpaceSeparated2,
+    to: null,
+    transform: null,
+    u1: null,
+    u2: null,
+    underlinePosition: number2,
+    underlineThickness: number2,
+    unicode: null,
+    unicodeBidi: null,
+    unicodeRange: null,
+    unitsPerEm: number2,
+    values: null,
+    vAlphabetic: number2,
+    vMathematical: number2,
+    vectorEffect: null,
+    vHanging: number2,
+    vIdeographic: number2,
+    version: null,
+    vertAdvY: number2,
+    vertOriginX: number2,
+    vertOriginY: number2,
+    viewBox: null,
+    viewTarget: null,
+    visibility: null,
+    width: null,
+    widths: null,
+    wordSpacing: null,
+    writingMode: null,
+    x: null,
+    x1: null,
+    x2: null,
+    xChannelSelector: null,
+    xHeight: number2,
+    y: null,
+    y1: null,
+    y2: null,
+    yChannelSelector: null,
+    z: null,
+    zoomAndPan: null
+  }
+});
+var valid2 = /^data[-\w.:]+$/i;
+var dash2 = /-[a-z]/g;
+var cap2 = /[A-Z]/g;
+function find2(schema, value) {
+  const normal = normalize6(value);
+  let prop = value;
+  let Type = Info2;
+  if (normal in schema.normal) {
+    return schema.property[schema.normal[normal]];
+  }
+  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid2.test(value)) {
+    if (value.charAt(4) === "-") {
+      const rest = value.slice(5).replace(dash2, camelcase$1);
+      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
+    } else {
+      const rest = value.slice(4);
+      if (!dash2.test(rest)) {
+        let dashes = rest.replace(cap2, kebab2);
+        if (dashes.charAt(0) !== "-") {
+          dashes = "-" + dashes;
+        }
+        value = "data" + dashes;
+      }
+    }
+    Type = DefinedInfo2;
+  }
+  return new Type(prop, value);
+}
+function kebab2($0) {
+  return "-" + $0.toLowerCase();
+}
+function camelcase$1($0) {
+  return $0.charAt(1).toUpperCase();
+}
+var html4 = merge2([xml2, xlink2, xmlns2, aria2, html$1], "html");
+var svg3 = merge2([xml2, xlink2, xmlns2, aria2, svg$1], "svg");
+var search2 = /[#.]/g;
+var parseSelector = function(selector, defaultTagName = "div") {
+  var value = selector || "";
+  var props = {};
+  var start3 = 0;
+  var subvalue;
+  var previous3;
+  var match;
+  while (start3 < value.length) {
+    search2.lastIndex = start3;
+    match = search2.exec(value);
+    subvalue = value.slice(start3, match ? match.index : value.length);
+    if (subvalue) {
+      if (!previous3) {
+        defaultTagName = subvalue;
+      } else if (previous3 === "#") {
+        props.id = subvalue;
+      } else if (Array.isArray(props.className)) {
+        props.className.push(subvalue);
+      } else {
+        props.className = [subvalue];
+      }
+      start3 += subvalue.length;
+    }
+    if (match) {
+      previous3 = match[0];
+      start3++;
+    }
+  }
+  return {
+    type: "element",
+    tagName: defaultTagName,
+    properties: props,
+    children: []
+  };
+};
+function parse$1(value) {
+  const input = String(value || "").trim();
+  return input ? input.split(/[ \t\n\r\f]+/g) : [];
+}
+function parse4(value) {
+  var tokens = [];
+  var input = String(value || "");
+  var index3 = input.indexOf(",");
+  var start3 = 0;
+  var end;
+  var token;
+  while (!end) {
+    if (index3 === -1) {
+      index3 = input.length;
+      end = true;
+    }
+    token = input.slice(start3, index3).trim();
+    if (token || !end) {
+      tokens.push(token);
+    }
+    start3 = index3 + 1;
+    index3 = input.indexOf(",", start3);
+  }
+  return tokens;
+}
+var buttonTypes = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]);
+var own$1 = {}.hasOwnProperty;
+function core2(schema, defaultTagName, caseSensitive) {
+  const adjust = caseSensitive && createAdjustMap(caseSensitive);
+  const h2 = function(selector, properties, ...children) {
+    let index3 = -1;
+    let node;
+    if (selector === void 0 || selector === null) {
+      node = { type: "root", children: [] };
+      children.unshift(properties);
+    } else {
+      node = parseSelector(selector, defaultTagName);
+      node.tagName = node.tagName.toLowerCase();
+      if (adjust && own$1.call(adjust, node.tagName)) {
+        node.tagName = adjust[node.tagName];
+      }
+      if (isProperties(properties, node.tagName)) {
+        let key;
+        for (key in properties) {
+          if (own$1.call(properties, key)) {
+            addProperty(schema, node.properties, key, properties[key]);
+          }
+        }
+      } else {
+        children.unshift(properties);
+      }
+    }
+    while (++index3 < children.length) {
+      addChild(node.children, children[index3]);
+    }
+    if (node.type === "element" && node.tagName === "template") {
+      node.content = { type: "root", children: node.children };
+      node.children = [];
+    }
+    return node;
+  };
+  return h2;
+}
+function isProperties(value, name3) {
+  if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
+    return false;
+  }
+  if (name3 === "input" || !value.type || typeof value.type !== "string") {
+    return true;
+  }
+  if ("children" in value && Array.isArray(value.children)) {
+    return false;
+  }
+  if (name3 === "button") {
+    return buttonTypes.has(value.type.toLowerCase());
+  }
+  return !("value" in value);
+}
+function addProperty(schema, properties, key, value) {
+  const info = find2(schema, key);
+  let index3 = -1;
+  let result;
+  if (value === void 0 || value === null)
+    return;
+  if (typeof value === "number") {
+    if (Number.isNaN(value))
+      return;
+    result = value;
+  } else if (typeof value === "boolean") {
+    result = value;
+  } else if (typeof value === "string") {
+    if (info.spaceSeparated) {
+      result = parse$1(value);
+    } else if (info.commaSeparated) {
+      result = parse4(value);
+    } else if (info.commaOrSpaceSeparated) {
+      result = parse$1(parse4(value).join(" "));
+    } else {
+      result = parsePrimitive(info, info.property, value);
+    }
+  } else if (Array.isArray(value)) {
+    result = value.concat();
+  } else {
+    result = info.property === "style" ? style2(value) : String(value);
+  }
+  if (Array.isArray(result)) {
+    const finalResult = [];
+    while (++index3 < result.length) {
+      finalResult[index3] = parsePrimitive(info, info.property, result[index3]);
+    }
+    result = finalResult;
+  }
+  if (info.property === "className" && Array.isArray(properties.className)) {
+    result = properties.className.concat(result);
+  }
+  properties[info.property] = result;
+}
+function addChild(nodes2, value) {
+  let index3 = -1;
+  if (value === void 0 || value === null)
+    ;
+  else if (typeof value === "string" || typeof value === "number") {
+    nodes2.push({ type: "text", value: String(value) });
+  } else if (Array.isArray(value)) {
+    while (++index3 < value.length) {
+      addChild(nodes2, value[index3]);
+    }
+  } else if (typeof value === "object" && "type" in value) {
+    if (value.type === "root") {
+      addChild(nodes2, value.children);
+    } else {
+      nodes2.push(value);
+    }
+  } else {
+    throw new Error("Expected node, nodes, or string, got `" + value + "`");
+  }
+}
+function parsePrimitive(info, name3, value) {
+  if (typeof value === "string") {
+    if (info.number && value && !Number.isNaN(Number(value))) {
+      return Number(value);
+    }
+    if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize6(value) === normalize6(name3))) {
+      return true;
+    }
+  }
+  return value;
+}
+function style2(value) {
+  const result = [];
+  let key;
+  for (key in value) {
+    if (own$1.call(value, key)) {
+      result.push([key, value[key]].join(": "));
+    }
+  }
+  return result.join("; ");
+}
+function createAdjustMap(values) {
+  const result = {};
+  let index3 = -1;
+  while (++index3 < values.length) {
+    result[values[index3].toLowerCase()] = values[index3];
+  }
+  return result;
+}
+var h = core2(html4, "div");
+var svgCaseSensitiveTagNames = [
+  "altGlyph",
+  "altGlyphDef",
+  "altGlyphItem",
+  "animateColor",
+  "animateMotion",
+  "animateTransform",
+  "clipPath",
+  "feBlend",
+  "feColorMatrix",
+  "feComponentTransfer",
+  "feComposite",
+  "feConvolveMatrix",
+  "feDiffuseLighting",
+  "feDisplacementMap",
+  "feDistantLight",
+  "feDropShadow",
+  "feFlood",
+  "feFuncA",
+  "feFuncB",
+  "feFuncG",
+  "feFuncR",
+  "feGaussianBlur",
+  "feImage",
+  "feMerge",
+  "feMergeNode",
+  "feMorphology",
+  "feOffset",
+  "fePointLight",
+  "feSpecularLighting",
+  "feSpotLight",
+  "feTile",
+  "feTurbulence",
+  "foreignObject",
+  "glyphRef",
+  "linearGradient",
+  "radialGradient",
+  "solidColor",
+  "textArea",
+  "textPath"
+];
+var s = core2(svg3, "g", svgCaseSensitiveTagNames);
+function location(file) {
+  var value = String(file);
+  var indices = [];
+  var search3 = /\r?\n|\r/g;
+  while (search3.test(value)) {
+    indices.push(search3.lastIndex);
+  }
+  indices.push(value.length + 1);
+  return { toPoint, toOffset };
+  function toPoint(offset2) {
+    var index3 = -1;
+    if (offset2 > -1 && offset2 < indices[indices.length - 1]) {
+      while (++index3 < indices.length) {
+        if (indices[index3] > offset2) {
+          return {
+            line: index3 + 1,
+            column: offset2 - (indices[index3 - 1] || 0) + 1,
+            offset: offset2
+          };
+        }
+      }
+    }
+    return { line: void 0, column: void 0, offset: void 0 };
+  }
+  function toOffset(point4) {
+    var line = point4 && point4.line;
+    var column = point4 && point4.column;
+    var offset2;
+    if (typeof line === "number" && typeof column === "number" && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {
+      offset2 = (indices[line - 2] || 0) + column - 1 || 0;
+    }
+    return offset2 > -1 && offset2 < indices[indices.length - 1] ? offset2 : -1;
+  }
+}
+var webNamespaces = {
+  html: "http://www.w3.org/1999/xhtml",
+  mathml: "http://www.w3.org/1998/Math/MathML",
+  svg: "http://www.w3.org/2000/svg",
+  xlink: "http://www.w3.org/1999/xlink",
+  xml: "http://www.w3.org/XML/1998/namespace",
+  xmlns: "http://www.w3.org/2000/xmlns/"
+};
+var own15 = {}.hasOwnProperty;
+var map = {
+  "#document": root3,
+  "#document-fragment": root3,
+  "#text": text6,
+  "#comment": comment2,
+  "#documentType": doctype
+};
+function fromParse5(ast, options = {}) {
+  let settings;
+  let file;
+  if (isFile(options)) {
+    file = options;
+    settings = {};
+  } else {
+    file = options.file;
+    settings = options;
+  }
+  return transform({
+    schema: settings.space === "svg" ? svg3 : html4,
+    file,
+    verbose: settings.verbose,
+    location: false
+  }, ast);
+}
+function transform(ctx, ast) {
+  const schema = ctx.schema;
+  const fn = own15.call(map, ast.nodeName) ? map[ast.nodeName] : element2;
+  let children;
+  if ("tagName" in ast) {
+    ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg3 : html4;
+  }
+  if ("childNodes" in ast) {
+    children = nodes(ctx, ast.childNodes);
+  }
+  const result = fn(ctx, ast, children);
+  if ("sourceCodeLocation" in ast && ast.sourceCodeLocation && ctx.file) {
+    const position4 = createLocation(ctx, result, ast.sourceCodeLocation);
+    if (position4) {
+      ctx.location = true;
+      result.position = position4;
+    }
+  }
+  ctx.schema = schema;
+  return result;
+}
+function nodes(ctx, children) {
+  let index3 = -1;
+  const result = [];
+  while (++index3 < children.length) {
+    result[index3] = transform(ctx, children[index3]);
+  }
+  return result;
+}
+function root3(ctx, ast, children) {
+  const result = {
+    type: "root",
+    children,
+    data: { quirksMode: ast.mode === "quirks" || ast.mode === "limited-quirks" }
+  };
+  if (ctx.file && ctx.location) {
+    const doc = String(ctx.file);
+    const loc = location(doc);
+    result.position = {
+      start: loc.toPoint(0),
+      end: loc.toPoint(doc.length)
+    };
+  }
+  return result;
+}
+function doctype() {
+  return { type: "doctype" };
+}
+function text6(_, ast) {
+  return { type: "text", value: ast.value };
+}
+function comment2(_, ast) {
+  return { type: "comment", value: ast.data };
+}
+function element2(ctx, ast, children) {
+  const fn = ctx.schema.space === "svg" ? s : h;
+  let index3 = -1;
+  const props = {};
+  while (++index3 < ast.attrs.length) {
+    const attribute = ast.attrs[index3];
+    props[(attribute.prefix ? attribute.prefix + ":" : "") + attribute.name] = attribute.value;
+  }
+  const result = fn(ast.tagName, props, children);
+  if (result.tagName === "template" && "content" in ast) {
+    const pos = ast.sourceCodeLocation;
+    const startTag = pos && pos.startTag && position3(pos.startTag);
+    const endTag = pos && pos.endTag && position3(pos.endTag);
+    const content3 = transform(ctx, ast.content);
+    if (startTag && endTag && ctx.file) {
+      content3.position = { start: startTag.end, end: endTag.start };
+    }
+    result.content = content3;
+  }
+  return result;
+}
+function createLocation(ctx, node, location2) {
+  const result = position3(location2);
+  if (node.type === "element") {
+    const tail = node.children[node.children.length - 1];
+    if (result && !location2.endTag && tail && tail.position && tail.position.end) {
+      result.end = Object.assign({}, tail.position.end);
+    }
+    if (ctx.verbose) {
+      const props = {};
+      let key;
+      for (key in location2.attrs) {
+        if (own15.call(location2.attrs, key)) {
+          props[find2(ctx.schema, key).property] = position3(location2.attrs[key]);
+        }
+      }
+      node.data = {
+        position: {
+          opening: position3(location2.startTag),
+          closing: location2.endTag ? position3(location2.endTag) : null,
+          properties: props
+        }
+      };
+    }
+  }
+  return result;
+}
+function position3(loc) {
+  const start3 = point3({
+    line: loc.startLine,
+    column: loc.startCol,
+    offset: loc.startOffset
+  });
+  const end = point3({
+    line: loc.endLine,
+    column: loc.endCol,
+    offset: loc.endOffset
+  });
+  return start3 || end ? { start: start3, end } : null;
+}
+function point3(point4) {
+  return point4.line && point4.column ? point4 : null;
+}
+function isFile(value) {
+  return "messages" in value;
+}
+var errors = {
+  abandonedHeadElementChild: {
+    reason: "Unexpected metadata element after head",
+    description: "Unexpected element after head. Expected the element before `</head>`",
+    url: false
+  },
+  abruptClosingOfEmptyComment: {
+    reason: "Unexpected abruptly closed empty comment",
+    description: "Unexpected `>` or `->`. Expected `-->` to close comments"
+  },
+  abruptDoctypePublicIdentifier: {
+    reason: "Unexpected abruptly closed public identifier",
+    description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
+  },
+  abruptDoctypeSystemIdentifier: {
+    reason: "Unexpected abruptly closed system identifier",
+    description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
+  },
+  absenceOfDigitsInNumericCharacterReference: {
+    reason: "Unexpected non-digit at start of numeric character reference",
+    description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
+  },
+  cdataInHtmlContent: {
+    reason: "Unexpected CDATA section in HTML",
+    description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
+  },
+  characterReferenceOutsideUnicodeRange: {
+    reason: "Unexpected too big numeric character reference",
+    description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
+  },
+  closingOfElementWithOpenChildElements: {
+    reason: "Unexpected closing tag with open child elements",
+    description: "Unexpectedly closing tag. Expected other tags to be closed first",
+    url: false
+  },
+  controlCharacterInInputStream: {
+    reason: "Unexpected control character",
+    description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
+  },
+  controlCharacterReference: {
+    reason: "Unexpected control character reference",
+    description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
+  },
+  disallowedContentInNoscriptInHead: {
+    reason: "Disallowed content inside `<noscript>` in `<head>`",
+    description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
+    url: false
+  },
+  duplicateAttribute: {
+    reason: "Unexpected duplicate attribute",
+    description: "Unexpectedly double attribute. Expected attributes to occur only once"
+  },
+  endTagWithAttributes: {
+    reason: "Unexpected attribute on closing tag",
+    description: "Unexpected attribute. Expected `>` instead"
+  },
+  endTagWithTrailingSolidus: {
+    reason: "Unexpected slash at end of closing tag",
+    description: "Unexpected `%c-1`. Expected `>` instead"
+  },
+  endTagWithoutMatchingOpenElement: {
+    reason: "Unexpected unopened end tag",
+    description: "Unexpected end tag. Expected no end tag or another end tag",
+    url: false
+  },
+  eofBeforeTagName: {
+    reason: "Unexpected end of file",
+    description: "Unexpected end of file. Expected tag name instead"
+  },
+  eofInCdata: {
+    reason: "Unexpected end of file in CDATA",
+    description: "Unexpected end of file. Expected `]]>` to close the CDATA"
+  },
+  eofInComment: {
+    reason: "Unexpected end of file in comment",
+    description: "Unexpected end of file. Expected `-->` to close the comment"
+  },
+  eofInDoctype: {
+    reason: "Unexpected end of file in doctype",
+    description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
+  },
+  eofInElementThatCanContainOnlyText: {
+    reason: "Unexpected end of file in element that can only contain text",
+    description: "Unexpected end of file. Expected text or a closing tag",
+    url: false
+  },
+  eofInScriptHtmlCommentLikeText: {
+    reason: "Unexpected end of file in comment inside script",
+    description: "Unexpected end of file. Expected `-->` to close the comment"
+  },
+  eofInTag: {
+    reason: "Unexpected end of file in tag",
+    description: "Unexpected end of file. Expected `>` to close the tag"
+  },
+  incorrectlyClosedComment: {
+    reason: "Incorrectly closed comment",
+    description: "Unexpected `%c-1`. Expected `-->` to close the comment"
+  },
+  incorrectlyOpenedComment: {
+    reason: "Incorrectly opened comment",
+    description: "Unexpected `%c`. Expected `<!--` to open the comment"
+  },
+  invalidCharacterSequenceAfterDoctypeName: {
+    reason: "Invalid sequence after doctype name",
+    description: "Unexpected sequence at `%c`. Expected `public` or `system`"
+  },
+  invalidFirstCharacterOfTagName: {
+    reason: "Invalid first character in tag name",
+    description: "Unexpected `%c`. Expected an ASCII letter instead"
+  },
+  misplacedDoctype: {
+    reason: "Misplaced doctype",
+    description: "Unexpected doctype. Expected doctype before head",
+    url: false
+  },
+  misplacedStartTagForHeadElement: {
+    reason: "Misplaced `<head>` start tag",
+    description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
+    url: false
+  },
+  missingAttributeValue: {
+    reason: "Missing attribute value",
+    description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
+  },
+  missingDoctype: {
+    reason: "Missing doctype before other content",
+    description: "Expected a `<!doctype html>` before anything else",
+    url: false
+  },
+  missingDoctypeName: {
+    reason: "Missing doctype name",
+    description: "Unexpected doctype end at `%c`. Expected `html` instead"
+  },
+  missingDoctypePublicIdentifier: {
+    reason: "Missing public identifier in doctype",
+    description: "Unexpected `%c`. Expected identifier for `public` instead"
+  },
+  missingDoctypeSystemIdentifier: {
+    reason: "Missing system identifier in doctype",
+    description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
+  },
+  missingEndTagName: {
+    reason: "Missing name in end tag",
+    description: "Unexpected `%c`. Expected an ASCII letter instead"
+  },
+  missingQuoteBeforeDoctypePublicIdentifier: {
+    reason: "Missing quote before public identifier in doctype",
+    description: "Unexpected `%c`. Expected `\"` or `'` instead"
+  },
+  missingQuoteBeforeDoctypeSystemIdentifier: {
+    reason: "Missing quote before system identifier in doctype",
+    description: "Unexpected `%c`. Expected `\"` or `'` instead"
+  },
+  missingSemicolonAfterCharacterReference: {
+    reason: "Missing semicolon after character reference",
+    description: "Unexpected `%c`. Expected `;` instead"
+  },
+  missingWhitespaceAfterDoctypePublicKeyword: {
+    reason: "Missing whitespace after public identifier in doctype",
+    description: "Unexpected `%c`. Expected ASCII whitespace instead"
+  },
+  missingWhitespaceAfterDoctypeSystemKeyword: {
+    reason: "Missing whitespace after system identifier in doctype",
+    description: "Unexpected `%c`. Expected ASCII whitespace instead"
+  },
+  missingWhitespaceBeforeDoctypeName: {
+    reason: "Missing whitespace before doctype name",
+    description: "Unexpected `%c`. Expected ASCII whitespace instead"
+  },
+  missingWhitespaceBetweenAttributes: {
+    reason: "Missing whitespace between attributes",
+    description: "Unexpected `%c`. Expected ASCII whitespace instead"
+  },
+  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
+    reason: "Missing whitespace between public and system identifiers in doctype",
+    description: "Unexpected `%c`. Expected ASCII whitespace instead"
+  },
+  nestedComment: {
+    reason: "Unexpected nested comment",
+    description: "Unexpected `<!--`. Expected `-->`"
+  },
+  nestedNoscriptInHead: {
+    reason: "Unexpected nested `<noscript>` in `<head>`",
+    description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
+    url: false
+  },
+  nonConformingDoctype: {
+    reason: "Unexpected non-conforming doctype declaration",
+    description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
+    url: false
+  },
+  nonVoidHtmlElementStartTagWithTrailingSolidus: {
+    reason: "Unexpected trailing slash on start tag of non-void element",
+    description: "Unexpected `/`. Expected `>` instead"
+  },
+  noncharacterCharacterReference: {
+    reason: "Unexpected noncharacter code point referenced by character reference",
+    description: "Unexpected code point. Do not use noncharacters in HTML"
+  },
+  noncharacterInInputStream: {
+    reason: "Unexpected noncharacter character",
+    description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
+  },
+  nullCharacterReference: {
+    reason: "Unexpected NULL character referenced by character reference",
+    description: "Unexpected code point. Do not use NULL characters in HTML"
+  },
+  openElementsLeftAfterEof: {
+    reason: "Unexpected end of file",
+    description: "Unexpected end of file. Expected closing tag instead",
+    url: false
+  },
+  surrogateCharacterReference: {
+    reason: "Unexpected surrogate character referenced by character reference",
+    description: "Unexpected code point. Do not use lone surrogate characters in HTML"
+  },
+  surrogateInInputStream: {
+    reason: "Unexpected surrogate character",
+    description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
+  },
+  unexpectedCharacterAfterDoctypeSystemIdentifier: {
+    reason: "Invalid character after system identifier in doctype",
+    description: "Unexpected character at `%c`. Expected `>`"
+  },
+  unexpectedCharacterInAttributeName: {
+    reason: "Unexpected character in attribute name",
+    description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
+  },
+  unexpectedCharacterInUnquotedAttributeValue: {
+    reason: "Unexpected character in unquoted attribute value",
+    description: "Unexpected `%c`. Quote the attribute value to include it"
+  },
+  unexpectedEqualsSignBeforeAttributeName: {
+    reason: "Unexpected equals sign before attribute name",
+    description: "Unexpected `%c`. Add an attribute name before it"
+  },
+  unexpectedNullCharacter: {
+    reason: "Unexpected NULL character",
+    description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
+  },
+  unexpectedQuestionMarkInsteadOfTagName: {
+    reason: "Unexpected question mark instead of tag name",
+    description: "Unexpected `%c`. Expected an ASCII letter instead"
+  },
+  unexpectedSolidusInTag: {
+    reason: "Unexpected slash in tag",
+    description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
+  },
+  unknownNamedCharacterReference: {
+    reason: "Unexpected unknown named character reference",
+    description: "Unexpected character reference. Expected known named character references"
+  }
+};
+var base2 = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-";
+var fatalities = { 2: true, 1: false, 0: null };
+function rehypeParse(options) {
+  const processorSettings = this.data("settings");
+  const settings = Object.assign({}, processorSettings, options);
+  Object.assign(this, { Parser: parser2 });
+  function parser2(doc, file) {
+    const fn = settings.fragment ? "parseFragment" : "parse";
+    const onParseError = settings.emitParseErrors ? onerror : null;
+    const parse5 = new Parser5({
+      sourceCodeLocationInfo: true,
+      onParseError,
+      scriptingEnabled: false
+    });
+    return fromParse5(parse5[fn](doc), {
+      space: settings.space,
+      file,
+      verbose: settings.verbose
+    });
+    function onerror(error) {
+      const code3 = error.code;
+      const name3 = camelcase2(code3);
+      const setting = settings[name3];
+      const config = setting === void 0 || setting === null ? true : setting;
+      const level = typeof config === "number" ? config : config ? 1 : 0;
+      const start3 = {
+        line: error.startLine,
+        column: error.startCol,
+        offset: error.startOffset
+      };
+      const end = {
+        line: error.endLine,
+        column: error.endCol,
+        offset: error.endOffset
+      };
+      if (level) {
+        const info = errors[name3] || { reason: "", description: "", url: "" };
+        const message = file.message(format(info.reason), { start: start3, end });
+        message.source = "parse-error";
+        message.ruleId = code3;
+        message.fatal = fatalities[level];
+        message.note = format(info.description);
+        message.url = "url" in info && info.url === false ? null : base2 + code3;
+      }
+      function format(value) {
+        return value.replace(/%c(?:-(\d+))?/g, (_, $1) => {
+          const offset2 = $1 ? -Number.parseInt($1, 10) : 0;
+          const char = doc.charAt(error.startOffset + offset2);
+          return char === "`" ? "` ` `" : char;
+        }).replace(/%x/g, () => "0x" + doc.charCodeAt(error.startOffset).toString(16).toUpperCase());
+      }
+    }
+  }
+}
+function camelcase2(value) {
+  return value.replace(/-[a-z]/g, ($0) => $0.charAt(1).toUpperCase());
+}
+var highlighterCache = /* @__PURE__ */ new Map();
+var hastParser = unified2().use(rehypeParse, { fragment: true });
+function toFragment({ node, trees, lang, inline = false }) {
+  node.tagName = inline ? "span" : "div";
+  node.properties = { "data-rehype-pretty-code-fragment": "" };
+  node.children = Object.entries(trees).map(([mode, tree]) => {
+    const pre = tree.children[0];
+    pre.properties = {};
+    const code3 = pre.children[0];
+    code3.properties["data-language"] = lang;
+    code3.properties["data-theme"] = mode;
+    if (inline) {
+      return code3;
+    }
+    return pre;
+  });
+}
+function rehypePrettyCode(options = {}) {
+  const {
+    theme,
+    tokensMap = {},
+    onVisitLine = () => {
+    },
+    onVisitHighlightedLine = () => {
+    },
+    onVisitHighlightedWord = () => {
+    },
+    getHighlighter = import_shiki.default.getHighlighter
+  } = options;
+  return (tree) => __async(this, null, function* () {
+    if (theme == null || typeof theme === "string" || (theme == null ? void 0 : theme.hasOwnProperty("tokenColors"))) {
+      if (!highlighterCache.has("default")) {
+        highlighterCache.set("default", getHighlighter({ theme }));
+      }
+    } else if (typeof theme === "object") {
+      for (const [mode, value] of Object.entries(theme)) {
+        if (!highlighterCache.has(mode)) {
+          highlighterCache.set(mode, getHighlighter({ theme: value }));
+        }
+      }
+    }
+    const highlighters = /* @__PURE__ */ new Map();
+    for (const [mode, loadHighlighter] of highlighterCache.entries()) {
+      highlighters.set(mode, yield loadHighlighter);
+    }
+    visit4(tree, "element", (node, index3, parent) => {
+      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
+      if (node.tagName === "code" && parent.tagName !== "pre" || node.tagName === "inlineCode") {
+        const value = node.children[0].value;
+        if (!value) {
+          return;
+        }
+        const stippedValue = value.replace(/{:[a-zA-Z.-]+}/, "");
+        const meta = (_a = value.match(/{:([a-zA-Z.-]+)}$/)) == null ? void 0 : _a[1];
+        if (!meta) {
+          return;
+        }
+        const isLang = meta[0] !== ".";
+        const trees = {};
+        for (const [mode, highlighter] of highlighters.entries()) {
+          if (!isLang) {
+            const color5 = (_c = (_b = highlighter.getTheme().settings.find(({ scope }) => {
+              var _a2;
+              return scope == null ? void 0 : scope.includes((_a2 = tokensMap[meta.slice(1)]) != null ? _a2 : meta.slice(1));
+            })) == null ? void 0 : _b.settings.foreground) != null ? _c : "inherit";
+            trees[mode] = hastParser.parse(`<pre><code><span style="color:${color5}">${stippedValue}</span></code></pre>`);
+          } else {
+            trees[mode] = hastParser.parse(highlighter.codeToHtml(stippedValue, meta));
+          }
+        }
+        toFragment({ node, trees, lang: isLang ? meta : ".token", inline: true });
+      }
+      if (node.tagName === "pre" && Array.isArray(node.children) && node.children.length === 1 && node.children[0].tagName === "code" && typeof node.children[0].properties === "object" && Array.isArray(node.children[0].properties.className) && typeof node.children[0].properties.className[0] === "string" && node.children[0].properties.className[0].startsWith("language-")) {
+        const codeNode = node.children[0].children[0];
+        const lang = node.children[0].properties.className[0].replace("language-", "");
+        const meta = (_e = (_d = node.children[0].data) == null ? void 0 : _d.meta) != null ? _e : node.children[0].properties.metastring;
+        const lineNumbers = meta ? (0, import_parse_numeric_range.default)((_g = (_f = meta.match(/{(.*)}/)) == null ? void 0 : _f[1]) != null ? _g : "") : [];
+        const word = (_h = meta == null ? void 0 : meta.match(/\/(.*)\//)) == null ? void 0 : _h[1];
+        const wordNumbers = meta ? (0, import_parse_numeric_range.default)((_j = (_i = meta.match(/\/.*\/([^\s]*)/)) == null ? void 0 : _i[1]) != null ? _j : "") : [];
+        const trees = {};
+        for (const [mode, highlighter] of highlighters.entries()) {
+          trees[mode] = hastParser.parse(highlighter.codeToHtml(codeNode.value.replace(/\n$/, ""), lang));
+        }
+        Object.entries(trees).forEach(([mode, tree2]) => {
+          let lineCounter = 0;
+          let wordCounter = 0;
+          visit4(tree2, "element", (node2) => {
+            var _a2;
+            if (((_a2 = node2.properties.className) == null ? void 0 : _a2[0]) === "line") {
+              onVisitLine(node2);
+              if (lineNumbers.length !== 0 && lineNumbers.includes(++lineCounter)) {
+                onVisitHighlightedLine(node2);
+              }
+              if (word) {
+                node2.children.forEach((child) => {
+                  var _a3, _b2;
+                  if ((_b2 = (_a3 = child.children) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.value.includes(word)) {
+                    if (wordNumbers.length === 0 || wordNumbers.includes(++wordCounter)) {
+                      const splits = child.children[0].value.split(word);
+                      const children = [];
+                      if (splits.length === 0) {
+                        onVisitHighlightedWord(child);
+                        return;
+                      }
+                      const node3 = {
+                        type: "element",
+                        tagName: "span",
+                        properties: {},
+                        children: [{ type: "text", value: word }]
+                      };
+                      splits.forEach((split, index4) => {
+                        const splitNode = {
+                          type: "element",
+                          tagName: "span",
+                          properties: {},
+                          children: [{ type: "text", value: split }]
+                        };
+                        if (index4 !== splits.length - 1) {
+                          if (split !== "") {
+                            children.push(splitNode);
+                          }
+                          children.push(node3);
+                        } else if (split !== "") {
+                          children.push(splitNode);
+                        }
+                      });
+                      if (children.length !== 0) {
+                        child.children = children;
+                      }
+                      onVisitHighlightedWord(node3);
+                    }
+                  }
+                });
+              }
+            }
+          });
+        });
+        toFragment({ node, trees, lang });
+      }
+    });
+  });
+}
+
+// src/mdx-plugins/static-image.js
+var relative = /^\.{1,2}\//;
+function visit5(node, type2, handler) {
+  if (node.type === type2) {
+    handler(node);
+  }
+  if (node.children) {
+    node.children.forEach((n) => visit5(n, type2, handler));
+  }
+}
+function ASTNodeImport(name3, from) {
+  return {
+    type: "mdxjsEsm",
+    value: `import ${name3} from "${from}"`,
+    data: {
+      estree: {
+        type: "Program",
+        body: [
+          {
+            type: "ImportDeclaration",
+            specifiers: [
+              {
+                type: "ImportDefaultSpecifier",
+                local: { type: "Identifier", name: name3 }
+              }
+            ],
+            source: {
+              type: "Literal",
+              value: from,
+              raw: `"${from}"`
+            }
+          }
+        ],
+        sourceType: "module"
+      }
+    }
+  };
+}
+function remarkStaticImage() {
+  return (tree, _file, done) => {
+    const importsToInject = [];
+    visit5(tree, "image", visitor);
+    tree.children.unshift(...importsToInject);
+    tree.children.unshift(ASTNodeImport("$NextImageNextra", "next/image"));
+    done();
+    function visitor(node) {
+      const url = node.url;
+      if (url && relative.test(url)) {
+        const tempVariableName = `$nextraImage${importsToInject.length}`;
+        Object.assign(node, {
+          type: "mdxJsxFlowElement",
+          name: "$NextImageNextra",
+          attributes: [
+            {
+              type: "mdxJsxAttribute",
+              name: "alt",
+              value: node.alt || ""
+            },
+            {
+              type: "mdxJsxAttribute",
+              name: "placeholder",
+              value: "blur"
+            },
+            {
+              type: "mdxJsxAttribute",
+              name: "src",
+              value: {
+                type: "mdxJsxAttributeValueExpression",
+                value: tempVariableName,
+                data: {
+                  estree: {
+                    type: "Program",
+                    body: [
+                      {
+                        type: "ExpressionStatement",
+                        expression: {
+                          type: "Identifier",
+                          name: tempVariableName
+                        }
+                      }
+                    ],
+                    sourceType: "module"
+                  }
+                }
+              }
+            }
+          ],
+          children: []
+        });
+        importsToInject.push(ASTNodeImport(tempVariableName, url));
+      }
+    }
+  };
+}
+
+// src/mdx-plugins/remark.ts
+function visit6(node, tester, handler) {
+  if (tester(node)) {
+    handler(node);
+  }
+  if (node.children) {
+    node.children.forEach((n) => visit6(n, tester, handler));
+  }
+}
+function getFlattenedValue(node) {
+  return node.children.map((child) => "children" in child ? getFlattenedValue(child) : "value" in child ? child.value : "").join("");
+}
+function remarkHeadings() {
+  const data2 = this.data();
+  return (tree, _file, done) => {
+    visit6(tree, (node) => {
+      return node.type === "heading" || node.name === "summary" || node.name === "details";
+    }, (node) => {
+      if (node.type === "heading") {
+        const heading2 = __spreadProps(__spreadValues({}, node), {
+          value: getFlattenedValue(node)
+        });
+        const headingMeta = data2.headingMeta;
+        if (node.depth === 1) {
+          headingMeta.hasH1 = true;
+          if (Array.isArray(node.children) && node.children.length === 1) {
+            const child = node.children[0];
+            if (child.type === "text") {
+              headingMeta.titleText = child.value;
+            }
+          }
+        }
+        headingMeta.headings.push(heading2);
+      } else if (node.name === "summary" || node.name === "details") {
+        if (node.data) {
+          delete node.data._mdxExplicitJsx;
+        }
+      }
+    });
+    done();
+  };
+}
+
+// src/mdx-plugins/structurize.js
+var import_github_slugger = __toESM(require_github_slugger());
+function cleanup(content3) {
+  return content3.trim().split("\n").map((line) => line.trim()).join("\n");
+}
+var structurize_default = (structurizedData, options) => {
+  if (typeof options === "boolean")
+    options = {};
+  options = Object.assign({ codeblocks: true }, options);
+  const slugger = new import_github_slugger.default();
+  let activeSlug = "";
+  let skip = false;
+  let content3 = "";
+  return function stripMarkdown() {
+    return (node) => {
+      walk3(node);
+      structurizedData[activeSlug] = cleanup(content3);
+      return node;
+    };
+    function walk3(node) {
+      let result = "";
+      const type2 = node.type;
+      if (type2 === "heading")
+        skip = true;
+      if (["code", "table", "blockquote", "list", "mdxJsxFlowElement"].includes(type2)) {
+        result += "\n";
+        if (!skip)
+          content3 += "\n";
+      }
+      if ("children" in node) {
+        for (let i = 0; i < node.children.length; i++) {
+          result += walk3(node.children[i]);
+        }
+      } else if ([
+        options.codeblocks ? "code" : "",
+        "text",
+        "inlineCode",
+        "tableCell"
+      ].includes(type2)) {
+        result += node.value;
+        if (!skip)
+          content3 += node.value;
+      }
+      if ([
+        "code",
+        "table",
+        "blockquote",
+        "list",
+        "listItem",
+        "break",
+        "mdxJsxFlowElement"
+      ].includes(type2)) {
+        result += "\n";
+        if (!skip)
+          content3 += "\n";
+      }
+      if (["tableCell"].includes(type2)) {
+        result += "	";
+        if (!skip)
+          content3 += "	";
+      }
+      if (type2 === "heading")
+        skip = false;
+      if (type2 === "heading" && node.depth > 1) {
+        structurizedData[activeSlug] = cleanup(content3);
+        content3 = "";
+        activeSlug = slugger.slug(result) + "#" + result;
+      }
+      return result;
+    }
+  };
+};
+
+// src/mdx-plugins/rehype-handler.js
+var import_github_slugger2 = __toESM(require_github_slugger());
+function visit7(node, tagNames, handler) {
+  if (tagNames.includes(node.tagName)) {
+    handler(node);
+    return;
+  }
+  if (node.children) {
+    node.children.forEach((n) => visit7(n, tagNames, handler));
+  }
+}
+function parseMeta() {
+  return (tree) => {
+    visit7(tree, ["pre"], (node) => {
+      var _a, _b, _c;
+      if (Array.isArray(node.children) && node.children.length === 1 && node.children[0].tagName === "code" && typeof node.children[0].properties === "object") {
+        const meta = (_b = (_a = node.children[0].data) == null ? void 0 : _a.meta) != null ? _b : node.children[0].properties.metastring;
+        if (meta) {
+          const filename = (_c = meta.match(/filename="([^"]+)"/)) == null ? void 0 : _c[1];
+          if (filename) {
+            node.__nextra_filename__ = filename;
+          }
+        }
+      }
+    });
+  };
+}
+function attachMeta() {
+  return (tree) => {
+    const slugger = new import_github_slugger2.default();
+    visit7(tree, ["div", "h2", "h3", "h4", "h5", "h6"], (node) => {
+      if (node.tagName === "div") {
+        if (!("data-rehype-pretty-code-fragment" in node.properties))
+          return;
+        node.properties["data-nextra-code"] = "";
+        if ("__nextra_filename__" in node) {
+          node.properties["data-filename"] = node.__nextra_filename__;
+        }
+      } else {
+        node.properties.id = node.properties.id || slugger.slug(getFlattenedValue(node));
+      }
+    });
+  };
+}
+
+// src/theme.json
+var name2 = "css-variables";
+var type = "light";
+var colors = {
+  "editor.foreground": "#000001",
+  "editor.background": "#000002"
+};
+var tokenColors = [
+  {
+    settings: {
+      foreground: "#000001"
+    }
+  },
+  {
+    scope: [
+      "markup.deleted",
+      "meta.diff.header.from-file",
+      "punctuation.definition.deleted"
+    ],
+    settings: {
+      foreground: "#ef6270"
+    }
+  },
+  {
+    scope: [
+      "markup.inserted",
+      "meta.diff.header.to-file",
+      "punctuation.definition.inserted"
+    ],
+    settings: {
+      foreground: "#4bb74a"
+    }
+  },
+  {
+    scope: [
+      "keyword.operator.accessor",
+      "meta.group.braces.round.function.arguments",
+      "meta.template.expression",
+      "markup.fenced_code meta.embedded.block"
+    ],
+    settings: {
+      foreground: "#000001"
+    }
+  },
+  {
+    scope: "emphasis",
+    settings: {
+      fontStyle: "italic"
+    }
+  },
+  {
+    scope: ["strong", "markup.heading.markdown", "markup.bold.markdown"],
+    settings: {
+      fontStyle: "bold"
+    }
+  },
+  {
+    scope: ["markup.italic.markdown"],
+    settings: {
+      fontStyle: "italic"
+    }
+  },
+  {
+    scope: "meta.link.inline.markdown",
+    settings: {
+      fontStyle: "underline",
+      foreground: "#000004"
+    }
+  },
+  {
+    scope: ["string", "markup.fenced_code", "markup.inline"],
+    settings: {
+      foreground: "#000005"
+    }
+  },
+  {
+    scope: ["comment", "string.quoted.docstring.multi"],
+    settings: {
+      foreground: "#000006"
+    }
+  },
+  {
+    scope: [
+      "constant.numeric",
+      "constant.language",
+      "constant.other.placeholder",
+      "constant.character.format.placeholder",
+      "variable.language.this",
+      "variable.other.object",
+      "variable.other.class",
+      "variable.other.constant",
+      "meta.property-name",
+      "meta.property-value",
+      "support"
+    ],
+    settings: {
+      foreground: "#000004"
+    }
+  },
+  {
+    scope: [
+      "keyword",
+      "storage.modifier",
+      "storage.type",
+      "storage.control.clojure",
+      "entity.name.function.clojure",
+      "entity.name.tag.yaml",
+      "support.function.node",
+      "support.type.property-name.json",
+      "punctuation.separator.key-value",
+      "punctuation.definition.template-expression"
+    ],
+    settings: {
+      foreground: "#000007"
+    }
+  },
+  {
+    scope: "variable.parameter.function",
+    settings: {
+      foreground: "#000008"
+    }
+  },
+  {
+    scope: [
+      "support.function",
+      "entity.name.type",
+      "entity.other.inherited-class",
+      "meta.function-call",
+      "meta.instance.constructor",
+      "entity.other.attribute-name",
+      "entity.name.function",
+      "constant.keyword.clojure"
+    ],
+    settings: {
+      foreground: "#000009"
+    }
+  },
+  {
+    scope: [
+      "entity.name.tag",
+      "string.quoted",
+      "string.regexp",
+      "string.interpolated",
+      "string.template",
+      "string.unquoted.plain.out.yaml",
+      "keyword.other.template"
+    ],
+    settings: {
+      foreground: "#000010"
+    }
+  },
+  {
+    scope: [
+      "punctuation.definition.arguments",
+      "punctuation.definition.dict",
+      "punctuation.separator",
+      "meta.function-call.arguments"
+    ],
+    settings: {
+      foreground: "#000011"
+    }
+  },
+  {
+    name: "[Custom] Markdown links",
+    scope: [
+      "markup.underline.link",
+      "punctuation.definition.metadata.markdown"
+    ],
+    settings: {
+      foreground: "#000012"
+    }
+  },
+  {
+    name: "[Custom] Markdown list",
+    scope: ["beginning.punctuation.definition.list.markdown"],
+    settings: {
+      foreground: "#000005"
+    }
+  },
+  {
+    name: "[Custom] Markdown punctuation definition brackets",
+    scope: [
+      "punctuation.definition.string.begin.markdown",
+      "punctuation.definition.string.end.markdown",
+      "string.other.link.title.markdown",
+      "string.other.link.description.markdown"
+    ],
+    settings: {
+      foreground: "#000007"
+    }
+  }
+];
+var theme_default = {
+  name: name2,
+  type,
+  colors,
+  tokenColors
+};
+
+// src/compile.ts
+var createCompiler = (mdxOptions) => {
+  const compiler2 = createProcessor(mdxOptions);
+  compiler2.data("headingMeta", {
+    hasH1: false,
+    headings: []
+  });
+  return compiler2;
+};
+var addHighlightedClass = (node) => {
+  var _a;
+  (_a = node.properties).className || (_a.className = []);
+  node.properties.className.push("highlighted");
+};
+var rehypePrettyCodeOptions = {
+  theme: theme_default,
+  onVisitHighlightedLine: addHighlightedClass,
+  onVisitHighlightedWord: addHighlightedClass
+};
+function compileMdx(_0) {
+  return __async(this, arguments, function* (source, mdxOptions = {}, nextraOptions = {
+    unstable_staticImage: false,
+    unstable_flexsearch: false
+  }, resourcePath) {
+    let structurizedData = {};
+    const compiler2 = createCompiler({
+      jsx: true,
+      providerImportSource: "@mdx-js/react",
+      remarkPlugins: [
+        ...mdxOptions.remarkPlugins || [],
+        remarkGfm,
+        remarkHeadings,
+        ...nextraOptions.unstable_staticImage ? [remarkStaticImage] : [],
+        ...nextraOptions.unstable_flexsearch ? [structurize_default(structurizedData, nextraOptions.unstable_flexsearch)] : []
+      ].filter(Boolean),
+      rehypePlugins: [
+        ...mdxOptions.rehypePlugins || [],
+        parseMeta,
+        [rehypePrettyCode, rehypePrettyCodeOptions],
+        attachMeta
+      ].filter(Boolean)
+    });
+    try {
+      const result = yield compiler2.process(source);
+      return __spreadProps(__spreadValues({
+        result: String(result)
+      }, compiler2.data("headingMeta")), {
+        structurizedData
+      });
+    } catch (err) {
+      console.error(`
+Error compiling ${resourcePath}
+${err}
+`);
+      throw err;
+    }
+  });
+}
+export {
+  compileMdx
+};
+/*!
+ * Determine if an object is a Buffer
+ *
+ * @author   Feross Aboukhadijeh <https://feross.org>
+ * @license  MIT
+ */
diff --git a/node_modules/nextra/dist/index.js b/node_modules/nextra/dist/index.js
index d288128..0a77464 100644
--- a/node_modules/nextra/dist/index.js
+++ b/node_modules/nextra/dist/index.js
@@ -231,16 +231,13 @@ var NextraPlugin = class {
   }
 };
 
-// src/index.js
+// src/index.ts
 var defaultExtensions = ["js", "jsx", "ts", "tsx"];
 var markdownExtensions = ["md", "mdx"];
 var markdownExtensionTest = /\.mdx?$/;
 module.exports = (...args) => (nextConfig = {}) => {
   var _a, _b;
-  const nextraConfig = typeof args[0] === "string" ? {
-    theme: args[0],
-    themeConfig: args[1]
-  } : args[0];
+  const nextraConfig = typeof args[0] === "string" ? { theme: args[0], themeConfig: args[1] } : args[0];
   const locales = ((_a = nextConfig.i18n) == null ? void 0 : _a.locales) || null;
   const defaultLocale = ((_b = nextConfig.i18n) == null ? void 0 : _b.defaultLocale) || null;
   let pageExtensions = nextConfig.pageExtensions || [...defaultExtensions];
diff --git a/node_modules/nextra/dist/loader.mjs b/node_modules/nextra/dist/loader.mjs
index 486c1fb..fcf6cda 100644
--- a/node_modules/nextra/dist/loader.mjs
+++ b/node_modules/nextra/dist/loader.mjs
@@ -599,20 +599,15 @@ var createCompiler = (mdxOptions) => {
   });
   return compiler;
 };
+var addHighlightedClass = (node) => {
+  var _a;
+  (_a = node.properties).className || (_a.className = []);
+  node.properties.className.push("highlighted");
+};
 var rehypePrettyCodeOptions = {
   theme: theme_default,
-  onVisitHighlightedLine(node) {
-    if (!node.properties.className) {
-      node.properties.className = [];
-    }
-    node.properties.className.push("highlighted");
-  },
-  onVisitHighlightedWord(node) {
-    if (!node.properties.className) {
-      node.properties.className = [];
-    }
-    node.properties.className.push("highlighted");
-  }
+  onVisitHighlightedLine: addHighlightedClass,
+  onVisitHighlightedWord: addHighlightedClass
 };
 function compileMdx(_0) {
   return __async(this, arguments, function* (source, mdxOptions = {}, nextraOptions = {
@@ -646,8 +641,8 @@ function compileMdx(_0) {
       });
     } catch (err) {
       console.error(`
-Error compiling ${resourcePath}`);
-      console.error(`${err}
+Error compiling ${resourcePath}
+${err}
 `);
       throw err;
     }
diff --git a/node_modules/nextra/index.js b/node_modules/nextra/index.js
deleted file mode 100755
index aae5903..0000000
--- a/node_modules/nextra/index.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/index')
diff --git a/node_modules/nextra/locales.js b/node_modules/nextra/locales.js
deleted file mode 100644
index 0adc2a7..0000000
--- a/node_modules/nextra/locales.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/locales')
diff --git a/node_modules/nextra/package.json b/node_modules/nextra/package.json
index 47e2096..474cc88 100644
--- a/node_modules/nextra/package.json
+++ b/node_modules/nextra/package.json
@@ -3,15 +3,12 @@
   "version": "2.0.0-alpha.56",
   "description": "Next.js and MDX based site generator.",
   "main": "index.js",
-  "files": [
-    "dist/*",
-    "index.js",
-    "ssg.js",
-    "data.js",
-    "loader.js",
-    "locales.js",
-    "context.js"
-  ],
+  "exports": {
+    ".": "./dist/index.js",
+    "./loader": "./loader.js",
+    "./compile": "./dist/compile.mjs",
+    "./ssg": "./dist/ssg.js"
+  },
   "types": "./dist/types.d.ts",
   "repository": "https://github.com/shuding/nextra",
   "license": "MIT",
diff --git a/node_modules/nextra/ssg.js b/node_modules/nextra/ssg.js
deleted file mode 100755
index 9016f08..0000000
--- a/node_modules/nextra/ssg.js
+++ /dev/null
@@ -1 +0,0 @@
-module.exports = require('./dist/ssg')
